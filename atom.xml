<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>永红的互联网手记</title>
  
  <subtitle>我相信好代码和好产品改变世界！</subtitle>
  <link href="http://yonghong.tech/atom.xml" rel="self"/>
  
  <link href="http://yonghong.tech/"/>
  <updated>2020-10-19T02:24:00.000Z</updated>
  <id>http://yonghong.tech/</id>
  
  <author>
    <name>王永红(Micheal Wang)</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>技术爱好者周刊 第3期 | 2020年10月19日</title>
    <link href="http://yonghong.tech/weekly-003/"/>
    <id>http://yonghong.tech/weekly-003/</id>
    <published>2020-10-19T02:24:00.000Z</published>
    <updated>2020-10-19T02:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>技术爱好者周刊，每周一发布，欢迎提<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dhbmd5b25naG9uZy95b25naG9uZy1tZS9pc3N1ZXM=">issue<i class="fa fa-external-link-alt"></i></span>贡献内容。</p></blockquote><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9waW5nY2FwLmNvbS9jYXNlcy1jbi91c2VyLWNhc2UtY2hpbmEtbW9iaWxlLWxvdC8=">中移物联网在车联网场景的 TiDB 探索和实现<i class="fa fa-external-link-alt"></i></span><br>本次分享主要介绍车联网业务，它主要围绕车载位置终端和车载视频终端开展业务，包括停车卫士、路尚个人、路尚行业、和统一填装业务。截止 2020 年 5 月，累计接入 150 万终端，车联网用户主要是个人用户和企业用户，目前累计注册个人用户 151 万，累计注册企业用户 1471 个。</p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvaGRUZmpsQ3l4cExUNGh6blNoNE8xQQ==">基于微服务成熟度模型的高可用优化实践<i class="fa fa-external-link-alt"></i></span><br>随着微服务的流行，每个互联网公司后台都有无数大大小小的服务，服务与服务之间又有着千丝万缕的调用关系。要保证整个微服务系统的成熟稳定，就必须保证每个微服务的成熟度。但如何来定义服务的成熟度？应该从哪些纬度来考量？各个纬度里又有哪些普遍的问题？如何来优化？本文介绍了爱奇艺技术产品团队用来衡量服务成熟度的模型，并基于此模型对多个后台服务进行评估，总结出了一些常见的低分项，并对低分项整理了相关优化方案。希望对大家有所帮助。</p></li></ul><a id="more"></a><h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMTAvMTUvbXQtYWlvcHMtaG9yYWUuaHRtbA==">AIOps在美团的探索与实践——故障发现篇<i class="fa fa-external-link-alt"></i></span><br>美团技术团队在行业、业务领域知识和运维领域的知识等方面有着长期的积累，已经沉淀出不少工具和产品，实现了自动化运维，同时在AIOps方面也有一些初步的成果。我们希望通过在AIOps上持续投入、迭代和钻研，将之前积累的行业、业务和运维领域的知识应用到AIOps中，从而能让AIOps为业务研发、产品和运营团队赋能，提高整个公司的生产效率。</li></ul><h2 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMTAvMTUvYWNtbW0tMjAyMC1hbnN3ZXItZHJpdmVuLXZpc3VhbC1zdGF0ZS1lc3RpbWF0b3IuaHRtbA==">对话任务中的“语言-视觉”信息融合研究<i class="fa fa-external-link-alt"></i></span><br>目标导向的视觉对话是“视觉-语言”交叉领域中一个较新的任务，它要求机器能通过多轮对话完成视觉相关的特定目标。该任务兼具研究意义与应用价值。日前，北京邮电大学王小捷教授团队与美团AI平台NLP中心团队合作，在目标导向的视觉对话任务上的研究论文《Answer-Driven Visual State Estimator for Goal-Oriented Visual Dialogue-commentCZ》被国际多媒体领域顶级会议ACMMM 2020录用。</li></ul><h2 id="近期会议"><a href="#近期会议" class="headerlink" title="近期会议"></a>近期会议</h2><h3 id="IBM-数据与-AI-线上论坛"><a href="#IBM-数据与-AI-线上论坛" class="headerlink" title="IBM 数据与 AI 线上论坛"></a><span class="exturl" data-url="aHR0cHM6Ly9pYm0uNmNvbm5leC5jb20vZXZlbnQvY2hpbmFjZW50ZXIvREFWRi9sb2dpbg==">IBM 数据与 AI 线上论坛<i class="fa fa-external-link-alt"></i></span></h3><p>报名链接：<span class="exturl" data-url="aHR0cHM6Ly9pYm0uNmNvbm5leC5jb20vZXZlbnQvY2hpbmFjZW50ZXIvREFWRi9sb2dpbg==">https://ibm.6connex.com/event/chinacenter/DAVF/login<i class="fa fa-external-link-alt"></i></span></p><p>如果将AI在企业的落地与扩展过程视为一场“障碍跑”，那么AI技能的缺乏、AI的可信性、数据的复杂性即是横亘途中的三大障碍。这个夏天开始，IBM将为您诚意打造”数有价，AI无界 | IBM数据与AI线上论坛”，三大专场为您逐一击破三大障碍，加速将AI愿景落地为现实！全球视角与本地洞察紧密结合，一次注册，畅享三大主题专场，全力助您冲刺AI落地与规模化之旅！</p><p>■ 10月21日：掘金复杂数据，让数据为业务所用专场（待开放）<br>   您的数据为AI做好准备了吗?<br>   一起实现数据的轻松获取与组织，确保数据简单、可访问且为业务就绪。</p><p>10月21日， “掘金复杂数据，让数据为业务所用专场”即将开场，精彩抢鲜放送：</p><h3 id="CNCC-2020-中国计算机大会"><a href="#CNCC-2020-中国计算机大会" class="headerlink" title="CNCC 2020 中国计算机大会"></a><span class="exturl" data-url="aHR0cHM6Ly9jb25mLmNjZi5vcmcuY24v">CNCC 2020 中国计算机大会<i class="fa fa-external-link-alt"></i></span></h3><p>CNCC是由CCF主办的计算领域年度盛会，创建于2003年，是CCF旗舰会议，每年于不同城市举办，已成功举办十六届。每年金秋10月，IT专业人士相约CNCC；每届CNCC，都成为学术界、产业界群贤毕至的盛会。</p><p>CNCC是宏观论述技术趋势的大会，具有规格高、规模大、内容丰富的特点，会议形式包括大会特邀报告、大会论坛、技术论坛、特色活动及展览。为期三天的大会汇聚了图灵奖获得者、两院院士、国内外顶尖学者、知名企业家等亲临大会，展望前沿趋势，分享创新成果。CNCC得到了国际计算机界的高度关注，ACM 、IEEE CS、日本情报处理学会、韩国信息科学学会等国际计算机组织的高层人士都专程来华参加这一盛会。</p><p>CNCC不仅是交流前沿新知的讲坛，更是表彰杰出、分享成功的殿堂大会期间将揭晓CCF王选奖、CCF科学技术奖、CCF海外杰出贡献奖等重要奖项。近百名CCF优秀大学生奖获奖者也在会议期间接受表彰。同期举办的科技成果展和专业参观，为产学研搭建了交流、合作的平台。CNCC是一个开放式平台，除了大会特邀报告和专题论坛外，大会还提供场地，供参会者自发组织各种活动。</p><p>CNCC还引起了社会各界的广泛关注。新华社、CCTV、新浪网、人民网等知名媒体均在第一时间报道大会盛况。CCF也通过视频直播、微信微博、专题网站等，让更多人远程参加大会，分享最新趋势。</p><p>CCF每年资助近200名师生参加CNCC，让边远地区和经费缺乏单位的师生也有机会参加这一盛会，充分体现了CCF强烈的社会责任感。不断提升的影响力，不断刷新的参会人数，日趋丰富的精彩内容，种类繁多的参与形式，书写着CNCC探索新知、搭建平台的崇高理念，诠释着 CCF“计算技术改变人类生活”的执着追求。</p><h3 id="2020科大讯飞全球开发者大会"><a href="#2020科大讯飞全球开发者大会" class="headerlink" title="2020科大讯飞全球开发者大会"></a><span class="exturl" data-url="aHR0cHM6Ly8xMDI0LmlmbHl0ZWsuY29tLw==">2020科大讯飞全球开发者大会<i class="fa fa-external-link-alt"></i></span></h3><p>报名链接：<span class="exturl" data-url="aHR0cHM6Ly8xMDI0LmlmbHl0ZWsuY29tLw==">https://1024.iflytek.com/<i class="fa fa-external-link-alt"></i></span></p><p><img src="https://up-img.yonghong.tech/pic/2020/10/13-17-46-%E6%88%AA%E5%B1%8F2020-10-13%20%E4%B8%8B%E5%8D%885.46.37-XtozZN.png" alt="2020科大讯飞全球开发者大会"></p><p>科大讯飞全球1024开发者节是以AI开发者为受众群体的人工智能盛会，由科大讯飞发起并主办。选择在每年的10月24日，是因为在计算机世界中，1024是2的十次方，是二进制计数的基本计量单位之一，是1KB的字节数，因此组成了程序中的最基础基因序列。从事计算机工作的开发者就像一个个1024，以最具创新、最富热情的基础模块搭建起整个万物互联世界。 秉承“开放·合作·生态·共享”的理念，科大讯飞全球1024开发者节希望用最新最全的人工智能技术和产品促进跨行业链接、多领域碰撞、新技术开发，以科技之光、生态之念，立足当下、放眼未来。</p><h2 id="其他周报"><a href="#其他周报" class="headerlink" title="其他周报"></a>其他周报</h2><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1YW55Zi93ZWVrbHkvYmxvYi9tYXN0ZXIvZG9jcy9pc3N1ZS0xMjkubWQ=">科技爱好者周刊（第 129 期）：创业的凸函数和凹函数<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BvbGFyaXMxMTE5L2dvbGFuZ3dlZWtseS9ibG9iL21hc3Rlci9kb2NzL2lzc3VlLTA2NS5tZA==">Go语言爱好者周刊：第 65 期<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3plbmFueS93ZWVrbHkvYmxvYi9tYXN0ZXIvc29mdHdhcmUvMjAyMC8xMDEyLm1k">2020.10.12 - The Widening Responsibility for Front-End Developers<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N3aWZ0T2xkRHJpdmVyL2lPUy1XZWVrbHkvYmxvYi9tYXN0ZXIvUmVwb3J0cy8yMDIwLyUyMzEzMi0yMDIwLjEwLjE5Lm1k">老司机 iOS 周报 #132 | 2020-10-19<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9yd2Vla2x5Lm9yZy8yMDIwLTQxLmh0bWw=">R Weekly 2020-41 package development topics, contributing to rOpenSci, learnr and shiny<i class="fa fa-external-link-alt"></i></span></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;技术爱好者周刊，每周一发布，欢迎提&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL3dhbmd5b25naG9uZy95b25naG9uZy1tZS9pc3N1ZXM=&quot;&gt;issue&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;贡献内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;后端&quot;&gt;&lt;a href=&quot;#后端&quot; class=&quot;headerlink&quot; title=&quot;后端&quot;&gt;&lt;/a&gt;后端&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9waW5nY2FwLmNvbS9jYXNlcy1jbi91c2VyLWNhc2UtY2hpbmEtbW9iaWxlLWxvdC8=&quot;&gt;中移物联网在车联网场景的 TiDB 探索和实现&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;本次分享主要介绍车联网业务，它主要围绕车载位置终端和车载视频终端开展业务，包括停车卫士、路尚个人、路尚行业、和统一填装业务。截止 2020 年 5 月，累计接入 150 万终端，车联网用户主要是个人用户和企业用户，目前累计注册个人用户 151 万，累计注册企业用户 1471 个。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvaGRUZmpsQ3l4cExUNGh6blNoNE8xQQ==&quot;&gt;基于微服务成熟度模型的高可用优化实践&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;随着微服务的流行，每个互联网公司后台都有无数大大小小的服务，服务与服务之间又有着千丝万缕的调用关系。要保证整个微服务系统的成熟稳定，就必须保证每个微服务的成熟度。但如何来定义服务的成熟度？应该从哪些纬度来考量？各个纬度里又有哪些普遍的问题？如何来优化？本文介绍了爱奇艺技术产品团队用来衡量服务成熟度的模型，并基于此模型对多个后台服务进行评估，总结出了一些常见的低分项，并对低分项整理了相关优化方案。希望对大家有所帮助。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术爱好者周刊" scheme="http://yonghong.tech/categories/%E6%8A%80%E6%9C%AF%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A/"/>
    
    
    <category term="技术爱好者周刊" scheme="http://yonghong.tech/tags/%E6%8A%80%E6%9C%AF%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 5 发布了，可能升级失败，但请多给些尝试的机会！ (2020-10-10)</title>
    <link href="http://yonghong.tech/release/webpack-5-0/"/>
    <id>http://yonghong.tech/release/webpack-5-0/</id>
    <published>2020-10-13T13:00:00.000Z</published>
    <updated>2020-10-13T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>webpack 4 于 2018 年 2 月发布。<br>从那时起，我们在没有重大更新的情况下，推出了很多功能。<br>我们知道，人们不喜欢带有突破性的重大变化。<br>尤其是 webpack，人们通常一年只接触两次，剩下的时间就 “只管用”了。<br>但是，在不做突破性改动的情况下推出功能也是有成本的：<br>我们不能做重大的 API 或架构改进。</p><p>所以时不时就会有一个点，困难堆积起来，我们不得不做突破性的改动，才不至于把一切都搞乱。<br>这时候就需要一个新的主要版本了。<br>所以 webpack 5 包含了这些架构上的改进，以及没有这些改进就不可能实现的功能。</p><p>这个主要版本也是修改一些默认值的机会，并与此同时出现的建议和规范保持一致。</p><p>所以今天（2020-10-10）webpack 5.0.0 发布了，但这并不意味着它已经完成了，没有 bug，甚至功能完整。<br>就像 webpack 4 一样，我们通过修复问题和增加功能来继续开发。<br>在接下来的日子里，可能会有很多 bug 修复。功能会在以后出现。</p><a id="more"></a><h2 id="疑问解答"><a href="#疑问解答" class="headerlink" title="疑问解答"></a>疑问解答</h2><h3 id="那么发布意味着什么呢？"><a href="#那么发布意味着什么呢？" class="headerlink" title="那么发布意味着什么呢？"></a>那么发布意味着什么呢？</h3><p>这意味着我们完成了重大的变更。<br>许多重构已经完成，以提高架构的水平，并为未来的功能（和当前的功能）创建一个良好的基础。</p><h3 id="那么什么时候是升级的时候呢？"><a href="#那么什么时候是升级的时候呢？" class="headerlink" title="那么什么时候是升级的时候呢？"></a>那么什么时候是升级的时候呢？</h3><p>这要看情况。有一个很好的机会，升级失败，你需要给它第二次或第三次尝试。<br>如果你愿意的话，现在就尝试升级，并向 webpack、插件和加载器提供反馈。<br>我们很想解决这些问题。总得有人开始，而你将是第一批受益者之一。</p><h2 id="赞助情况"><a href="#赞助情况" class="headerlink" title="赞助情况"></a>赞助情况</h2><p>webpack 是完全基于<span class="exturl" data-url="aHR0cHM6Ly9vcGVuY29sbGVjdGl2ZS5jb20vd2VicGFjaw==">赞助<i class="fa fa-external-link-alt"></i></span>的。<br>它不像其他一些开源项目那样与大公司挂钩（并由其支付费用）。<br>99% 的赞助收入是根据贡献者和维护者的贡献来分配的。<br>我们相信将这些钱投资于使 webpack 变得更好。</p><p>但是由于疫情的原因，公司已经不怎么愿意赞助了。<br>在这种情况下，Webpack 也受到了影响（就像许多其他公司和人一样）。</p><p>我们从来没有能力支付给我们的贡献者我们认为他们应得的金额，但现在我们只有一半的钱，所以我们需要更严重的削减。<br>在情况好转之前，我们将只向贡献者和维护者支付前 10 天或每个月的工资。<br>其余的日子，他们可以自愿工作，由雇主支付工资，从事其他工作，或者休息一些日子。<br>这样我们就可以在前 10 天的工作中支付更多相当于投入时间的报酬。</p><p>我们最感激的是 <span class="exturl" data-url="aHR0cHM6Ly90ZWNoLnRyaXZhZ28uY29tL29wZW5zb3VyY2U=">trivago<i class="fa fa-external-link-alt"></i></span>，他们在过去的 3 年里为 webpack 提供了大量的赞助。<br>遗憾的是，由于受到 Covid-19 的冲击，他们今年无法继续赞助了。<br>希望有其他公司站出来，跟随这些（巨头）的脚步。</p><p>感谢所有的赞助者。</p><h2 id="整体方向"><a href="#整体方向" class="headerlink" title="整体方向"></a>整体方向</h2><p>这个版本的重点在于以下几点。</p><ul><li>尝试用持久性缓存来提高构建性能。</li><li>尝试用更好的算法和默认值来改进长期缓存。</li><li>尝试用更好的 Tree Shaking 和代码生成来改善包大小。</li><li>尝试改善与网络平台的兼容性。</li><li>尝试在不引入任何破坏性变化的情况下，清理那些在实现 v4 功能时处于奇怪状态的内部结构。</li><li>试图通过现在引入突破性的变化来为未来的功能做准备，使其能够尽可能长时间地保持在 v5 版本上。</li></ul><h2 id="迁移指南"><a href="#迁移指南" class="headerlink" title="迁移指南"></a><strong>迁移</strong>指南</h2><p><span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmRvY3NjaGluYS5vcmcvbWlncmF0ZS81">在这里可查阅迁移指南<i class="fa fa-external-link-alt"></i></span></p><h2 id="重大变更-功能清除"><a href="#重大变更-功能清除" class="headerlink" title="重大变更: 功能清除"></a>重大变更: 功能清除</h2><h3 id="清理弃用的能力"><a href="#清理弃用的能力" class="headerlink" title="清理弃用的能力"></a>清理弃用的能力</h3><p>所有在 v4 中被废弃的能力都被移除。</p><p>迁移: 确保你的 webpack 4 构建没有打印废弃警告。</p><p>以下是一些被移除但在 v4 中没有废弃警告的东西：</p><ul><li>IgnorePlugin 和 BannerPlugin 现在必须只传递一个参数，这个参数可以是对象、字符串或函数。</li></ul><h3 id="废弃代码"><a href="#废弃代码" class="headerlink" title="废弃代码"></a>废弃代码</h3><p>新的弃用包括一个弃用代码，这样他们更容易被引用。</p><h3 id="语法废弃"><a href="#语法废弃" class="headerlink" title="语法废弃"></a>语法废弃</h3><p><code>require.include</code>已被废弃，使用时默认会发出警告。</p><p>可以通过 <code>Rule.parser.requireInclude</code> 将行为改为允许、废弃或禁用。</p><h3 id="不再为-Node-js-模块-自动引用-Polyfills"><a href="#不再为-Node-js-模块-自动引用-Polyfills" class="headerlink" title="不再为 Node.js 模块 自动引用 Polyfills"></a>不再为 Node.js 模块 自动引用 Polyfills</h3><p>在早期，webpack 的目的是为了让大多数的 Node.js 模块运行在浏览器中，但如今模块的格局已经发生了变化，现在许多模块主要是为前端而编写。webpack &lt;= 4 的版本中提供了许多 Node.js 核心模块的 polyfills，一旦某个模块引用了任何一个核心模块（如 <code>cypto</code> 模块），webpack 就会自动引用这些 polyfills。</p><p>尽管这会使得使用为 Node.js 编写模块变得容易，但它在构建时给 bundle 附加了庞大的 polyfills。在大部分情况下，这些 polyfills 并非必须。</p><p>从 webpack 5 开始不再自动填充这些 polyfills，而会专注于前端模块兼容。我们的目标是提高 web 平台的兼容性。</p><p>迁移：</p><ul><li>尽量使用前端兼容的模块。</li><li>可以手动为 Node.js 核心模块添加 polyfill。错误提示会告诉你如何实现。</li><li>Package 作者：在 <code>package.json</code> 中添加 <code>browser</code> 字段，使 package 与前端兼容。为浏览器提供其他的实现/dependencies。</li></ul><h2 id="重大变更：长期缓存"><a href="#重大变更：长期缓存" class="headerlink" title="重大变更：长期缓存"></a>重大变更：长期缓存</h2><h3 id="确定的-Chunk、模块-ID-和导出名称"><a href="#确定的-Chunk、模块-ID-和导出名称" class="headerlink" title="确定的 Chunk、模块 ID 和导出名称"></a>确定的 Chunk、模块 ID 和导出名称</h3><p>新增了长期缓存的算法。这些算法在生产模式下是默认启用的。</p><p><code>chunkIds: &quot;deterministic&quot;</code><br><code>moduleIds: &quot;deterministic&quot;</code><br><code>mangleExports: &quot;deterministic&quot;</code></p><p>该算法以确定性的方式为模块和分块分配短的（3 或 5 位）数字 ID，<br>这是包大小和长期缓存之间的一种权衡。</p><p><code>moduleIds/chunkIds/mangleExports: false</code> 禁用默认行为，你可以通过插件提供一个自定义算法。请注意，在 webpack 4 中，<code>moduleIds/chunkIds: false</code> 如果没有自定义插件，则可以正常运行，而在 webpack 5 中，你必须提供一个自定义插件。</p><p><strong>迁移</strong>：最好使用 <code>chunkIds</code>、<code>moduleIds</code> 和 <code>mangleExports</code> 的默认值。你也可以选择使用旧的默认值<code>chunkIds: &quot;size&quot;，moduleIds: &quot;size&quot;, mangleExports: &quot;size&quot;</code>，这将会生成更小的包，但为了缓存，会更频繁地将其失效。</p><p>注意：在 webpack 4 中，散列的模块 id 会导致 gzip 性能降低。这与模块顺序的改变有关，已经被修正。</p><p>注意：在 webpack 5 中，<code>deterministic</code> Ids 在生产模式下是默认启用的。</p><h3 id="真正的内容哈希"><a href="#真正的内容哈希" class="headerlink" title="真正的内容哈希"></a>真正的内容哈希</h3><p>当使用 <code>[contenthash]</code> 时，Webpack 5 将使用真正的文件内容哈希值。之前它 “只” 使用内部结构的哈希值。<br>当只有注释被修改或变量被重命名时，这对长期缓存会有积极影响。这些变化在压缩后是不可见的。</p><h2 id="重大变更：开发支持"><a href="#重大变更：开发支持" class="headerlink" title="重大变更：开发支持"></a>重大变更：开发支持</h2><h3 id="命名代码块-ID"><a href="#命名代码块-ID" class="headerlink" title="命名代码块 ID"></a>命名代码块 ID</h3><p>在开发模式下，默认启用的新命名代码块 ID 算法为模块（和文件名）提供了人类可读的名称。<br>模块 ID 由其路径决定，相对于 <code>context</code>。<br>代码块 ID 由代码块的内容决定。</p><p>所以你不再需要使用<code>import(/* webpackChunkName: &quot;name&quot; */ &quot;module&quot;)</code>来调试。<br>但如果你想控制生产环境的文件名，还是有意义的。</p><p>可以在生产环境中使用 <code>chunkIds: &quot;named&quot;</code> 在生产环境中使用，但要确保不要不小心暴露模块名的敏感信息。</p><p>迁移：如果你不喜欢在开发中改变文件名，你可以通过 <code>chunkIds: &quot;natural&quot;</code> 来使用旧的数字模式。</p><h3 id="模块联邦"><a href="#模块联邦" class="headerlink" title="模块联邦"></a>模块联邦</h3><p>Webpack 5 增加了一个新的功能 “模块联邦”，它允许多个 webpack 构建一起工作。<br>从运行时的角度来看，多个构建的模块将表现得像一个巨大的连接模块图。<br>从开发者的角度来看，模块可以从指定的远程构建中导入，并以最小的限制来使用。</p><p>更多细节请参见<span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmRvY3NjaGluYS5vcmcvY29uY2VwdHMvbW9kdWxlLWZlZGVyYXRpb24=">本单独指南<i class="fa fa-external-link-alt"></i></span>。</p><h2 id="重大变更：支持崭新的-Web-平台特性"><a href="#重大变更：支持崭新的-Web-平台特性" class="headerlink" title="重大变更：支持崭新的 Web 平台特性"></a>重大变更：支持崭新的 Web 平台特性</h2><h3 id="JSON-模块"><a href="#JSON-模块" class="headerlink" title="JSON 模块"></a>JSON 模块</h3><p>JSON 模块现在与提案保持一致，并在使用非默认导出时发出警告。<br>当从严格的 ECMAScript 模块导入时，JSON 模块不再有命名的导出。</p><p>迁移: 使用默认导出。</p><p>即使使用默认导出，未使用的属性也会被 <code>optimization.usedExports</code> 优化丢弃，属性会被 <code>optimization.mangleExports</code> 优化打乱。</p><p>可以在 <code>Rule.parser.parse</code> 中指定一个自定义的 JSON 解析器来导入类似 JSON 的文件（例如针对 toml、yaml、json5 等）。</p><h3 id="import-meta"><a href="#import-meta" class="headerlink" title="import.meta"></a>import.meta</h3><ul><li><code>import.meta.webpackHot</code> 是 <code>module.hot</code> 的别名，在严格的 ESM 中也可以使用。</li><li><code>import.meta.webpack</code> 是 webpack 的主要版本号。</li><li><code>import.meta.url</code> 是当前文件的 <code>file:</code> url(类似于<code>__filename</code>，但作为文件 url)。</li></ul><h3 id="资源模块"><a href="#资源模块" class="headerlink" title="资源模块"></a>资源模块</h3><p>Webpack 5 现在已经对表示资源的模块提供了内置支持。<br>这些模块可以向输出文件夹发送一个文件，或者向 javascript 包注入一个 DataURI。<br>无论哪种方式，它们都会给出一个 URL 来工作。</p><p>它们可以通过多种方式被使用：</p><ul><li><code>import url from &quot;./image.png&quot;</code> 和 在<code>module.rule</code> 中设置 <code>type: &quot;asset&quot;</code> 当匹配这样的导入时。(老方法)</li><li><code>new URL(&quot;./image.png&quot;, import.meta.url)</code> (新方式)</li></ul><p>选择 “新的方式 “语法是为了允许在没有打包工具的情况下运行代码。这种语法也可以在浏览器中的原生 ECMAScript 模块中使用。</p><h3 id="原生-Worker-支持"><a href="#原生-Worker-支持" class="headerlink" title="原生 Worker 支持"></a>原生 Worker 支持</h3><p>当把资源的 <code>new URL</code> 和 <code>new Worker</code>/<code>new SharedWorker</code>/<code>navigator.serviceWorker.register</code> 结合起来时，webpack 会自动为 web worker 创建一个新的入口点（entrypoint）。</p><p><code>new Worker(new URL(&quot;./worker.js&quot;, import.meta.url))</code></p><p>选择这种语法也是为了允许在没有打包工具的情况下运行代码。这种语法在浏览器的原生 ECMAScript 模块中也可以使用。</p><h3 id="URIs"><a href="#URIs" class="headerlink" title="URIs"></a>URIs</h3><p>Webpack 5 支持在请求中处理协议。</p><ul><li>支持<code>data:</code>。支持 Base64 或原始编码。Mimetype 可以在<code>module.rule</code>中被映射到加载器和模块类型。例如：<code>import x from &quot;data:text/javascript,export default 42&quot;</code>。</li><li>支持<code>file:</code>。</li><li>支持<code>http(s):</code>，但需要通过<code>new webpack.experiments.s schemesHttp(s)UriPlugin()</code>选择加入。<ul><li>默认情况下，当目标为 “web “时，这些 URI 会导致对外部资源的请求（它们是外部资源）。</li></ul></li></ul><p>支持请求中的片段。例如：<code>./file.js#fragment</code>。</p><h3 id="异步模块"><a href="#异步模块" class="headerlink" title="异步模块"></a>异步模块</h3><p>Webpack 5 支持所谓的 “异步模块”。<br>这些模块并不是同步解析的，而是基于异步和 Promise 的。</p><p>通过 “import “导入它们会被自动处理，不需要额外的语法，而且几乎看不出区别。</p><p>通过<code>require()</code>导入它们会返回一个解析到导出的 Promise。</p><p>在 webpack 中，有多种方式来拥有异步模块。</p><ul><li>异步的外部资源(async externals)</li><li>新规范中的 WebAssembly 模块</li><li>使用顶层 Await 的 ECMAScript 模块。</li></ul><h3 id="外部资源"><a href="#外部资源" class="headerlink" title="外部资源"></a>外部资源</h3><p>Webpack 5 增加了更多的外部类型来覆盖更多的应用：</p><p><code>promise</code>: 一个评估为 Promise 的表达式。外部模块是一个异步模块，解析值作为模块导出使用。</p><p><code>import</code>。原生的 <code>import()</code> 用于加载指定的请求，外部模块是一个异步模块，解析值作为模块导出。外部模块是一个异步模块。</p><p><code>module</code>: 尚未实现，但计划通过 <code>import x from &quot;...&quot;</code> 加载模块。</p><p><code>script</code>: 通过 <code>&lt;script&gt;</code> 标签加载一个 url，并从一个全局变量（以及它的可选属性）中获取输出。外部模块是一个异步模块。</p><h2 id="重大变更：支持全新的-Node-js-生态特性"><a href="#重大变更：支持全新的-Node-js-生态特性" class="headerlink" title="重大变更：支持全新的 Node.js 生态特性"></a>重大变更：支持全新的 Node.js 生态特性</h2><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>现在支持 package.json 中的 <code>exports</code> 和 <code>imports</code> 字段。</p><p>原生支持 Yarn PnP。</p><p>更多细节请参见<span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmRvY3NjaGluYS5vcmcvZ3VpZGVzL3BhY2thZ2UtZXhwb3J0cy8=">package exports<i class="fa fa-external-link-alt"></i></span>。</p><h2 id="重大变更：开发体验"><a href="#重大变更：开发体验" class="headerlink" title="重大变更：开发体验"></a>重大变更：开发体验</h2><h3 id="经过优化的构建目标-target"><a href="#经过优化的构建目标-target" class="headerlink" title="经过优化的构建目标(target)"></a>经过优化的构建目标(target)</h3><p>Webpack 5 允许传递一个目标列表，并且支持目标的版本。</p><p>例如 <code>target: &quot;node14&quot;``target: [&quot;web&quot;, &quot;es2020&quot;]</code>。</p><p>这是一个简单的方法，为 webpack 提供它需要确定的所有信息：</p><ul><li>代码块加载机制，以及</li><li>支持的语法，如箭头函数</li></ul><h3 id="Stats"><a href="#Stats" class="headerlink" title="Stats"></a>Stats</h3><p>改进了统计测试格式的可读性和冗余性。改进了默认值，使其不那么冗长，也适合大型构建。</p><ul><li>现在默认情况下，代码块关系是隐藏的，可以用 <code>stats.chunkRelations</code> 来切换。</li><li>Stats 现在可以区分 <code>files</code> 和 <code>auxiliaryFiles</code>。</li><li>Stats 现在默认隐藏模块和代码块的 id。这可以通过 <code>stats.ids</code> 来切换。</li><li>现在所有模块的列表是按照到入口点的距离排序的。这可以通过 <code>stats.modulesSort</code> 来改变。</li><li>代码块模块的列表现在按模块名称排序。这可以通过 <code>stats.chunkModulesSort</code> 来改变。</li><li>嵌套模块的列表现在是按拓扑结构排序的。这可以通过 <code>stats.nestedModulesSort</code> 来改变。</li><li>现在，代码块和资源会显示代码块 id 提示。</li><li>资产和模块将以树状而不是列表/表格的形式显示。</li><li>一般信息现在会在最后的摘要中显示。它显示了 webpack 版本，配置名称和警告/错误计数。</li><li>哈希值现在默认是隐藏的。这可以通过 <code>stats.hash</code> 来改变。</li><li>默认情况下不再显示构建的时间戳，这可以通过 <code>stats.builtAt</code> 开启。它会在摘要中显示时间戳。</li><li>默认情况下，不再显示子编译。它们可以用 <code>stats.children</code> 来显示。</li></ul><h3 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h3><p>对 <code>ProgressPlugin</code> 做了一些改进，它被 CLI 在参数 <code>--progress</code> 开启时使用，但也可以作为插件手动使用。</p><p>以前它只计算已处理的模块。现在它可以计算 “入口”、”依赖” 和 “模块”。<br>现在所有的模块都默认显示了。</p><p>以前它只显示当前处理的模块。这造成了很多 stderr 输出，在一些控制台上产生了性能问题。<br>现在这个功能被默认关闭（<code>activeModules</code> 选项）。这也减少了控制台的垃圾信息量。<br>现在，在构建模块的过程中，向 stderr 写入的时间被控制在 500ms 以内。</p><p>剖析模式也得到了升级，将显示嵌套进度消息的时间。<br>这使得它更容易弄清楚，当插件导致了性能问题。</p><p>新增加的 <code>percentBy</code> -选项告知 <code>ProgressPlugin</code> 如何计算进度百分比。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.ProgressPlugin(&#123; <span class="attr">percentBy</span>: <span class="string">&#x27;entries&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><p>为了使进度百分比更准确，<code>ProgressPlugin</code> 会缓存最后已知的总模块数，并在下一次构建时重新使用这个值。第一次构建将预热缓存，但后续构建将使用并更新这个值。</p><h3 id="自动添加唯一命名"><a href="#自动添加唯一命名" class="headerlink" title="自动添加唯一命名"></a>自动添加唯一命名</h3><p>在 webpack 4 中，多个 webpack 运行时可能会在同一个 HTML 页面上发生冲突，因为它们使用同一个全局变量进行代码块加载。为了解决这个问题，需要为 <code>output.jsonpFunction</code> 配置提供一个自定义的名称。</p><p>Webpack 5 确实会从 <code>package.json</code> <code>name</code> 中自动推断出一个唯一的构建名称，并将其作为 <code>output.uniqueName</code> 的默认值。</p><p>这个值用于使所有潜在的冲突的全局变量成为唯一。</p><p>迁移: 由于 <code>package.json</code> 中有唯一的名称，可将 <code>output.jsonpFunction</code> 删除。</p><h3 id="自动添加公共路径"><a href="#自动添加公共路径" class="headerlink" title="自动添加公共路径"></a>自动添加公共路径</h3><p>Webpack 5 会在可能的情况下自动确定 <code>output.publicPath</code>。</p><h3 id="Typescript-类型"><a href="#Typescript-类型" class="headerlink" title="Typescript 类型"></a>Typescript 类型</h3><p>Webpack 5 从源码中生成 typescript 类型，并通过 npm 包暴露它们。</p><p>迁移：删除<code>@types/webpack</code>。当名称不同时更新引用。</p><h2 id="重大变更-构建优化"><a href="#重大变更-构建优化" class="headerlink" title="重大变更: 构建优化"></a>重大变更: 构建优化</h2><h3 id="嵌套的-tree-shaking"><a href="#嵌套的-tree-shaking" class="headerlink" title="嵌套的 tree-shaking"></a>嵌套的 tree-shaking</h3><p>webpack 现在能够跟踪对导出的嵌套属性的访问。这可以改善重新导出命名空间对象时的 Tree Shaking（清除未使用的导出和混淆导出）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inner.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> inner <span class="keyword">from</span> <span class="string">&#x27;./inner&#x27;</span>;</span><br><span class="line"><span class="comment">// 或 import * as inner from &#x27;./inner&#x27;; export &#123; inner &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="built_in">module</span> <span class="keyword">from</span> <span class="string">&#x27;./module&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.inner.a);</span><br></pre></td></tr></table></figure><p>在这个例子中，可以在生产模式下删除导出的<code>b</code>。</p><h3 id="内部模块-tree-shaking"><a href="#内部模块-tree-shaking" class="headerlink" title="内部模块 tree-shaking"></a>内部模块 tree-shaking</h3><p>webpack 4 没有分析模块的导出和引用之间的依赖关系。webpack 5 有一个新的选项 <code>optimization.innerGraph</code>，在生产模式下是默认启用的，它可以对模块中的标志进行分析，找出导出和引用之间的依赖关系。</p><p>在这样的模块中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">&#x27;./something&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usingSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> usingSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部依赖图算法会找出 <code>something</code> 只有在使用 <code>test</code> 导出时才会使用。这允许将更多的出口标记为未使用，并从代码包中省略更多的代码。</p><p>当设置<code>&quot;sideEffects&quot;: false</code>时，可以省略更多的模块。在这个例子中，当 <code>test</code> 导出未被使用时，<code>./something</code> 将被省略。</p><p>要获得未使用的导出信息，需要使用 <code>optimization.unusedExports</code>。要删除无副作用的模块，需要使用<code>optimization.sideEffects</code>。</p><p>可以分析以下标记。</p><ul><li>函数声明</li><li>类声明</li><li><code>默认导出export default</code> 或定义变量以下的：<ul><li>函数表达式</li><li>类表达式</li><li>顺序表达式</li><li><code>/*#__PURE__*/</code> 表达式</li><li>局部变量</li><li>引入的捆绑(bindings)</li></ul></li></ul><p>反馈：如果你发现这个分析中缺少什么，请报告一个问题，我们会考虑增加它。</p><p>使用 <code>eval()</code> 将为一个模块放弃这个优化，因为经过 eval 的代码可以引用范围内的任何标记。</p><p>这种优化也被称为深度范围分析。</p><h3 id="CommonJs-Tree-Shaking"><a href="#CommonJs-Tree-Shaking" class="headerlink" title="CommonJs Tree Shaking"></a>CommonJs Tree Shaking</h3><p>webpack 曾经不进行对 CommonJs 导出和 <code>require()</code> 调用时的导出使用分析。</p><p>webpack 5 增加了对一些 CommonJs 构造的支持，允许消除未使用的 CommonJs 导出，并从 <code>require()</code> 调用中跟踪引用的导出名称。</p><p>支持以下构造：</p><ul><li><code>exports|this|module.exports.xxx = ...</code></li><li><code>exports|this|module.exports = require(&quot;...&quot;)</code> (reexport)</li><li><code>exports|this|module.exports.xxx = require(&quot;...&quot;).xxx</code> (reexport)</li><li><code>Object.defineProperty(exports|this|module.exports, &quot;xxx&quot;, ...)</code></li><li><code>require(&quot;abc&quot;).xxx</code></li><li><code>require(&quot;abc&quot;).xxx()</code></li><li>从 ESM 导入</li><li><code>require()</code> 一个 ESM 模块</li><li>被标记的导出类型 (对非严格 ESM 导入做特殊处理):<ul><li><code>Object.defineProperty(exports|this|module.exports, &quot;__esModule&quot;, &#123; value: true|!0 &#125;)</code></li><li><code>exports|this|module.exports.__esModule = true|!0</code></li></ul></li><li>未来计划支持更多的构造</li></ul><p>当检测到不可分析的代码时，webpack 会放弃，并且完全不跟踪这些模块的导出信息（出于性能考虑）。</p><h3 id="副作用分析"><a href="#副作用分析" class="headerlink" title="副作用分析"></a>副作用分析</h3><p>在 package.json 中的 <code>&quot;sideEffects&quot;</code> 标志允许手动将模块标记为无副作用，这就允许在不使用时放弃它们。</p><p>webpack 5 也可以根据对源代码的静态分析，自动将模块标记为无副作用。</p><h3 id="每个运行时的优化"><a href="#每个运行时的优化" class="headerlink" title="每个运行时的优化"></a>每个运行时的优化</h3><p>Webpack 5 现在能够（默认情况下也是如此）分析和优化每个运行时的模块（一个运行时通常等于一个入口点）。<br>这允许只在真正需要的地方导出这些入口点。<br>入口点之间不会相互影响 (只要每个入口点使用一个运行时)</p><h3 id="模块合并"><a href="#模块合并" class="headerlink" title="模块合并"></a>模块合并</h3><p>模块合并也可以在每个运行时工作，允许每个运行时进行不同的合并</p><p>模块合并已经成为一等公民，现在任何模块和依赖都可以实现它。<br>在初始时 webpack 5 已经添加了对 ExternalModules 和 json 模块的支持，更多的模块可能很快就会发布。</p><h3 id="通用-Tree-Shaking-改进"><a href="#通用-Tree-Shaking-改进" class="headerlink" title="通用 Tree Shaking 改进"></a>通用 Tree Shaking 改进</h3><p><code>export *</code> 已经得到改进，可以跟踪更多的信息，并且不再将<code>默认</code>导出标记为使用。</p><p><code>export *</code> 现在会在 webpack 确定有冲突的导出时显示警告。</p><p><code>import()</code> 允许通过 <code>/* webpackExports: [&quot;abc&quot;, &quot;default&quot;] */</code> 该魔法注释手动 tree shake 模块。</p><h3 id="开发与生产的一致性问题"><a href="#开发与生产的一致性问题" class="headerlink" title="开发与生产的一致性问题"></a>开发与生产的一致性问题</h3><p>我们试图通过改善两种模式的相似性，在开发模式的构建性能和避免仅在生产模式的产生的问题之间找到一个很好的平衡点。</p><p>Webpack 5 默认在两种模式下都启用了 “sideEffects “优化。在 webpack 4 中，由于 package.json 中的<code>&quot;sideEffects&quot;</code>标记不正确，这种优化导致了一些只在生产模式下出现的错误。在开发过程中启用这个优化可以更快更容易地发现这些问题。</p><p>在很多情况下，开发和生产都是在不同的操作系统上进行的，文件系统的大小写敏感度不同，所以 webpack 5 增加了一些奇怪的大小写的警告/错误。</p><h3 id="改进代码生成"><a href="#改进代码生成" class="headerlink" title="改进代码生成"></a>改进代码生成</h3><p>当 ASI 发生时，webpack 会检测到，当没有分号插入时，会生成更短的代码。<code>Object(...)</code>-&gt;<code>(0, ...)</code>。</p><p>webpack 将多个导出的 getters 合并为一个运行时函数调用。<code>r.d(x, &quot;a&quot;, () =&gt; a); r.d(x, &quot;b&quot;, () =&gt; b);</code> -&gt; <code>r.d(x, &#123;a: () =&gt; a, b: () =&gt; b&#125;);</code>。</p><p>现在在 <code>output.environment</code> 中有额外的选项。<br>它们允许指定哪些 ECMAScript 特性可以用于 webpack 生成的运行时代码。</p><p>通常人们不会直接指定这个选项，而是会使用 <code>target</code> 选项。</p><p>webpack 4 之前只生成 ES5 的代码。<br>webpack 5 则现在既可以生成 ES5 又可以生成 ES6/ES2015 代码。</p><p>只支持现代浏览器，将使用箭头函数生成更短的代码，使用 <code>const</code> 声明与 TDZ 为 <code>export default</code> 生成更符合规范的代码。</p><h3 id="改进-target-配置"><a href="#改进-target-配置" class="headerlink" title="改进 target 配置"></a>改进 <code>target</code> 配置</h3><p>在 webpack 4 中，”target “是在 <code>&quot;web&quot;</code> 和 <code>&quot;node&quot;</code> 之间的一个粗略的选择（还有一些其他的）。<br>Webpack 5 给你更多的选择。</p><p><code>target</code>选项现在比以前影响了更多关于生成代码的事情。</p><ul><li>代码块加载方法</li><li>代码块的格式</li><li>wasm 加载方法</li><li>代码块与 wasm 在 workers 中加载方法</li><li>被使用的全局对象</li><li>publicPath 是否应该被自动确定</li><li>生成的代码中使用的 ECMAScript 特性/语法</li><li><code>externals</code> 是否默认被启用</li><li>一些 Node.js 兼容层的行为(<code>global</code>, <code>__filename</code>, <code>__dirname</code>)</li><li>模块解析(<code>browser</code> 字段、<code>exports</code> 和 <code>imports</code> 条件)</li><li>一些加载器可能会基于此改变行为</li></ul><p>对于其中的一些情况，在 <code>&quot;web&quot;</code> 和 <code>&quot;node&quot;</code> 之间的选择过于粗略，我们需要更多的信息。<br>因此，我们允许指定最低版本，例如 <code>&quot;node10.13&quot;</code>，并推断出更多关于目标环境的属性。</p><p>现在也允许用一个数组组合多个目标，webpack 将确定所有目标的最小属性。使用数组也很有用，当使用像 <code>&quot;web&quot;</code> 或 <code>&quot;node&quot;</code> 这样没有提供完整信息的目标时（没有版本号）。例如，<code>[&quot;web&quot;, &quot;es2020&quot;]</code> 结合了这两个部分目标。</p><p>有一个目标 <code>&quot;browserslist&quot;</code>，它将使用 browserslist 类库的数据来确定环境的属性。<br>当项目中存在可用的 browserslist 配置时，这个目标也会被默认使用。当没有可用的配置时，默认使用 <code>&quot;web&quot;</code> 目标。</p><p>有些组合和功能还没有实现，会导致错误。它们是为未来的功能做准备。例如：</p><ul><li><code>[&quot;web&quot;, &quot;node&quot;]</code> 将导致一个通用的代码块加载方法，而这个方法还没有实现。</li><li><code>[&quot;web&quot;, &quot;node&quot;]</code> + <code>output.module: true</code>将导致一个模块代码块加载方法，该方法尚未实现。</li><li><code>&quot;web&quot;</code>会导致<code>http(s):</code>的导入被视为<code>模块</code>外部资源，而这些外部还没有实现(变通方法：<code>externalsPresets.&#123; web: false, webAsync: true &#125;</code>，将使用<code>import()</code>代替)。</li></ul><h3 id="代码块拆分与模块大小"><a href="#代码块拆分与模块大小" class="headerlink" title="代码块拆分与模块大小"></a>代码块拆分与模块大小</h3><p>现在模块的尺寸比单一的数字更好的表达方式。现在有不同类型的大小。</p><p>SplitChunksPlugin 现在知道如何处理这些不同的大小，并将它们用于 <code>minSize</code> 和 <code>maxSize</code>。<br>默认情况下，只有 <code>javascript</code> 大小被处理，但你现在可以传递多个值来管理它们：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      minSize: &#123;</span><br><span class="line">        javascript: <span class="number">30000</span>,</span><br><span class="line">        webassembly: <span class="number">50000</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你仍然可以使用一个数字来表示大小。在这种情况下，webpack 会自动使用默认的大小类型。</p><p><code>mini-css-extract-plugin</code> 使用 <code>css/mini-extra</code> 作为大小类型，并将此大小类型自动添加到默认类型中。</p><h2 id="重大变更：性能优化"><a href="#重大变更：性能优化" class="headerlink" title="重大变更：性能优化"></a>重大变更：性能优化</h2><h3 id="持久缓存"><a href="#持久缓存" class="headerlink" title="持久缓存"></a>持久缓存</h3><p>现在有一个文件系统缓存。它是可选的，可以通过以下配置启用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  cache: &#123;</span><br><span class="line">    <span class="comment">// 1. 将缓存类型设置为文件系统</span></span><br><span class="line">    type: <span class="string">&#x27;filesystem&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    buildDependencies: &#123;</span><br><span class="line">      <span class="comment">// 2. 将你的 config 添加为 buildDependency，以便在改变 config 时获得缓存无效</span></span><br><span class="line">      config: [__filename],</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 如果你有其他的东西被构建依赖，你可以在这里添加它们</span></span><br><span class="line">      <span class="comment">// 注意，webpack、加载器和所有从你的配置中引用的模块都会被自动添加</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>重要说明：</p><p>默认情况下，webpack 假定 webpack 所在的 <code>node_modules</code> 目录只被包管理器修改。对 <code>node_modules</code> 来说，哈希值和时间戳会被跳过。<br>出于性能考虑，只使用包名和版本。<br>只要不指定<code>resolve.symlinks: false</code>，Symlinks(即<code>npm/yarn link</code>)就没有问题(无论如何都要避免)。<br>不要直接编辑 <code>node_modules</code> 中的文件，除非你用 <code>snapshot.managedPaths: []</code>以剔除该优化。<br>当使用 Yarn PnP 时，webpack 假设 yarn 缓存是不可改变的（通常是这样）。<br>你可以使用 <code>snapshot.immutablePaths: []</code> 来退出这个优化。</p><p>缓存将默认存储在 <code>node_modules/.cache/webpack</code>（当使用 node_modules 时）或 <code>.yarn/.cache/webpack</code>（当使用 Yarn PnP 时）中。<br>当所有的插件都正确处理缓存时，你可能永远都不需要手动删除它。</p><p>许多内部插件也会使用持久性缓存。例如 <code>SourceMapDevToolPlugin</code> (缓存 SourceMap 的生成)或 <code>ProgressPlugin</code> (缓存模块数量)</p><p>持久性缓存将根据使用情况自动创建多个缓存文件，以优化对缓存的读写访问。</p><p>默认情况下，时间戳将用于开发模式的快照，而文件哈希将用于生产模式。<br>文件哈希也允许在 CI 中使用持久性缓存。</p><h3 id="编译器闲置和关闭"><a href="#编译器闲置和关闭" class="headerlink" title="编译器闲置和关闭"></a>编译器闲置和关闭</h3><p>编译器现在需要在使用后关闭。编译器现在会进入和离开空闲状态，并且有这些状态的钩子。插件可能会使用这些钩子来做不重要的工作。(即将持久缓存缓慢地将缓存存储到磁盘上)。在编译器关闭时–所有剩余的工作应该尽可能快地完成。一个回调标志着关闭完成。</p><p>插件和它们各自的作者应该预料到，有些用户可能会忘记关闭编译器。所以，所有的工作最终也应该在空闲状态下完成。当工作正在进行时，应该防止进程退出。</p><p><code>webpack()</code> 用法在被传递回调时自动调用<code>close</code>。</p><p>迁移：在使用 Node.js API 时，一定要在完成工作后调用 <code>Compiler.close</code>。</p><h3 id="文件生成"><a href="#文件生成" class="headerlink" title="文件生成"></a>文件生成</h3><p>webpack 过去总是在第一次构建时发出所有的输出文件，但在增量（观察）构建时跳过了写入未更改的文件。<br>假设在 webpack 运行时，没有任何其他东西改变输出文件。</p><p>增加了持久性缓存后，即使在重启 webpack 进程时，也应该会有类似监听的体验，但如果认为即使在 webpack 不运行时也没有其他东西改变输出目录，那这个假设就太强了。</p><p>所以 webpack 现在会检查输出目录中现有的文件，并将其内容与内存中的输出文件进行比较。只有当文件被改变时，它才会写入文件。<br>这只在第一次构建时进行。任何增量构建都会在运行中的 webpack 进程中生成新的资产时写入文件。</p><p>我们假设 webpack 和插件只有在内容被改变时才会生成新的资产。应该使用缓存来确保在输入相同时不会生成新的资产。<br>不遵循这个建议会降低性能。</p><p>被标记为 <code>[不可变]</code> 的文件（包括内容哈希），当已经存在一个同名文件时，将永远不会被写入。<br>我们假设当文件内容发生变化时，内容哈希会发生变化。<br>这在一般情况下是正确的，但在 webpack 或插件开发过程中可能并不总是如此。</p><h2 id="重大变更：长期未解决的问题"><a href="#重大变更：长期未解决的问题" class="headerlink" title="重大变更：长期未解决的问题"></a>重大变更：长期未解决的问题</h2><h3 id="单一文件目标的代码分割"><a href="#单一文件目标的代码分割" class="headerlink" title="单一文件目标的代码分割"></a>单一文件目标的代码分割</h3><p>只允许启动单个文件的目标（如 node、WebWorker、electron main）现在支持运行时自动加载引导所需的依赖代码片段。</p><p>这允许对这些目标使用 <code>chunks: &quot;all&quot;</code> 和 <code>optimization.runtimeChunk</code>。</p><p>请注意，如果目标的代码块加载是异步的，这使得初始评估也是异步的。当使用 <code>output.library</code> 时，这可能是一个问题，因为现在导出的值是一个 Promise。</p><h3 id="更新了解析器"><a href="#更新了解析器" class="headerlink" title="更新了解析器"></a>更新了解析器</h3><p><code>enhanced-resolve</code> 更新到了 v5，有以下改进：</p><ul><li>追踪更多的依赖关系，比如丢失的文件。</li><li>别名可能有多种选择</li><li>现在可以别名为 <code>false</code> 了。</li><li>支持 <code>exports</code> 和 <code>imports</code> 字段等功能。</li><li>性能提高</li></ul><h3 id="没有-JS-的代码块"><a href="#没有-JS-的代码块" class="headerlink" title="没有 JS 的代码块"></a>没有 JS 的代码块</h3><p>不包含 JS 代码的块，将不再生成 JS 文件。<br>这就允许有只包含 CSS 的代码块。</p><h2 id="重大变更：未来计划"><a href="#重大变更：未来计划" class="headerlink" title="重大变更：未来计划"></a>重大变更：未来计划</h2><h3 id="实验特性"><a href="#实验特性" class="headerlink" title="实验特性"></a>实验特性</h3><p>并不是所有的功能都是一开始就稳定的。在 webpack 4 中，我们添加了实验性功能，并在变更日志中注明它们是实验性的，但从配置中并不总是能清楚地看到这些功能是实验性的。</p><p>在 webpack 5 中，有一个新的 <code>experiments</code> 配置选项，允许启用实验性功能。这使得哪些功能被启用/使用变得很清楚。</p><p>虽然 webpack 遵循语义版本化，但它会对实验性功能进行例外处理。实验性功能可能会在 webpack 的次要版本中包含破坏性的变化。当这种情况发生时，我们会在变更日志中添加一个明确的注释。这将使我们能够更快地迭代实验性功能，同时也使我们能够在主要版本上为稳定的功能停留更长时间。</p><p>以下的实验功能将随 webpack 5 一起发布。</p><ul><li>旧的 WebAssembly 支持，就像 webpack 4 一样 (<code>experiments.syncWebAssembly</code>)</li><li>根据<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1dlYkFzc2VtYmx5L2VzbS1pbnRlZ3JhdGlvbg==">更新的规范<i class="fa fa-external-link-alt"></i></span>(<code>experiments.asyncWebAssembly</code>)，新增 WebAssembly 支持。<ul><li>这使得一个 WebAssembly 模块成为一个异步模块。</li></ul></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtdG9wLWxldmVsLWF3YWl0">顶层的 Await<i class="fa fa-external-link-alt"></i></span>第三阶段提案(<code>experiments.topLevelAwait</code>)<ul><li>在顶层使用 <code>await</code> 使该模块成为一个异步模块。</li></ul></li><li>以模块的形式生成代码包 (<code>experiments.outputModule</code>)<ul><li>这就从代码包中移除了包装器 IIFE，执行严格模式，通过 <code>&lt;script type=&quot;module&quot;&gt;</code> 进行懒惰加载，并在模块模式下最小化压缩。</li></ul></li></ul><p>请注意，这也意味着 WebAssembly 的支持现在被默认禁用。</p><h3 id="最小-Node-js-版本"><a href="#最小-Node-js-版本" class="headerlink" title="最小 Node.js 版本"></a>最小 Node.js 版本</h3><p>最低支持的 Node.js 版本从 6 增加到 10.13.0(LTS)。</p><p>迁移：升级到最新的 Node.js 版本。</p><h2 id="配置变更"><a href="#配置变更" class="headerlink" title="配置变更"></a>配置变更</h2><h3 id="结构的变化"><a href="#结构的变化" class="headerlink" title="结构的变化"></a>结构的变化</h3><ul><li><code>entry: &#123;&#125;</code> 现在可以赋值一个空对象（允许使用插件来修改入口）。</li><li><code>target</code> 支持数组，版本及 browserslist</li><li>移除了 <code>cache: Object</code>：不能再设置内存缓存对象</li><li>添加了 <code>cache.type</code>：现在可以在 <code>&quot;memory&quot;</code> 和 <code>&quot;filesystem&quot;</code> 间进行选择</li><li>在 <code>cache.type = &quot;filesystem&quot;</code> 时，增加了新配置项：<ul><li><code>cache.cacheDirectory</code></li><li><code>cache.name</code></li><li><code>cache.version</code></li><li><code>cache.store</code></li><li><code>cache.hashAlgorithm</code></li><li><code>cache.idleTimeout</code></li><li><code>cache.idleTimeoutForIntialStore</code></li><li><code>cache.buildDependencies</code></li></ul></li><li>添加了 <code>snapshot.resolveBuildDependencies</code></li><li>添加了 <code>snapshot.resolve</code></li><li>添加了 <code>snapshot.module</code></li><li>添加了 <code>snapshot.managedPaths</code></li><li>添加了 <code>snapshot.immutablePaths</code></li><li>添加了 <code>resolve.cache</code>：此选项可禁用/启用 safe 解析缓存</li><li>移除了 <code>resolve.concord</code></li><li><code>resolve.alias</code> 值可以为数组或 <code>false</code></li><li>添加了 <code>resolve.restrictions</code>：允许限制可能存在的结果</li><li>添加了 <code>resolve.fallback</code>：允许为处理不了的别名请求设置降级</li><li>添加了 <code>resolve.preferRelative</code>：允许处理模块请求</li><li>移除了针对于 Node.js 原生模块的自动 polyfills<ul><li>移除了 <code>node.Buffer</code></li><li>移除了 <code>node.console</code></li><li>移除了 <code>node.process</code></li><li>移除了 <code>node.*</code>（Node.js 原生模块）</li><li>迁移：<code>resolve.alias</code> 和 <code>ProvidePlugin</code>。错误会给出提示。（可以参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svbm9kZS1saWJzLWJyb3dzZXI=">node-libs-browser<i class="fa fa-external-link-alt"></i></span>，了解 v4 中 polyfill 和 mock 的方式）</li></ul></li><li><code>output.filename</code> 可以设置为函数</li><li>添加了 <code>output.assetModuleFilename</code></li><li><code>output.jsonpScriptType</code> 更名为 <code>output.scriptType</code></li><li><code>devtool</code> 更加严格<ul><li>格式化：<code>false | eval | [inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map</code></li></ul></li><li>添加了 <code>optimization.chunkIds: &quot;deterministic&quot;</code></li><li>添加了 <code>optimization.moduleIds: &quot;deterministic&quot;</code></li><li><code>optimization.moduleIds: &quot;hashed&quot;</code> 已弃用</li><li>移除了 <code>optimization.moduleIds: &quot;total-size&quot;</code></li><li>废弃了模块的 flag 并移除了 chunk id<ul><li>移除了 <code>optimization.hashedModuleIds</code></li><li>移除了 <code>optimization.namedChunks</code> (<code>NamedChunksPlugin</code> too)</li><li>移除了 <code>optimization.namedModules</code> (<code>NamedModulesPlugin</code> too)</li><li>移除了 <code>optimization.occurrenceOrder</code></li><li>迁移：使用 <code>chunkIds</code> 和 <code>moduleIds</code></li></ul></li><li><code>optimization.splitChunks</code> <code>test</code> 不再匹配 chunk 名<ul><li>迁移：使用 test 函数<br><code>(module, &#123; chunkGraph &#125;) =&gt; chunkGraph.getModuleChunks(module).some(chunk =&gt; chunk.name === &quot;name&quot;)</code></li></ul></li><li>添加了 <code>optimization.splitChunks</code> <code>minRemainingSize</code></li><li><code>optimization.splitChunks</code> 的 <code>filename</code> 可以设置为函数</li><li><code>optimization.splitChunks</code> 的大小现在可以设置为每个源类型大小的对象<ul><li><code>minSize</code></li><li><code>minRemainingSize</code></li><li><code>maxSize</code></li><li><code>maxAsyncSize</code></li><li><code>maxInitialSize</code></li></ul></li><li><code>optimization.splitChunks</code> 中的 <code>maxAsyncSize</code> 和 <code>maxInitialSize</code> 添加了 <code>maxSize</code>：允许为初始和异步 chunk 指定不同的 maxSize</li><li>移除了 <code>optimization.splitChunks</code> 的 <code>name: true</code>：不再支持自动命名<ul><li>迁移：使用默认值。<code>chunkIds: &quot;named&quot;</code> 会为你的文件取一个有用的名字，以便于调试</li></ul></li><li>添加了 <code>optimization.splitChunks.cacheGroups[].idHint</code>：会给出提示，如果选择命名的 chunk id</li><li>移除了 <code>optimization.splitChunks</code> 的 <code>automaticNamePrefix</code><ul><li>迁移：使用 <code>idHint</code> 代替</li></ul></li><li><code>optimization.splitChunks</code> 的 <code>filename</code> 不再局限于初始 chunk</li><li>添加了 <code>optimization.splitChunks</code> 的 <code>usedExports</code>，以便在比较模块时引入使用过的 export</li><li>添加了 <code>optimization.splitChunks.defaultSizeTypes</code>：当使用数字表示 size 时，可以指定 size 的类型</li><li>添加了 <code>optimization.mangleExports</code></li><li><code>optimization.minimizer</code> <code>&quot;...&quot;</code> 可以用于引入默认值</li><li><code>optimization.usedExports</code> <code>&quot;global&quot;</code> 增加了一个值，以允许在每个运行时中禁用分析，而在全局范围内进行分享（性能更好）</li><li><code>optimization.noEmitOnErrors</code> 更名为 <code>optimization.emitOnErrors</code>，逻辑颠倒</li><li>添加了 <code>optimization.realContentHash</code></li><li>移除了 <code>output.devtoolLineToLine</code><ul><li>迁移：没有替代项</li></ul></li><li>现已允许 <code>output.chunkFilename: Function</code></li><li><code>output.hotUpdateChunkFilename: Function</code> 已被禁止：反正也没什么用。</li><li><code>output.hotUpdateMainFilename: Function</code> 已被禁止：反正也没什么用。</li><li><code>output.importFunctionName: string</code> 指定用于替换 <code>import()</code> 的名称，以允许在不支持的环境中进行 polyfilling</li><li>添加了 <code>output.charset</code>：将其设置为 false，会省略 script 标签上的 <code>charset</code> 属性</li><li><code>output.hotUpdateFunction</code> 更名为 <code>output.hotUpdateGlobal</code></li><li><code>output.jsonpFunction</code> 更名为 <code>output.chunkLoadingGlobal</code></li><li><code>output.chunkCallbackFunction</code> 更名为 <code>output.chunkLoadingGlobal</code></li><li>添加了 <code>output.chunkLoading</code></li><li>添加了 <code>output.enabledChunkLoadingTypes</code></li><li>添加了 <code>output.chunkFormat</code></li><li><code>module.rules</code> 中的 <code>resolve</code> 和 <code>parser</code> 将以不同的方式进行合并（对象会进行深度合并，数组可能会使用 <code>&quot;...&quot;</code> 的形式来引用之前的值）</li><li>添加了 <code>module.rules</code> <code>parser.worker</code>：允许为支持的 worker 添加配置</li><li><code>module.rules</code> 中的 <code>query</code> 和 <code>loaders</code> 被移除</li><li>向 <code>module.rules</code> 中的 <code>options</code> 传递字符串的形式被废弃<ul><li>迁移：使用传递选项对象的方式代替，当不支持这种方式时，请在对应的 loader 中开启一个 issues</li></ul></li><li>添加了 <code>module.rules</code> <code>mimetype</code>：允许匹配 DataURI 的 mimetype</li><li>添加了 <code>module.rules</code> <code>descriptionData</code>：允许匹配来自 package.json 中的数据</li><li><code>module.defaultRules</code> <code>&quot;...&quot;</code> 可以用于引用默认值</li><li>添加了 <code>stats.chunkRootModules</code>：用于显示根模块的 chunk</li><li>添加了 <code>stats.orphanModules</code>：用于显示为 emit 的模块</li><li>添加了 <code>stats.runtime</code>：用于显示 runtime 模块</li><li>添加了 <code>stats.chunkRelations</code>：用于显示 parent/children/sibling 的 chunk</li><li>添加了 <code>stats.errorStack</code>：用于显示追踪 webpack 内部的堆栈错误</li><li>添加了 <code>stats.preset</code>：选择 preset</li><li>添加了 <code>stats.relatedAssets</code>：用于显示与其他 asset 相关的 asset（如，SourceMaps）</li><li><code>stats.warningsFilter</code> 已被弃用，请改用 <code>ignoreWarnings</code></li><li><code>BannerPlugin.banner</code> 签名已变更<ul><li>移除了 <code>data.basename</code></li><li>移除了 <code>data.query</code></li><li>迁移：从 <code>filename</code> 中获取</li></ul></li><li>移除了 <code>SourceMapDevToolPlugin</code> 的 <code>lineToLine</code><ul><li>迁移：无可替代项</li></ul></li><li><code>[hash]</code> 作为完整的编译 hash 值，现已被弃用<ul><li>迁移：使用 <code>[fullhash]</code> 代替，或最好选用其他 hash 选项</li></ul></li><li><code>[modulehash]</code> 已被弃用<ul><li>迁移：使用 <code>[hash]</code> 代替</li></ul></li><li><code>[moduleid]</code> 已被弃用<ul><li>迁移：使用 <code>[id]</code> 代替</li></ul></li><li>移除了 <code>[filebase]</code><ul><li>迁移：使用 <code>[base]</code> 代替</li></ul></li><li>基于文件模板的新 placeholders（例如 SourceMapDevToolPlugin）<ul><li><code>[name]</code></li><li><code>[base]</code></li><li><code>[path]</code></li><li><code>[ext]</code></li></ul></li><li>当给 <code>externals</code> 传递一个函数时，现在有一个不同的签名 <code>(&#123; context, request &#125;, callback)</code><ul><li>迁移：改变函数签名</li></ul></li><li>添加了 <code>externalsPresets</code></li><li>添加了 <code>experiments</code>（见上述实验部分）</li><li>添加了 <code>watchOptions.followSymlinks</code></li><li><code>watchOptions.ignored</code> 可以使用正则匹配</li><li>暴露了 <code>webpack.util.serialization</code></li></ul><h3 id="默认值变更"><a href="#默认值变更" class="headerlink" title="默认值变更"></a>默认值变更</h3><ul><li>当 browserslist 配置可用时，<code>target</code> 默认为 <code>&quot;browserslist&quot;</code></li><li><code>module.unsafeCache</code> 现默认只对 <code>node_modules</code> 启用</li><li><code>optimization.moduleIds</code> 在生产环境下默认为 <code>deterministic</code>，而不再是 <code>size</code></li><li><code>optimization.chunkIds</code> 在生产环境下默认为 <code>deterministic</code>，而不再是 <code>total-size</code></li><li><code>optimization.nodeEnv</code> 在 <code>none</code> 模式下，默认为 <code>false</code></li><li><code>optimization.splitChunks.minSize</code> 在生产环境下默认为 <code>20k</code></li><li><code>optimization.splitChunks.enforceSizeThreshold</code> 在生产环境下默认为 <code>50k</code></li><li><code>optimization.splitChunks</code> 中的 <code>minRemainingSize</code> 在生产环境下默认为 <code>minSize</code><ul><li>这将导致在剩余部分过小的情况下，创建更少的 chunk</li></ul></li><li><code>optimization.splitChunks</code> 中的 <code>maxAsyncRequests</code> 和 <code>maxInitialRequests</code> 默认值增加到了 30</li><li><code>optimization.splitChunks.cacheGroups.vendors</code> 更名为 <code>optimization.splitChunks.cacheGroups.defaultVendors</code></li><li><code>optimization.splitChunks.cacheGroups.defaultVendors.reuseExistingChunk</code> 默认为 <code>true</code></li><li><code>optimization.minimizer</code> 的 target 默认在 terser 选项中使用 <code>compress.passes: 2</code></li><li>当使用 <code>cache</code> 时， <code>resolve(Loader).cache</code> 默认为 <code>true</code></li><li><code>resolve(Loader).cacheWithContext</code> 默认为 <code>false</code></li><li><code>resolveLoader.extensions</code> 移除了 <code>.json</code></li><li><code>node.global</code> 中的 <code>node.__filename</code> 和 <code>node.__dirname</code> 默认为 <code>false</code></li><li><code>stats.errorStack</code> 默认为 <code>false</code></li></ul><h2 id="加载器相关变更"><a href="#加载器相关变更" class="headerlink" title="加载器相关变更"></a>加载器相关变更</h2><h3 id="this-getOptions"><a href="#this-getOptions" class="headerlink" title="this.getOptions"></a><code>this.getOptions</code></h3><p>这个新的 API 应该可以简化加载器中选项的使用。<br>它允许传递 JSON 模式进行验证。<br>详情请见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9wdWxsLzEwMDE3">PR<i class="fa fa-external-link-alt"></i></span></p><h3 id="this-exec"><a href="#this-exec" class="headerlink" title="this.exec"></a><code>this.exec</code></h3><p>这一点已从加载器上下文中删除</p><p>迁移：这可以在加载器本身实现。</p><h3 id="this-getResolve"><a href="#this-getResolve" class="headerlink" title="this.getResolve"></a><code>this.getResolve</code></h3><p>loader API 中的 <code>getResolve(options)</code> 将以另一种方式合并选项，参见<code>module.rule``resolve</code>。</p><p>由于 webpack 5 在不同的发布依赖关系之间存在差异，所以传递一个 <code>dependencyType</code> 作为选项可能是有意义的（例如<code>&quot;esm&quot;</code>，<code>&quot;commonjs&quot;</code>，或者其他）。</p><h2 id="重大内部变更"><a href="#重大内部变更" class="headerlink" title="重大内部变更"></a>重大内部变更</h2><p>?&gt; 这一部分可能需要更多的完善。</p><p>以下改动只与插件作者有关：</p><h3 id="新的插件运行顺序"><a href="#新的插件运行顺序" class="headerlink" title="新的插件运行顺序"></a>新的插件运行顺序</h3><p>现在 webpack 5 中的插件在应用配置默认值 <strong>之前</strong> 就会被应用。<br>这使得插件可以应用自己的默认值，或者作为配置预设。</p><p>但这也是一个突破性的变化，因为插件在应用时不能依赖配置值的设置。</p><p>迁移：只在插件钩子中访问配置。或者最好完全避免访问配置，并通过构造函数获取选项。</p><h3 id="运行时模块"><a href="#运行时模块" class="headerlink" title="运行时模块"></a>运行时模块</h3><p>大部分的运行时代码被移到了所谓的”运行时模块”中。这些特殊模块负责添加运行时代码。它们可以被添加到任何块中，但目前总是被添加到运行时块中。”运行时需求”控制哪些运行时模块（或核心运行时部件）被添加到代码包中。这确保了只有使用的运行时代码才会被添加到代码包中。未来，运行时模块也可以添加到按需加载的块中，以便在需要时加载运行时代码。</p><p>在大多数情况下，核心运行代码时允许内联入口模块，而不是用 <code>__webpack_require__</code> 来调用它。如果代码包中没有其他模块，则根本不需要使用 <code>__webpack_require__</code>。这与模块合并很好地结合在一起，即多个模块被合并成一个模块。</p><p>在最好的情况下，根本不需要运行时代码。</p><p>迁移：如果你在插件中注入运行时代码到 webpack 运行时，可以考虑使用 RuntimeModules 来代替。instead.</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>我们添加了一个序列化机制，以允许在 webpack 中对复杂对象进行序列化。它有一个可选的语义，所以那些应该被序列化的类需要被明确地标记出来（并且实现它们的序列化）。大多数模块、所有的依赖关系和一些错误都已经这样做了。</p><p>迁移：当使用自定义模块或依赖关系时，建议将它们实现成可序列化的，以便从持久化缓存中获益。</p><h3 id="用于缓存的插件"><a href="#用于缓存的插件" class="headerlink" title="用于缓存的插件"></a>用于缓存的插件</h3><p>增加了一个带有插件接口的 <code>Cache</code> 类。该类可用于写入和读取缓存。根据配置的不同，不同的插件可以为缓存添加功能。<code>MemoryCachePlugin</code> 增加了内存缓存功能。<code>FileCachePlugin</code> 增加了持久性（文件系统）缓存。</p><p><code>FileCachePlugin</code> 使用序列化机制将缓存项目持久化到磁盘上或从磁盘上恢复。</p><h3 id="冻结钩子对象"><a href="#冻结钩子对象" class="headerlink" title="冻结钩子对象"></a>冻结钩子对象</h3><p>有 <code>hooks</code> 的类会冻结其 <code>hooks</code> 对象，所以通过这种方式添加自定义钩子已经不可能了。</p><p>迁移：推荐的添加自定义钩子的方式是使用 WeakMap 和一个静态的 <code>getXXXHooks(XXX)</code>(即<code>getCompilationHook(compilation)</code>)方法。内部类使用与自定义钩子相同的机制。</p><h3 id="Tapable-插件升级"><a href="#Tapable-插件升级" class="headerlink" title="Tapable 插件升级"></a>Tapable 插件升级</h3><p>webpack 3 插件的 compat 层已经被移除。它在 webpack 4 中已经被取消了。</p><p>一些较少使用的 tapable API 被删除或废弃。</p><p>迁移：使用新的 tapable API。</p><h3 id="Stage-钩子"><a href="#Stage-钩子" class="headerlink" title="Stage 钩子"></a>Stage 钩子</h3><p>在封装代码包过程的几个步骤中，不同阶段有多个钩子，即 <code>optimizeDependenciesBasic</code>, <code>optimizeDependencies</code> 和 <code>optimizeDependenciesAdvanced</code>。这些已经被删除，改为一个单一的钩子，它可以与 <code>stage</code> 选项一起使用。参见 <code>OptimizationStages</code>了解可能的 <code>stage</code> 选项值。</p><p>MIGRATION: 侵入剩余的钩子。你可以添加一个 <code>stage</code> 选项。</p><h3 id="Main-Chunk-ModuleTemplate-废弃"><a href="#Main-Chunk-ModuleTemplate-废弃" class="headerlink" title="Main/Chunk/ModuleTemplate 废弃"></a>Main/Chunk/ModuleTemplate 废弃</h3><p>打包模板已经重构。MainTemplate/ChunkTemplate/ModuleTemplate 被废弃，现在 JavascriptModulesPlugin 负责 JS 模板。</p><p>在那次重构之前，JS 输出由 Main/ChunkTemplate 处理，而另一个输出（即 WASM、CSS）则由插件处理。这样看起来 JS 是一等公民，而其它输出是二等。重构改变了这一点，所有的输出都由他们的插件处理。</p><p>依然可以侵入部分模板。钩子现在在 JavascriptModulesPlugin 中，而不是 Main/ChunkTemplate 中。(是的，插件也可以有钩子，我称之为附加钩子。)</p><p>有一个兼容层，所以 Main/Chunk/ModuleTemplate 仍然存在，但只是将 tap 调用委托给新的钩子位置。</p><p>迁移：按照 deprecation 消息中的建议。主要是指向不同位置的钩子。</p><h3 id="入口文件描述符"><a href="#入口文件描述符" class="headerlink" title="入口文件描述符"></a>入口文件描述符</h3><p>如果传递一个对象作为入口文件，其值可能是一个字符串、字符串数组或描述符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    catalog: &#123;</span><br><span class="line">      <span class="keyword">import</span>: <span class="string">&#x27;./catalog.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>描述符语法可用于向入口文件传递附加选项。</p><h4 id="入口文件输出文件名"><a href="#入口文件输出文件名" class="headerlink" title="入口文件输出文件名"></a>入口文件输出文件名</h4><p>默认情况下，入口文件代码块的输出文件名是从<code>output.filename</code>中提取的，<br>但你可以为特定入口文件指定一个自定义的输出文件名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    about: &#123; <span class="attr">import</span>: <span class="string">&#x27;./about.js&#x27;</span>, <span class="attr">filename</span>: <span class="string">&#x27;pages/[name][ext]&#x27;</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="入口文件依赖"><a href="#入口文件依赖" class="headerlink" title="入口文件依赖"></a>入口文件依赖</h4><p>默认情况下，每个入口文件代码块都存储了它所使用的所有模块。使用 <code>dependOn</code>-选项，<br>你可以将模块从一个入口文件代码块共享到另一个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &#123; <span class="attr">import</span>: <span class="string">&#x27;./app.js&#x27;</span>, <span class="attr">dependOn</span>: <span class="string">&#x27;react-vendors&#x27;</span> &#125;,</span><br><span class="line">    <span class="string">&#x27;react-vendors&#x27;</span>: [<span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;react-dom&#x27;</span>, <span class="string">&#x27;prop-types&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>app 代码块 将不包含 <code>react-vendors</code> 所拥有的模块。</p><h4 id="入口文件类库"><a href="#入口文件类库" class="headerlink" title="入口文件类库"></a>入口文件类库</h4><p>入口文件描述符允许为每个入口文件传递不同的 <code>library</code> 选项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    commonjs: &#123;</span><br><span class="line">      <span class="keyword">import</span>: <span class="string">&#x27;./lib.js&#x27;</span>,</span><br><span class="line">      library: &#123;</span><br><span class="line">        type: <span class="string">&#x27;commonjs-module&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    amd: &#123;</span><br><span class="line">      <span class="keyword">import</span>: <span class="string">&#x27;./lib.js&#x27;</span>,</span><br><span class="line">      library: &#123;</span><br><span class="line">        type: <span class="string">&#x27;amd&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="入口文件运行时"><a href="#入口文件运行时" class="headerlink" title="入口文件运行时"></a>入口文件运行时</h4><p>入口文件描述符允许为每个入口文件指定一个 <code>运行时代码</code>。<br>当指定时，将创建一个以该名称命名的代码块，其中仅包含该条目的运行时代码。<br>当多个条目指定相同的<code>运行时代码</code>时，该块将包含所有这些入口文件的共同运行时代码。<br>这意味着它们可以在同一个 HTML 页面中一起使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &#123;</span><br><span class="line">      <span class="keyword">import</span>: <span class="string">&#x27;./app.js&#x27;</span>,</span><br><span class="line">      runtime: <span class="string">&#x27;app-runtime&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="入口文件代码块加载"><a href="#入口文件代码块加载" class="headerlink" title="入口文件代码块加载"></a>入口文件代码块加载</h4><p>入口文件描述符允许为每个入口文件指定一个 <code>chunkLoading</code>。<br>这个入口文件的运行时代码将使用这个来加载代码块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &#123;</span><br><span class="line">      <span class="keyword">import</span>: <span class="string">&#x27;./app.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    worker: &#123;</span><br><span class="line">      <span class="keyword">import</span>: <span class="string">&#x27;./worker.js&#x27;</span>,</span><br><span class="line">      chunkLoading: <span class="string">&#x27;importScripts&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="排序与-ID"><a href="#排序与-ID" class="headerlink" title="排序与 ID"></a>排序与 ID</h3><p>webpack 曾经在编译阶段以特定的方式对模块和代码块进行排序，以递增的方式分配 ID。现在不再是这样了。顺序将不再用于 ID 的生成，取而代之的是，ID 生成的完全控制在插件中。</p><p>优化模块和代码块顺序的钩子已经被移除。</p><p>迁移：在编译阶段，你不能再依赖模块和代码块的顺序了。</p><h3 id="从数组到集合-Set"><a href="#从数组到集合-Set" class="headerlink" title="从数组到集合(Set)"></a>从数组到集合(Set)</h3><ul><li>Compilation.modules 现在是一个集合</li><li>Compilation.chunks 现在是一个集合</li><li>Chunk.files 现在是一个集合</li></ul><p>存在一个适配层但会打印废弃的警告。</p><p>迁移: 使用集合方法代替数组方法。</p><h3 id="Compilation-fileSystemInfo"><a href="#Compilation-fileSystemInfo" class="headerlink" title="Compilation.fileSystemInfo"></a>Compilation.fileSystemInfo</h3><p>这个新 class 可以用来以缓存的方式访问文件系统的信息。目前，它允许访问文件和目录的时间戳。如果可能的话，关于时间戳的信息会从监听那里传输过了，否则将由文件系统访问决定。</p><p>后续，会增加访问文件内容 hash 值的功能，模块可以用文件内容代替文件 hash 来检查有效性。</p><p>迁移：使用 <code>compilation.fileSystemInfo</code> API，替代 <code>file/contextTimestamps</code>。</p><p>现在可以对目录进行时间戳管理，允许对 ContextModules 进行序列化。</p><p>增加了 <code>Compiler.modifiedFiles</code>（类似于 <code>Compiler.removedFiles</code>），以便更容易引用更改后的文件。</p><h3 id="Filesystems"><a href="#Filesystems" class="headerlink" title="Filesystems"></a>Filesystems</h3><p>新增了一个类似于 <code>compiler.inputFileSystem</code> 和 <code>compiler.outputFileSystem</code> 的新 API <code>compiler.intermediateFileSystem</code>，用于所有不被认为是输入或输出的 fs 操作，如写入 records，缓存或输出 profiling。</p><p>文件系统现在有 <code>fs</code> 接口，不再需要 <code>join</code> 或 <code>mkdirp</code> 等额外方式。但如果它们包含 <code>join</code> 或 <code>dirname</code> 等类似方法，也会被使用。</p><h3 id="模块热替换"><a href="#模块热替换" class="headerlink" title="模块热替换"></a>模块热替换</h3><p>HMR 运行时已被重构为运行时模块。<code>HotUpdateChunkTemplate</code> 已被合并入 <code>ChunkTemplate</code> 中。ChunkTemplates 和 plugins 也应处理 <code>HotUpdateChunk</code> 了。</p><p>HMR 运行时的 javascript 部分已从核心 HMR 运行时钟分离了出来。其他模块类型现在也可以使用它们自己的方式处理 HMR。在未来，这将使得 HMR 处理诸如 mini-css-extract-plugin 或 WASM 模块。</p><p>迁移：此为新功能，无需迁移。</p><p><code>import.meta.webpackHot</code> 公开了与 <code>module.hot</code> 相同的 API。当然可以在 ESM 模块（.mjs，package.json 中的 type: “module”）中使用，这些模块不能访问 <code>module</code>。</p><h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h3><p>webpack 曾经通过函数调用函数的形式来进行模块处理，还有一个 <code>semaphore</code> 选项限制并行性。<code>Compilation.semaphore</code> 已被移除，现在可以使用异步队列处理，每个步骤都有独立的队列：</p><ul><li><code>Compilation.factorizeQueue</code>：为一组 dependencies 调用模块工厂。</li><li><code>Compilation.addModuleQueue</code>：将模块添加到编译队列中（可以使用缓存恢复模块）</li><li><code>Compilation.buildQueue</code>：必要时构建模块（可将模块存储到缓存中）</li><li><code>Compilation.rebuildQueue</code>：如需手动触发，则会重新构建模块</li><li><code>Compilation.processDependenciesQueue</code>：处理模块的 dependencies。</li></ul><p>这些队列会有一些 hook 来监听并拦截工作的进程。</p><p>未来，多个编译器会同时工作，可以通过拦截这些队列来进行编译工作的编排。</p><p>迁移：此为新功能，无需迁移。</p><h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><p>webpack 内部引入了一些日志记录的方法。<br><code>stats.logging</code> 和 <code>infrastructureLogging</code> 选项可用于启用这些信息。</p><h3 id="模块和-chunk-图"><a href="#模块和-chunk-图" class="headerlink" title="模块和 chunk 图"></a>模块和 chunk 图</h3><p>webpack 曾经在依赖关系中存储了已解析的模块，并在 chunk 中存储引入的模块。但现已发生变化。所有关于模块在模块图中如何连接的信息，现在都存储在 ModulGraph 的 class 中。所有关于模块与 chunk 如何连接的信息现在都已存储在 ChunkGraph 的 class 中。依赖于 chunk 图的信息也存储在相关的 class 中。</p><p>这意味着以下关于模块的信息已被移动：</p><ul><li>Module connections -&gt; ModuleGraph</li><li>Module issuer -&gt; ModuleGraph</li><li>Module optimization bailout -&gt; ModuleGraph (TODO: check if it should ChunkGraph instead)</li><li>Module usedExports -&gt; ModuleGraph</li><li>Module providedExports -&gt; ModuleGraph</li><li>Module pre order index -&gt; ModuleGraph</li><li>Module post order index -&gt; ModuleGraph</li><li>Module depth -&gt; ModuleGraph</li><li>Module profile -&gt; ModuleGraph</li><li>Module id -&gt; ChunkGraph</li><li>Module hash -&gt; ChunkGraph</li><li>Module runtime requirements -&gt; ChunkGraph</li><li>Module is in chunk -&gt; ChunkGraph</li><li>Module is entry in chunk -&gt; ChunkGraph</li><li>Module is runtime module in chunk -&gt; ChunkGraph</li><li>Chunk runtime requirements -&gt; ChunkGraph</li></ul><p>当从缓存中恢复模块时，webpack 会将模块从图中断开。现在已无需这么做。一个模块不存储图形的任何信息，技术上可以在多个图形中使用。这会使得缓存变得更加容易。</p><p>这部分变化中大多数都有一个 compat-layer，当使用时，它会打印一个弃用警告。</p><p>迁移：在 ModuleGraph 和 ChunkGraph 上使用新的 API。</p><h3 id="Init-Fragments"><a href="#Init-Fragments" class="headerlink" title="Init Fragments"></a>Init Fragments</h3><p><code>DependenciesBlockVariables</code> 已被移除，改为 <code>InitFragments</code>。<code>DependencyTemplates</code> 现在可以添加 <code>InitFragments</code>，以将代码注入模块源的起始位置。<code>InitFragments</code> 允许删除重复数据。</p><p>迁移：使用 <code>InitFragments</code> 代替，而无需在源文件的负索引出插入。</p><h3 id="模块-Source-Types"><a href="#模块-Source-Types" class="headerlink" title="模块 Source Types"></a>模块 Source Types</h3><p>Modules 现在必须通过 <code>Module.getSourceTypes()</code> 来定义它们支持的源码类型。根据这一点，不同的插件会用这些类型调用 <code>source()</code>。对于源类型为 <code>javascript</code> 的 <code>JavascriptModulesPlugin</code> 会将源代码嵌入到 bundle 中。源类型 <code>webassembly</code> 的 <code>WebAssemblyModulesPlugin</code> 会 emit 一个 wasm 文件。同时，也支持自定义源类型，例如，mini-css-extract-plugin 会使用源类型为 <code>stylesheet</code> 将源码嵌入到 css 文件中。</p><p>模块类型与源类型间没有关系。即使模块类型为 <code>json</code>，也可以使用源类型为 <code>javascript</code> 和模块类型为 <code>webassembly/experimental</code> 的 <code>javascript</code> 和 <code>webassembly</code>。</p><p>迁移：自定义模块需要实现这些新的接口方法。</p><h3 id="Stats-的插件"><a href="#Stats-的插件" class="headerlink" title="Stats 的插件"></a>Stats 的插件</h3><p>Stats 的 <code>preset</code>，<code>default</code>，<code>json</code> 和 <code>toString</code> 现已由插件系统内置。将当前的 Stats 转换为插件。</p><p>迁移：你现在可以自定义它，而无需替换整个 Stats 功能。额外的信息现在可以添加到 stats json 中，而不是单独编写文件。</p><h3 id="全新的监听"><a href="#全新的监听" class="headerlink" title="全新的监听"></a>全新的监听</h3><p>webpack 所使用的监听已重构。它之前使用的是 <code>chokidar</code> 和原生依赖 <code>fsevents</code>（仅在 OSX 上）。现在它在只基于原生的 Node.js 中的 <code>fs</code>。这意味着在 webpack 中已经没有原生依赖了。</p><p>它还能在监听时捕捉更多关于文件系统的信息。目前，它还可以捕获 mtimes 和监视事件时间，以及丢失文件的信息。为此，<code>WatchFileSystem</code> API 做了一点小改动。在修改的同时，我们还将 Arrays 转换为 Sets，Objects 转换为 Maps。</p><h3 id="SizeOnlySource-after-emit"><a href="#SizeOnlySource-after-emit" class="headerlink" title="SizeOnlySource after emit"></a>SizeOnlySource after emit</h3><p>webpack 现在使用 <code>SizeOnlySource</code> 替换 <code>Compilation.assets</code> 中的 Sources，以减少内存占用。</p><h3 id="Emitting-assets-multiple-times"><a href="#Emitting-assets-multiple-times" class="headerlink" title="Emitting assets multiple times"></a>Emitting assets multiple times</h3><p>原来的 <code>Multiple assets emit different content to the same filename</code> 警告，现在成为错误。</p><h3 id="ExportsInfo"><a href="#ExportsInfo" class="headerlink" title="ExportsInfo"></a>ExportsInfo</h3><p>重构了模块导出信息的存储方式。ModuleGraph 现在为每个 <code>Module</code> 提供了一个 <code>ExportsInfo</code>，它用于存储每个 export 的信息。如果模块仅以副作用的方式使用，它还存储了关于未知 export 的信息，</p><p>对于每个 export，都会存储以下信息：</p><ul><li>是否使用 export? 是否使用并不确定。（详见 <code>optimization.usedExports</code>）</li><li>是否提供 export? 是否提供并不确定。（详见 <code>optimization.providedExports</code>）</li><li>能否重命名 export 名? 是否重命名，也不确定</li><li>如果 export 已重新命名，则为新名称。（详见 <code>optimization.mangleExports</code>）</li><li>嵌套的 ExportsInfo，如果 export 是一个含有附加信息的对象，那么它本身就是一个对象<ul><li>用于重新导出命名空间对象：<code>import * as X from &quot;...&quot;; export &#123; X &#125;;</code></li><li>用于表示 JSON 模块中的结构</li></ul></li></ul><h3 id="代码生成阶段"><a href="#代码生成阶段" class="headerlink" title="代码生成阶段"></a>代码生成阶段</h3><p>编译的代码生成功能作为单独的编译阶段。它不再隐藏在 <code>Module.source()</code> 和 <code>Module.getRuntimeRequirements()</code> 中运行了。</p><p>这应该会使得流程更加简洁。它还运行报告该阶段的进度。并使得代码生成在剖析时更加清晰可见。</p><p>迁移：<code>Module.source()</code> 和 <code>Module.getRuntimeRequirements()</code> 已弃用。使用 <code>Module.codeGeneration()</code> 代替。</p><h3 id="依赖关系参考"><a href="#依赖关系参考" class="headerlink" title="依赖关系参考"></a>依赖关系参考</h3><p>webpack 曾经有一个单一的方法和类型来表示依赖关系的引用（<code>Compilation.getDependencyReference</code> 会返回一个 <code>DependencyReference</code>）<br>该类型用于引入关于该引用的所有信息，如 被引用的模块，已经引入了哪些 export，如果是弱引用，还需要订阅一些相关信息。</p><p>把所有这些信息构建在一起，拿到参考的成本就很高，而且很频繁（每次有人需要一个信息）。</p><p>在 webpack5 中，这部分代码库被重构了，方法进行了拆分。</p><ul><li>引用的模块可以从 ModuleGraphConnection 中读取</li><li>引入的导出名，可以通过 <code>Dependency.getReferencedExports()</code> 获取</li><li><code>Dependency</code> 的 class 上会有一个 <code>weak</code> 的 flag</li><li>排序只与 <code>HarmonyImportDependencies</code> 相关，可以通过 <code>sourceOrder</code> 属性获取</li></ul><h3 id="Presentational-Dependencies"><a href="#Presentational-Dependencies" class="headerlink" title="Presentational Dependencies"></a>Presentational Dependencies</h3><p>这是 <code>NormalModules</code> 的一种新 Dependencies 类型：Presentational Dependencies</p><p>这些 dependencies 只在代码生成阶段使用，但在模块图构建过程中未使用。<br>所以它们永远不能引用模块或影响导出/导入。</p><p>这些依赖关系的处理成本较低，webpack 会尽可能地使用它们</p><h3 id="弃用-loaders"><a href="#弃用-loaders" class="headerlink" title="弃用 loaders"></a>弃用 loaders</h3><ul><li><p><a href="https://github.com/webpack-contrib/null-loader"><code>null-loader</code></a></p><p>已被弃用。使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      xyz$: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者使用绝对路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      [path.resolve(__dirname, <span class="string">&#x27;....&#x27;</span>)]: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="微小改动"><a href="#微小改动" class="headerlink" title="微小改动"></a>微小改动</h2><ul><li><code>Compiler.name</code>：当生成带有绝对路径的编译器名称时，请确保名称使用 <code>|</code> 或 <code>!</code> 分隔。<ul><li>使用空格作为分隔符的做法现已不再适用。（路径可以保护空格）</li><li>温馨提示：在 Stats 中输出时 <code>|</code> 会被替换为空格。</li></ul></li><li><code>SystemPlugin</code> 现已被默认禁用。<ul><li>迁移：应避免使用它，因为此规范已被删除。你可以使用 <code>Rule.parser.system: true</code> 来重新启用它。</li></ul></li><li><code>ModuleConcatenationPlugin</code>：<code>DependencyVariables</code> 已被移除，将不再阻止连接。<ul><li>这意味着它现在可以在 <code>module</code>，<code>global</code>，<code>process</code> 或 ProvidePlugin 的情况下进行连接。</li></ul></li><li>移除了 <code>Stats.presetToOptions</code><ul><li>迁移：使用 <code>compilation.createStatsOptions</code> 代替</li></ul></li><li>移除了 <code>SingleEntryPlugin</code> 和 <code>SingleEntryDependency</code><ul><li>迁移：使用 <code>EntryPlugin</code> 和 <code>EntryDependency</code> 代替</li></ul></li><li>chunk 现在可以有多个入口</li><li>移除了 <code>ExtendedAPIPlugin</code><ul><li>迁移：不再需要此插件，在必要时，你可以使用 <code>__webpack_hash__</code> 和 <code>__webpack_chunkname__</code> 注入运行时代码。</li></ul></li><li><code>ProgressPlugin</code> 不再为 <code>reportProgress</code> 使用 tapable 上下文。<ul><li>迁移：使用 <code>ProgressPlugin.getReporter(compiler)</code> 代替</li></ul></li><li>现已对 <code>.mjs</code> 文件重新启用 <code>ProvidePlugin</code></li><li><code>Stats</code> json 中的 <code>errors</code> 和 <code>warnings</code> 不再是字符串类型，而是包含必要信息的对象，这些信息会被分割为熟悉。<ul><li>迁移：查阅具体属性信息，如 <code>message</code> 字段</li></ul></li><li>移除了 <code>Compilation.hooks.normalModuleLoader</code><ul><li>迁移：使用 <code>NormalModule.getCompilationHooks(compilation).loader</code> 代替</li></ul></li><li>将 <code>NormalModuleFactory</code> 中的 hook 从 waterfall 改为 bailing，修改并对 waterfall 函数的 hook 进行了重命名操作。</li><li>移除了 <code>compilationParams.compilationDependencies</code><ul><li>插件可以在编译中使用 <code>compilation.file/context/missingDependencies</code> 添加依赖关系</li><li>Compat 层将 <code>compilationDependencies.add</code> 委托给 <code>fileDependencies.add</code>。</li></ul></li><li><code>stats.assetsByChunkName[x]</code> 始终为一个数组</li><li>增加了 <code>__webpack_get_script_filename__</code> 函数用于获取 script 文件的文件名。</li><li>在 package.json 中 <code>&quot;sideEffects&quot;</code> 将使用 <code>glob-to-regex</code> 来代替 <code>micromatch</code> 处理。<ul><li>这可能会改变边缘案例的语义。</li></ul></li><li>从 <code>IgnorePlugin</code> 中移除了 <code>checkContext</code></li><li>全新的 <code>__webpack_exports_info__</code> API 允许导出使用自省。</li><li>SourceMapDevToolPlugin 现已适用于非 chunk 资源。</li><li>当引用的 env 变量缺失且没有降级数据时，EnvironmentPlugin 目前会展示一个错。</li><li>从 schema 中移除 <code>serve</code> 熟悉。</li></ul><h2 id="其他微小改动"><a href="#其他微小改动" class="headerlink" title="其他微小改动"></a>其他微小改动</h2><ul><li>移除 build 目录，用运行时代替 build</li><li>移除不适用的特性<ul><li>BannerPlugin 目前只支持一个参数，这个参数可以是对象，字符串或函数</li></ul></li><li>移除 <code>CachePlugin</code></li><li><code>Chunk.entryModule</code> 已弃用，使用 ChunkGraph 代替</li><li><code>Chunk.hasEntryModule</code> 已弃用</li><li><code>Chunk.addModule</code> 已弃用</li><li><code>Chunk.removeModule</code> 已弃用</li><li><code>Chunk.getNumberOfModules</code> 已弃用</li><li><code>Chunk.modulesIterable</code> 已弃用</li><li><code>Chunk.compareTo</code> 已弃用</li><li><code>Chunk.containsModule</code> 已弃用</li><li><code>Chunk.getModules</code> 已弃用</li><li><code>Chunk.remove</code> 已弃用</li><li><code>Chunk.moveModule</code> 已弃用</li><li><code>Chunk.integrate</code> 已弃用</li><li><code>Chunk.canBeIntegrated</code> 已弃用</li><li><code>Chunk.isEmpty</code> 已弃用</li><li><code>Chunk.modulesSize</code> 已弃用</li><li><code>Chunk.size</code> 已弃用</li><li><code>Chunk.integratedSize</code> 已弃用</li><li><code>Chunk.getChunkModuleMaps</code> 已弃用</li><li><code>Chunk.hasModuleInGraph</code> 已弃用</li><li><code>Chunk.updateHash</code> 签名已变更</li><li><code>Chunk.getChildIdsByOrders</code> 签名已变更（TODO: 考虑移至 <code>ChunkGraph</code>）</li><li><code>Chunk.getChildIdsByOrdersMap</code> 签名已变更（TODO: 考虑移至 <code>ChunkGraph</code>）</li><li>移除了 <code>Chunk.getChunkModuleMaps</code></li><li>移除了 <code>Chunk.setModules</code></li><li>移除了废弃的 Chunk 方法</li><li>添加了 <code>ChunkGraph</code></li><li>移除了 <code>ChunkGroup.setParents</code></li><li>移除了 <code>ChunkGroup.containsModule</code></li><li><code>ChunkGroup.remove</code> 不再断开该 Group 与 block 的连接</li><li><code>ChunkGroup.compareTo</code> 签名已变更</li><li><code>ChunkGroup.getChildrenByOrders</code> 签名已变更</li><li><code>ChunkGroup</code> 的 index 和 index 改名为 pre/post order index<ul><li>废弃了 old getter</li></ul></li><li><code>ChunkTemplate.hooks.modules</code> 签名已变更</li><li><code>ChunkTemplate.hooks.render</code> 签名已变更</li><li><code>ChunkTemplate.updateHashForChunk</code> 签名已变更</li><li>移除了 <code>Compilation.hooks.optimizeChunkOrder</code></li><li>移除了 <code>Compilation.hooks.optimizeModuleOrder</code></li><li>移除了 <code>Compilation.hooks.advancedOptimizeModuleOrder</code></li><li>移除了 <code>Compilation.hooks.optimizeDependenciesBasic</code></li><li>移除了 <code>Compilation.hooks.optimizeDependenciesAdvanced</code></li><li>移除了 <code>Compilation.hooks.optimizeModulesBasic</code></li><li>移除了 <code>Compilation.hooks.optimizeModulesAdvanced</code></li><li>移除了 <code>Compilation.hooks.optimizeChunksBasic</code></li><li>移除了 <code>Compilation.hooks.optimizeChunksAdvanced</code></li><li>移除了 <code>Compilation.hooks.optimizeChunkModulesBasic</code></li><li>移除了 <code>Compilation.hooks.optimizeChunkModulesAdvanced</code></li><li>移除了 <code>Compilation.hooks.optimizeExtractedChunksBasic</code></li><li>移除了 <code>Compilation.hooks.optimizeExtractedChunks</code></li><li>移除了 <code>Compilation.hooks.optimizeExtractedChunksAdvanced</code></li><li>移除了 <code>Compilation.hooks.afterOptimizeExtractedChunks</code></li><li>添加了 <code>Compilation.hooks.stillValidModule</code></li><li>添加了 <code>Compilation.hooks.statsPreset</code></li><li>添加了 <code>Compilation.hooks.statsNormalize</code></li><li>添加了 <code>Compilation.hooks.statsFactory</code></li><li>添加了 <code>Compilation.hooks.statsPrinter</code></li><li><code>Compilation.fileDependencies</code>，<code>Compilation.contextDependencies</code> 以及 <code>Compilation.missingDependencies</code> 现在变为了 LazySets</li><li>移除了 <code>Compilation.entries</code><ul><li>迁移：使用 <code>Compilation.entryDependencies</code> 代替</li></ul></li><li>移除了 <code>Compilation._preparedEntrypoints</code></li><li><code>dependencyTemplates</code> 现已改为 <code>DependencyTemplates</code> 的 class 类型，而不再是原始的 <code>Map</code></li><li>移除了 <code>Compilation.fileTimestamps</code> 和 <code>contextTimestamps</code><ul><li>迁移：使用 <code>Compilation.fileSystemInfo</code> 代替</li></ul></li><li>移除了 <code>Compilation.waitForBuildingFinished</code><ul><li>迁移：使用新队列</li></ul></li><li>移除了 <code>Compilation.addModuleDependencies</code></li><li>移除了 <code>Compilation.prefetch</code></li><li><code>Compilation.hooks.beforeHash</code> 会在创建模块 hash 值后被调用。<ul><li>迁移：使用 <code>Compiliation.hooks.beforeModuleHash</code> 代替</li></ul></li><li>移除了 <code>Compilation.applyModuleIds</code></li><li>移除了 <code>Compilation.applyChunkIds</code></li><li>添加了 <code>Compiler.root</code>，用于指向根编译器<ul><li>可用于缓存 WeakMaps 中的数据，而非静态作用域内的数据</li></ul></li><li>添加了 <code>Compiler.hooks.afterDone</code></li><li><code>Source.emitted</code> 不再由编译器设置<ul><li>迁移：使用 <code>Compilation.emittedAssets</code> 代替</li></ul></li><li>添加了 <code>Compiler/Compilation.compilerPath</code>：此为编译器在编译器树中唯一名称。（在根编译器范围内唯一）</li><li><code>Module.needRebuild</code> 已弃用<ul><li>迁移：使用 <code>Module.needBuild</code> 代替</li></ul></li><li><code>Dependency.getReference</code> 签名已变更</li><li><code>Dependency.getExports</code> 签名已变更</li><li><code>Dependency.getWarnings</code> 签名已变更</li><li><code>Dependency.getErrors</code> 签名已变更</li><li><code>Dependency.updateHash</code> 签名已变更</li><li>移除了 <code>Dependency.module</code></li><li>添加了 <code>DependencyTemplate</code> 的基类</li><li>移除了 <code>MultiEntryDependency</code></li><li>添加了 <code>EntryDependency</code></li><li>移除了 <code>EntryModuleNotFoundError</code></li><li>移除了 <code>SingleEntryPlugin</code></li><li>添加了 <code>EntryPlugin</code></li><li>添加了 <code>Generator.getTypes</code></li><li>添加了 <code>Generator.getSize</code></li><li><code>Generator.generate</code> 签名已变更</li><li>添加了 <code>HotModuleReplacementPlugin.getParserHooks</code></li><li><code>Parser</code> 被移至 <code>JavascriptParser</code> 中</li><li><code>ParserHelpers</code> 被移至 <code>JavascriptParserHelpers</code> 中</li><li>移除了 <code>MainTemplate.hooks.moduleObj</code></li><li>移除了 <code>MainTemplate.hooks.currentHash</code></li><li>移除了 <code>MainTemplate.hooks.addModule</code></li><li>移除了 <code>MainTemplate.hooks.requireEnsure</code></li><li>移除了 <code>MainTemplate.hooks.globalHashPaths</code></li><li>移除了 <code>MainTemplate.hooks.globalHash</code></li><li>移除了 <code>MainTemplate.hooks.hotBootstrap</code></li><li><code>MainTemplate.hooks</code> 部分签名已变更</li><li><code>Module.hash</code> 已弃用</li><li><code>Module.renderedHash</code> 已弃用</li><li>移除了 <code>Module.reasons</code></li><li><code>Module.id</code> 已弃用</li><li><code>Module.index</code> 已弃用</li><li><code>Module.index2</code> 已弃用</li><li><code>Module.depth</code> 已弃用</li><li><code>Module.issuer</code> 已弃用</li><li>移除了 <code>Module.profile</code></li><li>移除了 <code>Module.prefetched</code></li><li>移除了 <code>Module.built</code></li><li>移除了 <code>Module.used</code><ul><li>迁移：使用 <code>Module.getUsedExports</code> 代替</li></ul></li><li>Module.usedExports 已弃用<ul><li>MIGRATION: 使用 <code>Module.getUsedExports</code> 代替</li></ul></li><li><code>Module.optimizationBailout</code> 已弃用</li><li>移除了 <code>Module.exportsArgument</code></li><li><code>Module.optional</code> 已弃用</li><li>移除了 <code>Module.disconnect</code></li><li>移除了 <code>Module.unseal</code></li><li>移除了 <code>Module.setChunks</code></li><li><code>Module.addChunk</code> 已弃用</li><li><code>Module.removeChunk</code> 已弃用</li><li><code>Module.isInChunk</code> 已弃用</li><li><code>Module.isEntryModule</code> 已弃用</li><li><code>Module.getChunks</code> 已弃用</li><li><code>Module.getNumberOfChunks</code> 已弃用</li><li><code>Module.chunksIterable</code> 已弃用</li><li>移除了 <code>Module.hasEqualsChunks</code></li><li><code>Module.useSourceMap</code> 被移至 <code>NormalModule</code></li><li>移除了 <code>Module.addReason</code></li><li>移除了 <code>Module.removeReason</code></li><li>移除了 <code>Module.rewriteChunkInReasons</code></li><li>移除了 <code>Module.isUsed</code><ul><li>迁移：使用 <code>isModuleUsed</code>，<code>isExportUsed</code> 和 <code>getUsedName</code> 代替</li></ul></li><li><code>Module.updateHash</code> 签名已变更</li><li>移除了 <code>Module.sortItems</code></li><li>移除了 <code>Module.unbuild</code><ul><li>迁移：使用 <code>invalidateBuild</code> 代替</li></ul></li><li>添加了 <code>Module.getSourceTypes</code></li><li>添加了 <code>Module.getRuntimeRequirements</code></li><li><code>Module.size</code> 签名已变更</li><li><code>ModuleFilenameHelpers.createFilename</code> 签名已变更</li><li><code>ModuleProfile</code> 的 class 添加了许多数据</li><li>移除了 <code>ModuleReason</code></li><li><code>ModuleTemplate.hooks</code> 签名已变更</li><li><code>ModuleTemplate.render</code> 签名已变更</li><li>移除了 <code>Compiler.dependencies</code><ul><li>迁移：使用 <code>MultiCompiler.setDependencies</code> 代替</li></ul></li><li>移除了 <code>MultiModule</code></li><li>移除了 <code>MultiModuleFactory</code></li><li><code>NormalModuleFactory.fileDependencies</code>，<code>NormalModuleFactory.contextDependencies</code> 和 <code>NormalModuleFactory.missingDependencies</code> 现已使用 LazySets</li><li><code>RuntimeTemplate</code> 方法现已使用 <code>runtimeRequirements</code> 的参数</li><li>移除了 <code>serve</code> 属性</li><li>移除了 <code>Stats.jsonToString</code></li><li>移除了 <code>Stats.filterWarnings</code></li><li>移除了 <code>Stats.getChildOptions</code></li><li>移除了 <code>Stats</code> 的 helper 方法</li><li><code>Stats.toJson</code> 签名已变更（参数二被移除）</li><li>移除了 <code>ExternalModule.external</code></li><li>移除了 <code>HarmonyInitDependency</code></li><li><code>Dependency.getInitFragments</code> 已弃用<ul><li>迁移：使用 <code>apply</code> <code>initFragements</code> 代替</li></ul></li><li>DependencyReference 现将函数传递给模块，而非模块。</li><li>移除了 <code>HarmonyImportSpecifierDependency.redirectedId</code><ul><li>迁移：使用 <code>setId</code> 代替</li></ul></li><li>acorn 5 -&gt; 7</li><li>测试<ul><li>HotTestCases 现可为多个目标运行，包括 <code>async-node</code> <code>node</code> <code>web</code> <code>webworker</code></li><li>TestCases 现在可以用 <code>store: &quot;instant&quot;</code> 和 <code>store: &quot;pack&quot;</code> 来运行系统缓存。</li><li>TestCases 现在也可以为指定的模块 id 运行。</li></ul></li><li>工具添加了 import 的排序功能（在 CI 检查）</li><li>当 chunk 的名称与 id 等价时，运行时的 chunk 名称映射不再包含入口</li><li>将 <code>resolvedModuleId</code> <code>resolvedModuleIdentifier</code> 和 <code>resolvedModule</code> 添加到 Stats 的 reason 中，在完成作用域提升等优化之前，这些 reason 指向模块</li><li>在 Stats toString 的输出中展示 <code>resolvedModule</code></li><li>loader-runner 已升级：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svbG9hZGVyLXJ1bm5lci9yZWxlYXNlcy90YWcvdjMuMC4w">https://github.com/webpack/loader-runner/releases/tag/v3.0.0<i class="fa fa-external-link-alt"></i></span></li><li><code>Compilation</code> 中的 <code>file/context/missingDependencies</code> 因性能问题不再排序<ul><li>不要依赖排序</li></ul></li><li>webpack-sources 已升级：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1zb3VyY2VzL3JlbGVhc2VzL3RhZy92Mi4wLjAtYmV0YS4w">https://github.com/webpack/webpack-sources/releases/tag/v2.0.0-beta.0<i class="fa fa-external-link-alt"></i></span></li><li>删除了对 webpack-command 的支持</li><li>使用 schema-utils@2 进行模式校验</li><li><code>Compiler.assetEmitted</code> 改进了参数二，增加了更多信息</li><li>BannerPlugin 省略了尾部的空白字符</li><li>从 <code>LimitChunkCountPlugin</code> 中移除了 <code>minChunkSize</code> 选项</li><li>将与 javascript 相关的文件重组到子目录中<ul><li><code>webpack.JavascriptModulesPlugin</code> -&gt; <code>webpack.javascript.JavascriptModulesPlugin</code></li></ul></li><li>添加了 <code>Logger.getChildLogger</code></li><li>将 DllPlugin 中 entryOnly 选项的默认值变更为 true</li><li>移除了特殊请求的简化逻辑，使用单一的相对路径作为可读模块的名称</li><li>允许 webpack:// 将 SourceMaps 中的 url 改为相对于 webpack 根目录的路径</li><li>添加了 API 用于生成和处理针对 webpack 配置的 CLI 参数</li><li>当使用 System.js 作为 libraryTarget 时，在 System 中添加 <code>__system_context__</code> 作为上下文</li><li>为 DefinePlugin 添加 bigint 的支持</li><li>对基本环节添加 bigint 的支持，例如 maths</li><li>移除在创建 hash 后修改编译 hash 的功能</li><li>移除了 <code>HotModuleReplacementPlugin</code> 的 multiStep 模式</li><li>当使用嵌套的对象或数组时，<code>emitAsset</code> 中的 <code>assetInfo</code> 将被合并</li><li>当基于 <code>filename</code> 生成路径时，<code>[query]</code> 是一个有效占位符，如 asset</li><li>添加了 <code>Compilation.deleteAsset</code>，用于正确删除 asset 和非公用的相关资源</li><li>将 <code>require(&quot;webpack-sources&quot;)</code> 暴露为 <code>require(&quot;webpack&quot;).sources</code></li><li>terser 5</li><li>当 Webpack 作为句首时，Webpack 的 W 应该大写</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;webpack 4 于 2018 年 2 月发布。&lt;br&gt;从那时起，我们在没有重大更新的情况下，推出了很多功能。&lt;br&gt;我们知道，人们不喜欢带有突破性的重大变化。&lt;br&gt;尤其是 webpack，人们通常一年只接触两次，剩下的时间就 “只管用”了。&lt;br&gt;但是，在不做突破性改动的情况下推出功能也是有成本的：&lt;br&gt;我们不能做重大的 API 或架构改进。&lt;/p&gt;
&lt;p&gt;所以时不时就会有一个点，困难堆积起来，我们不得不做突破性的改动，才不至于把一切都搞乱。&lt;br&gt;这时候就需要一个新的主要版本了。&lt;br&gt;所以 webpack 5 包含了这些架构上的改进，以及没有这些改进就不可能实现的功能。&lt;/p&gt;
&lt;p&gt;这个主要版本也是修改一些默认值的机会，并与此同时出现的建议和规范保持一致。&lt;/p&gt;
&lt;p&gt;所以今天（2020-10-10）webpack 5.0.0 发布了，但这并不意味着它已经完成了，没有 bug，甚至功能完整。&lt;br&gt;就像 webpack 4 一样，我们通过修复问题和增加功能来继续开发。&lt;br&gt;在接下来的日子里，可能会有很多 bug 修复。功能会在以后出现。&lt;/p&gt;</summary>
    
    
    
    <category term="release" scheme="http://yonghong.tech/categories/release/"/>
    
    
    <category term="release" scheme="http://yonghong.tech/tags/release/"/>
    
    <category term="Webpack" scheme="http://yonghong.tech/tags/Webpack/"/>
    
    <category term="Frontend" scheme="http://yonghong.tech/tags/Frontend/"/>
    
    <category term="前端" scheme="http://yonghong.tech/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>技术爱好者周刊 第2期 | 2020年10月12日</title>
    <link href="http://yonghong.tech/weekly-002/"/>
    <id>http://yonghong.tech/weekly-002/</id>
    <published>2020-10-12T02:24:00.000Z</published>
    <updated>2020-10-12T02:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>技术爱好者周刊，每周一发布，欢迎提<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dhbmd5b25naG9uZy95b25naG9uZy1tZS9pc3N1ZXM=">issue<i class="fa fa-external-link-alt"></i></span>贡献内容。</p></blockquote><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9waW5nY2FwLmNvbS9ibG9nLWNuL21hc3MtZGF0YS1iYXRjaC1wcm9jZXNzaW5nLXRlY2hub2xvZ3ktYmFzZWQtb24tdGlzcGFyay8=">基于 TiSpark 的海量数据批量处理技术<i class="fa fa-external-link-alt"></i></span><br>熟悉 TiSpark 的人都知道，TiSpark 是 Spark 的一个插件，它其实就是给予了 Spark 能够去访问 TiDB 底层分布式存储引擎 TiKV 或者 TiFlash 的能力。之前我们一直在解决读的问题，写问题并没有付出太多的时间去解决。今天就给大家揭秘，我们是怎样使用 TiSpark 去实现海量数据批处理，然后写入到 TiDB 里面去的。</li></ul><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMDkvMzAvd2FpbWFpLW1vYmlsZS1hcmNoaXRlY3R1cmUtZXZvbHV0aW9uLmh0bWw=">外卖客户端容器化架构的演进<i class="fa fa-external-link-alt"></i></span><br>好的架构要不断演变，进而去适应业务的发展。美团在移动端上的架构，也经历了组件化、平台化、RN混合化，到现在开始向容器化变迁。容器化架构充分地利用了现在的跨端技术，将动态化的能力最大化地赋予了业务。作为美团最为重要的业务之一，美团外卖移动端的架构演进是怎样的呢？本文将为你揭开背后的思考、技术细节以及实践。</li></ul><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9saW51eHRveS5vcmcvYXJjaGl2ZXMvdmVyYWNyeXB0LWNvbmZpZ3VyYXRpb24tdGlwcy1mb3ItZHVhbGJvb3Qtc3lzdGVtLmh0bWw=">双引导系统下的 VeraCrypt 配置<i class="fa fa-external-link-alt"></i></span><br>对于笔记本电脑这种时常会携带外出的电子设备，基本的安全考量是必不可少的，而应用全盘加密（Full Disk Encryption）便是其中一个避免个人资料泄漏的重要措施。本文将简述如何在 Win Linux 双引导系统下使用 VeraCrypt 的配置技巧。</li></ul><a id="more"></a><h2 id="近期会议"><a href="#近期会议" class="headerlink" title="近期会议"></a>近期会议</h2><h3 id="2020-F5金融科技趋势线上研讨会"><a href="#2020-F5金融科技趋势线上研讨会" class="headerlink" title="2020 F5金融科技趋势线上研讨会"></a><span class="exturl" data-url="aHR0cDovL3d3dy5mNWNoaW5hbmV0d29ya3MuY29tL3BhcnRuZXIvd2VjaGF0L2RhdGFjZW50ZXIvaW52aXRlL2FjdGl2aXR5RGV0YWlscy5hc3A/bWVldGluZ2lkPTc2JnRyYWNraW5nY29kZT1mNWNvbW11bml0eQ==">2020 F5金融科技趋势线上研讨会<i class="fa fa-external-link-alt"></i></span></h3><p>报名链接：<span class="exturl" data-url="aHR0cDovL3d3dy5mNWNoaW5hbmV0d29ya3MuY29tL3BhcnRuZXIvd2VjaGF0L2RhdGFjZW50ZXIvaW52aXRlL2FjdGl2aXR5RGV0YWlscy5hc3A/bWVldGluZ2lkPTc2JnRyYWNraW5nY29kZT1mNWNvbW11bml0eQ==">2020 F5金融科技趋势线上研讨会<i class="fa fa-external-link-alt"></i></span></p><p>F5作为应用交付领域的领导者，在过去的几年中每年都会举办一次针对金融科技领域的线下研讨会，反响热烈。由于疫情原因，今年的研讨会将以线上的形式开展，我们将继续保持高品质的内容输出，为广大金融从业者奉献一场专为金融行业烹制的饕餮盛宴。</p><p>本次研讨会将围绕助力金融行业数字化转型，银行4.0（开放式银行），大数据价值挖掘与安全，现代应用的敏捷发布与管理，分布式架构的最佳实践等热门话题展开分享和讨论。 届时，国有大行，全国股份制银行，各城商行，证券，基金，保险等数百名金融机构从业人员； F5合作伙伴腾讯云、天空卫士和DellEMC一线技术大咖； 以及来自金融科技界的专家们均会在云中相聚，共同在线分享金融科技创新成果及他们的最佳业务实践。</p><p>  会议主题：2020 F5金融科技趋势线上研讨会</p><p>  会议时间：10月16 - 10月17日（周五-周六）下午 1:30 - 6:00</p><p>  会议形式：线上研讨会</p><h3 id="IBM-数据与-AI-线上论坛"><a href="#IBM-数据与-AI-线上论坛" class="headerlink" title="IBM 数据与 AI 线上论坛"></a><span class="exturl" data-url="aHR0cHM6Ly9pYm0uNmNvbm5leC5jb20vZXZlbnQvY2hpbmFjZW50ZXIvREFWRi9sb2dpbg==">IBM 数据与 AI 线上论坛<i class="fa fa-external-link-alt"></i></span></h3><p>报名链接：<span class="exturl" data-url="aHR0cHM6Ly9pYm0uNmNvbm5leC5jb20vZXZlbnQvY2hpbmFjZW50ZXIvREFWRi9sb2dpbg==">https://ibm.6connex.com/event/chinacenter/DAVF/login<i class="fa fa-external-link-alt"></i></span></p><p>如果将AI在企业的落地与扩展过程视为一场“障碍跑”，那么AI技能的缺乏、AI的可信性、数据的复杂性即是横亘途中的三大障碍。这个夏天开始，IBM将为您诚意打造”数有价，AI无界 | IBM数据与AI线上论坛”，三大专场为您逐一击破三大障碍，加速将AI愿景落地为现实！全球视角与本地洞察紧密结合，一次注册，畅享三大主题专场，全力助您冲刺AI落地与规模化之旅！</p><p>■ 7月15日：冲破人才瓶颈，AI赋能数字化技能专场 （内容回看已开放）<br>   您是否拥有让AI真正为企业所用的正确技能与人才？<br>   一起释放AI自动化的力量，弥补AI技能差距，降低AI技能门槛。</p><p>■ 8月26日：打开AI黑盒，构建可信企业级AI专场（内容回看已开放）<br>   您充分信任您取得的AI成果吗?<br>   一起探索如何构建和扩展可信任、可解释的企业级AI应用。</p><p>■ 10月21日：掘金复杂数据，让数据为业务所用专场（待开放）<br>   您的数据为AI做好准备了吗?<br>   一起实现数据的轻松获取与组织，确保数据简单、可访问且为业务就绪。</p><p>10月21日， “掘金复杂数据，让数据为业务所用专场”即将开场，精彩抢鲜放送：</p><p>精华内容 抢鲜剧透<br>· 接轨市场最前沿洞察<br>-现代化的企业数据架构如何降低您的运营与基础设施成本？<br>-企业数据治理的六大趋势您了解吗？<br>-可扩展及面向开源的高级统计分析、机器学习算法、文本分析如何助您锁定新商机？<br>-高性能计算及深度学习如何支持您将 AI 应用更快、更准、更安全地投入到业务应用中。<br>· 直通先行者成功经验<br>-讲述本土成功案例，复盘各行业先行者的成功轨迹<br>-更多全球成功案例供您按需点播，了解大洋彼岸的真实场景与实际应用<br>· 重塑您的数据与 AI 实践<br>-借力行业领先的 IBM 解决方案，了解IBM 明星产品如何助力数据与 AI 之旅</p><p>双重现场 双倍畅谈<br>· 第一现场，本地精彩案例分享及 IBM 全球数据与 AI 论坛精粹回看，全球专家与您共叙AI掘金经验<br>· 第二现场，带您亲临直播现场 —— IBM 中国数字销售中心，趣聊AI台前幕后事儿</p><h3 id="2020科大讯飞全球开发者大会"><a href="#2020科大讯飞全球开发者大会" class="headerlink" title="2020科大讯飞全球开发者大会"></a><span class="exturl" data-url="aHR0cHM6Ly8xMDI0LmlmbHl0ZWsuY29tLw==">2020科大讯飞全球开发者大会<i class="fa fa-external-link-alt"></i></span></h3><p>报名链接：<span class="exturl" data-url="aHR0cHM6Ly8xMDI0LmlmbHl0ZWsuY29tLw==">https://1024.iflytek.com/<i class="fa fa-external-link-alt"></i></span></p><p><img src="https://up-img.yonghong.tech/pic/2020/10/13-17-46-%E6%88%AA%E5%B1%8F2020-10-13%20%E4%B8%8B%E5%8D%885.46.37-XtozZN.png" alt="2020科大讯飞全球开发者大会"></p><p>科大讯飞全球1024开发者节是以AI开发者为受众群体的人工智能盛会，由科大讯飞发起并主办。选择在每年的10月24日，是因为在计算机世界中，1024是2的十次方，是二进制计数的基本计量单位之一，是1KB的字节数，因此组成了程序中的最基础基因序列。从事计算机工作的开发者就像一个个1024，以最具创新、最富热情的基础模块搭建起整个万物互联世界。 秉承“开放·合作·生态·共享”的理念，科大讯飞全球1024开发者节希望用最新最全的人工智能技术和产品促进跨行业链接、多领域碰撞、新技术开发，以科技之光、生态之念，立足当下、放眼未来。</p><h2 id="其他周报"><a href="#其他周报" class="headerlink" title="其他周报"></a>其他周报</h2><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1YW55Zi93ZWVrbHkvYmxvYi9tYXN0ZXIvZG9jcy9pc3N1ZS0xMjgubWQ=">科技爱好者周刊（第 128 期）：这个社会是否正在变成”赛博朋克”？<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BvbGFyaXMxMTE5L2dvbGFuZ3dlZWtseS9ibG9iL21hc3Rlci9kb2NzL2lzc3VlLTA2NC5tZA==">Go语言爱好者周刊：第 64 期<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3plbmFueS93ZWVrbHkvYmxvYi9tYXN0ZXIvc29mdHdhcmUvMjAyMC8xMDA1Lm1k">2020.10.05 - I was wrong. CRDTs are the future<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N3aWZ0T2xkRHJpdmVyL2lPUy1XZWVrbHkvYmxvYi9tYXN0ZXIvUmVwb3J0cy8yMDIwLyUyMzEzMS0yMDIwLjEwLjEyLm1k">老司机 iOS 周报 #131 | 2020-10-12<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9yd2Vla2x5Lm9yZy8yMDIwLTQwLmh0bWw=">R Weekly 2020-40 learnr tutorials, visual markdown editing, stat_layers<i class="fa fa-external-link-alt"></i></span></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;技术爱好者周刊，每周一发布，欢迎提&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL3dhbmd5b25naG9uZy95b25naG9uZy1tZS9pc3N1ZXM=&quot;&gt;issue&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;贡献内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;后端&quot;&gt;&lt;a href=&quot;#后端&quot; class=&quot;headerlink&quot; title=&quot;后端&quot;&gt;&lt;/a&gt;后端&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9waW5nY2FwLmNvbS9ibG9nLWNuL21hc3MtZGF0YS1iYXRjaC1wcm9jZXNzaW5nLXRlY2hub2xvZ3ktYmFzZWQtb24tdGlzcGFyay8=&quot;&gt;基于 TiSpark 的海量数据批量处理技术&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;熟悉 TiSpark 的人都知道，TiSpark 是 Spark 的一个插件，它其实就是给予了 Spark 能够去访问 TiDB 底层分布式存储引擎 TiKV 或者 TiFlash 的能力。之前我们一直在解决读的问题，写问题并没有付出太多的时间去解决。今天就给大家揭秘，我们是怎样使用 TiSpark 去实现海量数据批处理，然后写入到 TiDB 里面去的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;前端&quot;&gt;&lt;a href=&quot;#前端&quot; class=&quot;headerlink&quot; title=&quot;前端&quot;&gt;&lt;/a&gt;前端&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMDkvMzAvd2FpbWFpLW1vYmlsZS1hcmNoaXRlY3R1cmUtZXZvbHV0aW9uLmh0bWw=&quot;&gt;外卖客户端容器化架构的演进&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;好的架构要不断演变，进而去适应业务的发展。美团在移动端上的架构，也经历了组件化、平台化、RN混合化，到现在开始向容器化变迁。容器化架构充分地利用了现在的跨端技术，将动态化的能力最大化地赋予了业务。作为美团最为重要的业务之一，美团外卖移动端的架构演进是怎样的呢？本文将为你揭开背后的思考、技术细节以及实践。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Linux&quot;&gt;&lt;a href=&quot;#Linux&quot; class=&quot;headerlink&quot; title=&quot;Linux&quot;&gt;&lt;/a&gt;Linux&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9saW51eHRveS5vcmcvYXJjaGl2ZXMvdmVyYWNyeXB0LWNvbmZpZ3VyYXRpb24tdGlwcy1mb3ItZHVhbGJvb3Qtc3lzdGVtLmh0bWw=&quot;&gt;双引导系统下的 VeraCrypt 配置&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;对于笔记本电脑这种时常会携带外出的电子设备，基本的安全考量是必不可少的，而应用全盘加密（Full Disk Encryption）便是其中一个避免个人资料泄漏的重要措施。本文将简述如何在 Win Linux 双引导系统下使用 VeraCrypt 的配置技巧。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术爱好者周刊" scheme="http://yonghong.tech/categories/%E6%8A%80%E6%9C%AF%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A/"/>
    
    
    <category term="技术爱好者周刊" scheme="http://yonghong.tech/tags/%E6%8A%80%E6%9C%AF%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>ARPU 是什么？ ARPPU 是什么？累计 ARPU 是什么？</title>
    <link href="http://yonghong.tech/wiki/arpu-and-arppu/"/>
    <id>http://yonghong.tech/wiki/arpu-and-arppu/</id>
    <published>2020-10-11T02:00:00.000Z</published>
    <updated>2020-10-11T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ARPU-每用户平均收入或平均每用户收入"><a href="#ARPU-每用户平均收入或平均每用户收入" class="headerlink" title="ARPU 每用户平均收入或平均每用户收入"></a>ARPU 每用户平均收入或平均每用户收入</h2><p>ARPU: the Average Revenue Per User </p><blockquote><p><strong>ARPU = 应用收益 / 应用活跃用户</strong></p></blockquote><p>ARPU 这个指标计算的是某时间段内平均每个活跃用户为应用创造的收入。</p><p>ARPU 的计算中，所有的用户都被纳入了计算范围——无论是付费用户或非付费用户。ARPU 是评估应用变现有效性的指标：ARPU 越高，就代表用户在这段时间内为应用带来的变现收入就越多。 </p><p>ARPU可用于评估应用中的变动是否能有效提升变现收益：如果ARPU提升，证明应用的变动有利于提升应用变现收益；如果ARPU不升反降，应用开发者可能就需要确认一下变动的有效性了。</p><h2 id="ARPPU-每付费用户平均收益"><a href="#ARPPU-每付费用户平均收益" class="headerlink" title="ARPPU 每付费用户平均收益"></a>ARPPU 每付费用户平均收益</h2><p>ARPPU: the Average Revenue Per Paying User</p><blockquote><p><strong>ARPPU = 应用收益 / 应用付费用户</strong></p></blockquote><p>由于分母上数值较小（付费用户&lt;全体活跃用户），对于同一时间的同一应用而言，ARPPU的数值会明显高于ARPU。</p><p>ARPPU 这个指标考核的是某时间段内平均每个付费用户为应用创造的收入。在用户数量上，ARPPU只考虑某一时间段内的付费用户，而非该时间段内所有的活跃用户。</p><a id="more"></a><p>ARPPU能够反映付费用户为你的应用带来了多少收益，显示出一个忠诚付费用户实际上愿意支付的金额。同时，这个指标也可以显示用户对一些付费项目的反应。</p><p>应用提高收费价格，ARPPU会有一定的提升。但这并不意味着盈利也随之增长，因为涨价往往会让一些无法接受新价格的用户停止付费，导致付费用户规模下降。</p><p>因此，ARPU与ARPPU两者的关系其实可以这样表达：</p><blockquote><p><strong>ARPU = ARPPU * 付费用户比例</strong></p></blockquote><p>我们依然用一个例子来理解一下：</p><p>假如你的应用有 10,000 个活跃用户，其中 30 个是付费用户，你的月收入是 30,000 美金。</p><p>那么，ARPU = $30,000 / 10,000 = $3</p><p>也就是说，一个活跃用户平均一个月能给你带来$3的收益。</p><p>同时，ARPPU = $30,000 / 30 = $1,000</p><p>也就是说，一个付费用户平均在一个月能给你带来 $1,000 的收益。</p><p>在这种情况下，付费用户规模为 30 / 10,000 = 0.3%</p><p>ARPU($3) = ARPPU($1,000) * 付费用户规模(0.3%)</p><h2 id="累计-ARPU"><a href="#累计-ARPU" class="headerlink" title="累计 ARPU"></a>累计 ARPU</h2><p>在实际应用中，还有一个十分有用的指标：累计ARPU。</p><p>如果说ARPU计算的是一个时间段内全部用户产生的应用收益，累计ARPU则聚焦在一定时间段内的某组用户群体对应用产生的收益。</p><p>累计ARPU通常以一段时间为计算单位，比如说1天、7天、14天、30天等等。举个例子，ARPU可以用于计算10月1日下载应用的100名用户在30天内平均每人为应用带来了多少收益。</p><p>因此，累积ARPU是一个不断增长的数值，因为计算的用户对象数值不变，但是产生的收益却在一直增长。如果应用表现良好，流量购买就发挥效果，累积ARPU的值迟早都会超过CPI（cost per install，单次安装成本）。这就意味着，你买的量开始给你盈利了，ROI从此超过100%。</p><p>当时间范围延长，累积ARPU无限接近一个极限值，这就是我们常说的LTV指数了。</p><p><img src="https://up-img.yonghong.tech/pic/2020/10/11-10-32-JsbDho-9YHAaC.png" alt="累计 ARPU"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>ARPU: the Average Revenue Per User 有时候也是 the Average Revenue Per Unit</p><p>ARPA: the Average Revenue Per Account</p><p>ARPC: the Average Revenue Per Customer</p><p>LTV: Life Time Value 用户的终身价值或用户生命周期价值</p><p>CAC: Customer Acquisition Cost 用户获取成本</p><p>ROI: Return on Investment 投资回报</p><p>ROAS: Return on Advertising Spend 广告投资回报</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ARPU-每用户平均收入或平均每用户收入&quot;&gt;&lt;a href=&quot;#ARPU-每用户平均收入或平均每用户收入&quot; class=&quot;headerlink&quot; title=&quot;ARPU 每用户平均收入或平均每用户收入&quot;&gt;&lt;/a&gt;ARPU 每用户平均收入或平均每用户收入&lt;/h2&gt;&lt;p&gt;ARPU: the Average Revenue Per User &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;ARPU = 应用收益 / 应用活跃用户&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ARPU 这个指标计算的是某时间段内平均每个活跃用户为应用创造的收入。&lt;/p&gt;
&lt;p&gt;ARPU 的计算中，所有的用户都被纳入了计算范围——无论是付费用户或非付费用户。ARPU 是评估应用变现有效性的指标：ARPU 越高，就代表用户在这段时间内为应用带来的变现收入就越多。 &lt;/p&gt;
&lt;p&gt;ARPU可用于评估应用中的变动是否能有效提升变现收益：如果ARPU提升，证明应用的变动有利于提升应用变现收益；如果ARPU不升反降，应用开发者可能就需要确认一下变动的有效性了。&lt;/p&gt;
&lt;h2 id=&quot;ARPPU-每付费用户平均收益&quot;&gt;&lt;a href=&quot;#ARPPU-每付费用户平均收益&quot; class=&quot;headerlink&quot; title=&quot;ARPPU 每付费用户平均收益&quot;&gt;&lt;/a&gt;ARPPU 每付费用户平均收益&lt;/h2&gt;&lt;p&gt;ARPPU: the Average Revenue Per Paying User&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;ARPPU = 应用收益 / 应用付费用户&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于分母上数值较小（付费用户&amp;lt;全体活跃用户），对于同一时间的同一应用而言，ARPPU的数值会明显高于ARPU。&lt;/p&gt;
&lt;p&gt;ARPPU 这个指标考核的是某时间段内平均每个付费用户为应用创造的收入。在用户数量上，ARPPU只考虑某一时间段内的付费用户，而非该时间段内所有的活跃用户。&lt;/p&gt;</summary>
    
    
    
    <category term="wiki" scheme="http://yonghong.tech/categories/wiki/"/>
    
    
    <category term="wiki" scheme="http://yonghong.tech/tags/wiki/"/>
    
    <category term="ARPU" scheme="http://yonghong.tech/tags/ARPU/"/>
    
    <category term="ARPPU" scheme="http://yonghong.tech/tags/ARPPU/"/>
    
    <category term="ARPA" scheme="http://yonghong.tech/tags/ARPA/"/>
    
    <category term="ARPC" scheme="http://yonghong.tech/tags/ARPC/"/>
    
    <category term="ROI" scheme="http://yonghong.tech/tags/ROI/"/>
    
    <category term="每用户平均收入" scheme="http://yonghong.tech/tags/%E6%AF%8F%E7%94%A8%E6%88%B7%E5%B9%B3%E5%9D%87%E6%94%B6%E5%85%A5/"/>
    
    <category term="平均每用户收入" scheme="http://yonghong.tech/tags/%E5%B9%B3%E5%9D%87%E6%AF%8F%E7%94%A8%E6%88%B7%E6%94%B6%E5%85%A5/"/>
    
    <category term="每帐户平均收入" scheme="http://yonghong.tech/tags/%E6%AF%8F%E5%B8%90%E6%88%B7%E5%B9%B3%E5%9D%87%E6%94%B6%E5%85%A5/"/>
    
    <category term="每客户平均收入" scheme="http://yonghong.tech/tags/%E6%AF%8F%E5%AE%A2%E6%88%B7%E5%B9%B3%E5%9D%87%E6%94%B6%E5%85%A5/"/>
    
    <category term="每个付费用户的平均收入" scheme="http://yonghong.tech/tags/%E6%AF%8F%E4%B8%AA%E4%BB%98%E8%B4%B9%E7%94%A8%E6%88%B7%E7%9A%84%E5%B9%B3%E5%9D%87%E6%94%B6%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>软件推荐 | 更好用的图床(文件)上传客户端 uPic</title>
    <link href="http://yonghong.tech/recommend/upic/"/>
    <id>http://yonghong.tech/recommend/upic/</id>
    <published>2020-10-10T09:00:00.000Z</published>
    <updated>2020-10-10T09:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dlZTFrL3VQaWM=">uPic(upload Picture)<i class="fa fa-external-link-alt"></i></span> 是一款 macOS 端的图床(文件)上传客户端。</p><p>💡 特点：：无论是本地文件、或者屏幕截图都可自动上传，菜单栏显示实时上传进度。上传完成后文件链接自动复制到剪切板，让你无论是在写博客、灌水聊天都能快速插入图片。 连接格式可以是普通 URL、HTML 或者 Markdown，仍由你掌控。</p><p><strong>🔋 支持图床：</strong> <span class="exturl" data-url="aHR0cHM6Ly9zbS5tcy8=">smms<i class="fa fa-external-link-alt"></i></span>、 <span class="exturl" data-url="aHR0cHM6Ly93d3cudXB5dW4uY29tL3Byb2R1Y3RzL2ZpbGUtc3RvcmFnZQ==">又拍云 USS<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cucWluaXUuY29tL3Byb2R1Y3RzL2tvZG8=">七牛云 KODO<i class="fa fa-external-link-alt"></i></span>、 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS9wcm9kdWN0L29zcy8=">阿里云 OSS<i class="fa fa-external-link-alt"></i></span>、 <span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9wcm9kdWN0L2Nvcw==">腾讯云 COS<i class="fa fa-external-link-alt"></i></span>、 <span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC5iYWlkdS5jb20vcHJvZHVjdC9ib3MuaHRtbA==">百度云 BOS<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93ZWliby5jb20v">微博<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL3Rva2Vucw==">Github<i class="fa fa-external-link-alt"></i></span>、 <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vcHJvZmlsZS9wZXJzb25hbF9hY2Nlc3NfdG9rZW5z">Gitee<i class="fa fa-external-link-alt"></i></span>、 <span class="exturl" data-url="aHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9jbi9zMy8=">Amazon S3<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9pbWd1ci5jb20v">Imgur<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnN2ZW5kLmNjL3VwaWMvdHV0b3JpYWxzL2N1c3RvbQ==">自定义上传接口<i class="fa fa-external-link-alt"></i></span>、…</p><a id="more"></a><h2 id="🚀-如何安装"><a href="#🚀-如何安装" class="headerlink" title="🚀 如何安装"></a>🚀 如何安装</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><h4 id="1-Homebrew-推荐"><a href="#1-Homebrew-推荐" class="headerlink" title="1.Homebrew(推荐):"></a>1.Homebrew(推荐):</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>cask <span class="keyword">install </span>upic</span><br></pre></td></tr></table></figure><h4 id="2-手动"><a href="#2-手动" class="headerlink" title="2.手动"></a>2.手动</h4><p>从 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dlZTFrL3VQaWMvcmVsZWFzZXM=">Github release<i class="fa fa-external-link-alt"></i></span> 下载。</p><p><strong>如果在国内访问 Github 下载困难的，可以从<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZ2VlMWsvdVBpYy9yZWxlYXNlcw==">Gitee release<i class="fa fa-external-link-alt"></i></span>下载。</strong></p><h3 id="检查-Finder-扩展权限"><a href="#检查-Finder-扩展权限" class="headerlink" title="检查 Finder 扩展权限"></a>检查 Finder 扩展权限</h3><ul><li><p>1.打开 uPic</p></li><li><p>2.打开<code>系统偏好设置</code> - <code>扩展</code> - <code>访达扩展</code> 确保 <code>uPicFinderExtension</code>是勾选状态</p></li></ul><img src="https://up-img.yonghong.tech/pic/2020/10/10-17-07-68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f676565316b2f6f7373406d61737465722f73637265656e73686f742f755069632d636e2f66696e6465722d657874656e73696f6e2e706e67-DYYKob.png" width="650px" style="margin: 0 auto;"/><h2 id="🕹-使用方式"><a href="#🕹-使用方式" class="headerlink" title="🕹 使用方式"></a>🕹 使用方式</h2><table><thead><tr><th>功能</th><th>描述</th><th>预览</th></tr></thead><tbody><tr><td><strong>🖥 选择文件上传</strong></td><td>从<code>Finder</code>选择文件上传。<code>可设置全局快捷键</code></td><td><img src="https://up-img.yonghong.tech/pic/2020/10/10-17-07-68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f676565316b2f6f7373406d61737465722f73637265656e73686f742f755069632d636e2f73656c65637446696c652e676966-VqFefp.gif" alt="img"></td></tr><tr><td><strong>⌨️ 复制文件上传</strong></td><td>上传已拷贝到剪切板的文件。<code>可设置全局快捷键</code></td><td><img src="https://up-img.yonghong.tech/pic/2020/10/10-17-07-68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f676565316b2f6f7373406d61737465722f73637265656e73686f742f755069632d636e2f7061737465626f6172642e676966-hBiI5s.gif" alt="img"></td></tr><tr><td><strong>📸 截图上传</strong></td><td>直接拉框截图上传。<code>可设置全局快捷键</code></td><td><img src="https://up-img.yonghong.tech/pic/2020/10/10-17-07-68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f676565316b2f6f7373406d61737465722f73637265656e73686f742f755069632d636e2f73637265656e73686f742e676966-91Kj7l.gif" alt="img"></td></tr><tr><td><strong>🖱 拖拽本地文件上传</strong></td><td>拖拽文件到状态栏上传</td><td><img src="https://up-img.yonghong.tech/pic/2020/10/10-17-07-68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f676565316b2f6f7373406d61737465722f73637265656e73686f742f755069632d636e2f6472616746696c652e676966-5Dzzbw.gif" alt="img"></td></tr><tr><td><strong>🖱 拖拽浏览器图片上传</strong></td><td>从浏览器拖拽图片到状态栏上传</td><td><img src="https://up-img.yonghong.tech/pic/2020/10/10-17-07-68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f676565316b2f6f7373406d61737465722f73637265656e73686f742f755069632d636e2f6472616746726f6d42726f777365722e676966-QYEBH7.gif" alt="img"></td></tr><tr><td><strong>📂 Finder 中右键上传</strong></td><td>右击文件上传</td><td><img src="https://up-img.yonghong.tech/pic/2020/10/10-17-07-68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f676565316b2f6f7373406d61737465722f73637265656e73686f742f755069632d636e2f636f6e746578746d656e752e676966-7Nmsoo.gif" alt="img"></td></tr><tr><td><strong>⌨️ 命令行上传</strong></td><td>通过执行命令调用 uPic 上传文件</td><td><img src="https://up-img.yonghong.tech/pic/2020/10/10-17-07-68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f676565316b2f6f7373406d61737465722f73637265656e73686f742f755069632d636e2f636c692e676966-uqE7yy.gif" alt="img"></td></tr></tbody></table><h2 id="🧰-更多功能"><a href="#🧰-更多功能" class="headerlink" title="🧰 更多功能"></a>🧰 更多功能</h2><h3 id="1-全局快捷键"><a href="#1-全局快捷键" class="headerlink" title="1.全局快捷键"></a>1.全局快捷键</h3><img src="https://up-img.yonghong.tech/pic/2020/10/10-17-07-68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f676565316b2f6f7373406d61737465722f73637265656e73686f742f755069632d636e2f73686f7274637574732e706e67-eWTput.png" width="450px" style="margin: 0 auto;"/><h3 id="2-上传历史"><a href="#2-上传历史" class="headerlink" title="2. 上传历史"></a>2. 上传历史</h3><img src="https://up-img.yonghong.tech/pic/2020/10/10-17-07-68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f676565316b2f6f7373406d61737465722f73637265656e73686f742f755069632d636e2f686973746f72792e706e67-Ad5U62.png" width="650px" style="margin: 0 auto;"/>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL2dlZTFrL3VQaWM=&quot;&gt;uPic(upload Picture)&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt; 是一款 macOS 端的图床(文件)上传客户端。&lt;/p&gt;
&lt;p&gt;💡 特点：：无论是本地文件、或者屏幕截图都可自动上传，菜单栏显示实时上传进度。上传完成后文件链接自动复制到剪切板，让你无论是在写博客、灌水聊天都能快速插入图片。 连接格式可以是普通 URL、HTML 或者 Markdown，仍由你掌控。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;🔋 支持图床：&lt;/strong&gt; &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9zbS5tcy8=&quot;&gt;smms&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;、 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cudXB5dW4uY29tL3Byb2R1Y3RzL2ZpbGUtc3RvcmFnZQ==&quot;&gt;又拍云 USS&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;、&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cucWluaXUuY29tL3Byb2R1Y3RzL2tvZG8=&quot;&gt;七牛云 KODO&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;、 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS9wcm9kdWN0L29zcy8=&quot;&gt;阿里云 OSS&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;、 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9wcm9kdWN0L2Nvcw==&quot;&gt;腾讯云 COS&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;、 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9jbG91ZC5iYWlkdS5jb20vcHJvZHVjdC9ib3MuaHRtbA==&quot;&gt;百度云 BOS&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;、&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93ZWliby5jb20v&quot;&gt;微博&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;、&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL3Rva2Vucw==&quot;&gt;Github&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;、 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRlZS5jb20vcHJvZmlsZS9wZXJzb25hbF9hY2Nlc3NfdG9rZW5z&quot;&gt;Gitee&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;、 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9jbi9zMy8=&quot;&gt;Amazon S3&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;、&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9pbWd1ci5jb20v&quot;&gt;Imgur&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;、&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9ibG9nLnN2ZW5kLmNjL3VwaWMvdHV0b3JpYWxzL2N1c3RvbQ==&quot;&gt;自定义上传接口&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;、…&lt;/p&gt;</summary>
    
    
    
    <category term="软件推荐" scheme="http://yonghong.tech/categories/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="推荐" scheme="http://yonghong.tech/tags/%E6%8E%A8%E8%8D%90/"/>
    
    <category term="软件推荐" scheme="http://yonghong.tech/tags/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    
    <category term="uPic" scheme="http://yonghong.tech/tags/uPic/"/>
    
    <category term="图床" scheme="http://yonghong.tech/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>网站推荐 | 基于CC0协议的免版权图库 Hippopx</title>
    <link href="http://yonghong.tech/recommend/hippopx/"/>
    <id>http://yonghong.tech/recommend/hippopx/</id>
    <published>2020-10-09T14:24:00.000Z</published>
    <updated>2020-10-09T14:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaGlwcG9weC5jb20v">Hippopx<i class="fa fa-external-link-alt"></i></span> 是一个基于 CC0 协议的免版权图库。Hippopx 提供的图像可免费用于个人和商业项目。网站提供了多种语言，包括中文。该网站上的每一张图片都打上了相关内容的标签，图片的命名也和内容相关。</p><h2 id="网站截图"><a href="#网站截图" class="headerlink" title="网站截图"></a>网站截图</h2><p><img src="https://up-img.yonghong.tech/pic/2020/10/09-22-44-%E6%88%AA%E5%B1%8F2020-10-09%20%E4%B8%8B%E5%8D%8810.37.12-lothe7.png" alt="Hippopx首页"></p><a id="more"></a><p><img src="https://up-img.yonghong.tech/pic/2020/10/09-22-45-%E6%88%AA%E5%B1%8F2020-10-09%20%E4%B8%8B%E5%8D%8810.38.09-dK13jp.png" alt="Hippopx热门图片"></p><h2 id="什么是CC0？"><a href="#什么是CC0？" class="headerlink" title="什么是CC0？"></a>什么是CC0？</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL3B1YmxpY2RvbWFpbi96ZXJvLzEuMC9kZWVkLnpo">https://creativecommons.org/publicdomain/zero/1.0/deed.zh<i class="fa fa-external-link-alt"></i></span></p><p><strong>CC0 1.0 通用 (CC0 1.0) 公共领域贡献</strong> 意味着 <strong>无著作权</strong></p><p>在作品上适用该文本的人已经将作品 贡献 至公共领域，在法律允许的范围，放弃所有他在全世界范围内基于著作权法对作品享有的权利，包括所有相关权利和邻接权利。</p><p>您可以复制、修改、发行和表演本作品，甚至可用于商业性目的，都无需要求同意。请看以下其他信息。</p><p>CC0不影响任何人可能拥有的专利权或商标权，也不影响其他人可能拥有的对本作品本身的权利，或者决定本作品如何使用的权利，比如形象权或隐私权。</p><p>除非另有明确声明，本文件项下的作品关联人，在可适用法律所允许的最大限度内，不对本作品提供担保，不承担因本作品使用产生的责任。</p><p>当使用或引用本作品时，您不得暗示 作者或声明人为您的行为背书。</p><h2 id="条款"><a href="#条款" class="headerlink" title="条款"></a>条款</h2><p>Hippopx 提供的图像可免费用于个人和商业项目，本页列出了商业项目的定义和使用条件。请阅读全文，从 Hippopx 下载图像，您需要同意下面规定的所有条款和条件。</p><h2 id="什么是商业用途？"><a href="#什么是商业用途？" class="headerlink" title="什么是商业用途？"></a>什么是商业用途？</h2><p>来自本网站的图像可用于几乎任何商业设计项目，这包括大多数形式的数字或印刷创意：网页设计，应用程序设计，WordPress主题，PSD和HTML模板等。博客和社交媒体团队也可以自由地使用我们的图片。</p><h2 id="您是否需要提供图片来源？"><a href="#您是否需要提供图片来源？" class="headerlink" title="您是否需要提供图片来源？"></a>您是否需要提供图片来源？</h2><p>不必须，但它是提供图片来源是推荐的，特别是对于商业 WordPress 主题和网络模板。如果您无法提供图片来源，请通过社交媒体和博客与同事和朋友分享此网站。这个网站分享的越多，我们可以与您分享的图片也更多。</p><h2 id="商业形象使用注意事项"><a href="#商业形象使用注意事项" class="headerlink" title="商业形象使用注意事项"></a>商业形象使用注意事项</h2><h3 id="品牌知名度"><a href="#品牌知名度" class="headerlink" title="品牌知名度"></a>品牌知名度</h3><p>我们的一些图片包含来自知名品牌和已注册商标的公司的产品。这些商标需要得到尊重和承认。</p><h3 id="型号版本"><a href="#型号版本" class="headerlink" title="型号版本"></a>型号版本</h3><p>Hippopx 提供真实世界的摄影。这意味着，我们提供的任何包含人员的图像可能未通过模型发布，因此这些图像可能不适合某些类型的商业用途。</p><h3 id="产权"><a href="#产权" class="headerlink" title="产权"></a>产权</h3><p>某些图像可能包含拥有图像和产权的私营公司拥有的私人建筑。这些图像可能不适合某些类型的商业用途，因为您需要获得有关公司的许可才能合法发布图像。</p><h2 id="禁止使用"><a href="#禁止使用" class="headerlink" title="禁止使用"></a>禁止使用</h2><p>您不得将我们的图像用于色情、非法或其他不道德目的，或以可能给被描绘的人起坏名声的方式使用，或暗示可识别的人、品牌或组织认可产品和服务。您不能在免费库存照片网站或应用程序上使用这些图像或重新分发这些图片，您不能出售和/或重新分发这些图像，暗示您是摄影师;你不能出售和/或重新分发这些图像作为股票摄影</p><h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><p>Hippopx 对因不正确或不当使用从本网站下载的任何图像而导致的任何版权侵犯不负任何责任。Hippopx 的所有用户下载和使用我们的映像的风险由他们自己承担，并完全负责后续的图像使用和应用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuaGlwcG9weC5jb20v&quot;&gt;Hippopx&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt; 是一个基于 CC0 协议的免版权图库。Hippopx 提供的图像可免费用于个人和商业项目。网站提供了多种语言，包括中文。该网站上的每一张图片都打上了相关内容的标签，图片的命名也和内容相关。&lt;/p&gt;
&lt;h2 id=&quot;网站截图&quot;&gt;&lt;a href=&quot;#网站截图&quot; class=&quot;headerlink&quot; title=&quot;网站截图&quot;&gt;&lt;/a&gt;网站截图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://up-img.yonghong.tech/pic/2020/10/09-22-44-%E6%88%AA%E5%B1%8F2020-10-09%20%E4%B8%8B%E5%8D%8810.37.12-lothe7.png&quot; alt=&quot;Hippopx首页&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="网站推荐" scheme="http://yonghong.tech/categories/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
    
    
    <category term="网站推荐" scheme="http://yonghong.tech/tags/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
    
    <category term="推荐" scheme="http://yonghong.tech/tags/%E6%8E%A8%E8%8D%90/"/>
    
    <category term="Hippopx" scheme="http://yonghong.tech/tags/Hippopx/"/>
    
    <category term="无版权图库" scheme="http://yonghong.tech/tags/%E6%97%A0%E7%89%88%E6%9D%83%E5%9B%BE%E5%BA%93/"/>
    
    <category term="图库" scheme="http://yonghong.tech/tags/%E5%9B%BE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>解密九型人格读书笔记（5） | 你适不适合搞管理？</title>
    <link href="http://yonghong.tech/2020/10/jiu-xing-ren-ge-005/"/>
    <id>http://yonghong.tech/2020/10/jiu-xing-ren-ge-005/</id>
    <published>2020-10-09T09:00:00.000Z</published>
    <updated>2020-10-09T09:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>◇测验一：假如你已知道你的生活将发生如下变化，是否仍能愉快地从事管理工作？</p><p>　　1．你将越来越多地涉及管理，而和技术的联系越来越少。<br>　　2．一旦决定搞管理，就不能半途而废。即使你想再去搞技术，也是办不到的，因为技术的前进太迅速了。<br>　　3．你将从一个可靠的领域，即一个对自己所做的事隋有把握的领域，转向一个无论从可利用的人力还是工作条件都无把握的领域。<a id="more"></a><br>　　4．你必须大大扩大知识面和兴趣范围，丝毫不能将兴趣集中于一点或致力于一个专业。5．你必须放弃你在专业上所取得的成绩，而为自己能渐渐支配更多的人，组织越来越多的活动及能够帮助其他专业人员取得成功而感到满足。</p><p>◇测验二：</p><p>　　1．如果让你选择不同于现在工作的一个职业，你喜欢做一个：<br>　　a．医生<br>　　b．勘探员<br>　　2．你喜欢读关于哪一方面的书？<br>　　a．地理学<br>　　b．心理学<br>　　3．你喜欢怎样度过一个夜晚？<br>　　a．做新家具<br>　　b．和朋友做游戏<br>　　4．如果某人耽误你的时间，怎么办呢？<br>　　a．总是很耐心<br>　　b．往往会发火<br>　　5．你喜欢做哪件事？<br>　　a．会见陌生人<br>　　b．看展览<br>　　6．你喜欢别人称你：<br>　　a．善于合作<br>　　b．机智多谋<br>　　7．每样东西都有放处且各就各位，这对你：<br>　　a．很重要<br>　　b．不怎么重要<br>　　8．如果你强烈反对某个人，将怎么办？<br>　　a．力求最大的统一，使争论最少<br>　　b．将在价值、原则及政策上争论个水落石出<br>　　9．你是否能容易地放下正在阅读的一个很有趣的故事？<br>　　a．能<br>　　b．不能<br>　　10．在一出戏中，你喜欢演哪个角色？<br>　　a．富兰克林<br>　　b．约瑟夫（政治家）<br>　　c．查理斯·凯特玲（工程师，电机的发明人）</p><p>◇测验三：</p><p>　　1．你做出的从事管理工作的决定，是否与你的能力、兴趣、品质、个性和目标相一致？是否能比你从事技术工作更加可以施展你的才能？<br>　　2．你是否具有从事管理工作的较强的能力和必要的条件？是否期待将来亲身投入管理工作中去？<br>　　3．你肯定管理工作能使自己得到个人心理上的更大满足吗？<br>　　4．你是否对本企业的情况有一个全面的了解？你熟悉你所在企业的不同部门的不同要求和不同管理方法吗？是否很容易从这一部门转到另一部门呢？<br>　　5．你已确立了今后5～10年的奋斗目标了吗？你肯定现在的工作更能达到你的目的吗？你意识到在管理阶层中，存在更强有力的竞争吗？你肯定自己能充分地正视这些竞争吗？<br>　　6．你是否更注重人而不是工作？你更喜欢和别人工作在一起吗？你能很容易地找到合作者吗？你自愿帮助别人吗？你真正知道人们为什么在社会中如此表现吗？<br>　　7．你的同事和朋友认为你友好和随和吗？假如你已意识到帮助别人时要牺牲个人利益，是否仍执意这样做？朋友请教你吗？你愿意得到别人的帮助吗？<br>　　8．你能在变化莫测的情况下灵活处事，在一时混乱的情况下泰然处之吗？当所有的情况都不能如愿以偿时，你仍能快活吗？当对自己决定的后果尚无把握时，你觉得烦躁不安吗？<br>　　9．你是否觉得信任他人且他人信任你？你能很容易地消除隔阂吗？<br>　　10．你在工作中注重人和主观因素吗？你注重利用他人吗？你同样注重自己的下级吗？<br>　　11．你是否注意自己的行为且试图解释过？你是否有时听见自己的言论像是来自别人的观点？你曾努力从别人的立场出发来寻求看待事物的方式吗？<br>　　12．你觉得自己很善于广泛接触各种各样的人，并在使用人时尽可能发挥他们的作用吗？</p><hr><p>　　◇测试答案<br>　　测验一：如果你的生活发生上述的四到五种变化仍能适应，那么你适合于管理工作。<br>　　测验二：适于搞管理工作的人有如下列回答：1a，2b，3b，4a，5a，6a，7a，8a，9a，10a。<br>　　测验三：在上述12个问题中，你有6个以上回答“是”吗？如果是的话，那你就有可能并有能力领导一个棘手的企业。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;◇测验一：假如你已知道你的生活将发生如下变化，是否仍能愉快地从事管理工作？&lt;/p&gt;
&lt;p&gt;　　1．你将越来越多地涉及管理，而和技术的联系越来越少。&lt;br&gt;　　2．一旦决定搞管理，就不能半途而废。即使你想再去搞技术，也是办不到的，因为技术的前进太迅速了。&lt;br&gt;　　3．你将从一个可靠的领域，即一个对自己所做的事隋有把握的领域，转向一个无论从可利用的人力还是工作条件都无把握的领域。</summary>
    
    
    
    <category term="读书笔记" scheme="http://yonghong.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="心理学" scheme="http://yonghong.tech/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
    <category term="九型人格" scheme="http://yonghong.tech/tags/%E4%B9%9D%E5%9E%8B%E4%BA%BA%E6%A0%BC/"/>
    
    <category term="读书笔记" scheme="http://yonghong.tech/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>解密九型人格读书笔记（4） | 测验一下你的性格</title>
    <link href="http://yonghong.tech/2020/10/jiu-xing-ren-ge-004/"/>
    <id>http://yonghong.tech/2020/10/jiu-xing-ren-ge-004/</id>
    <published>2020-10-09T08:00:00.000Z</published>
    <updated>2020-10-09T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　1．你认为你是一个有个性、有自己的思想及主见的人吗？<br>　　是（请回答问题2）<br>　　否（请回答问题8）<br>　　2．你比较喜欢星形还是心形的项链呢？<br>　　星形（请回答问题3）<br>　　心形（请回答问题9）<br>　　3．你喜欢玩洋娃娃或机器人吗？<br>　　喜欢（请回答问题11）<br>　　不喜欢（请回答问题4）<a id="more"></a><br>　　4．你对中国的传统服饰有兴趣吗？<br>　　有兴趣（请回答问题11）<br>　　没有太大兴趣（请回答问题5）<br>　　5．你的衣柜里有红色的衣服吗？<br>　　有（请回答问题6）<br>　　没有（请回答问题12）<br>　　6．你愿意申请一份需要工作经验的职位吗？<br>　　愿意（请回答问题7）<br>　　不愿意（请回答问题13）<br>　　7．你受到朋友的欢迎，是否因为你是一个可靠的人呢？<br>　　是（你属于a型）<br>　　否（你属于b型）<br>　　8．你是短头发吗？<br>　　是（请回答问题2）<br>　　否（请回答问题15）<br>　　9．你是否觉得你的肤色不够白皙呢？<br>　　是（请回答问题3）<br>　　否（请回答问题16）<br>　　10．请从下列两种花中选择你较喜欢的一种：<br>　　向日葵（请回答问题14）<br>　　野菊花（请回答问题11）<br>　　11．你是否是一个有责任心的学生或职员呢？<br>　　是（请回答问题5）<br>　　否（请回答问题17）<br>　　12．你最近对手工艺有兴趣吗？<br>　　有兴趣（请回答问题18）<br>　　没有兴趣（请回答问题6）<br>　　13．你认为你是一个亲切友善的人吗？<br>　　是（请回答问题7）<br>　　否（请回答问题19）<br>　　14．你介意与一群异性朋友睡在相同的一张床上吗？<br>　　介意（请回答问题20）<br>　　不介意（你是属于a型）<br>　　15．运动是否是你主要的课余活动呢？<br>　　是（请回答问题9）<br>　　否（请回答问题21）<br>　　16．你对理科有兴趣吗？<br>　　有兴趣（请回答问题10）<br>　　没有兴趣（请回答问题22）<br>　　17．请从下列两种颜色中选择你较喜欢的一种：<br>　　橙／橘色（请回答问题12）<br>　　红色（请回答问题24）<br>　　18．你较喜欢山还是海洋呢？<br>　　山（请回答问题13）<br>　　海洋（请回答问题25）<br>　　19．你会妒忌比你出色的人吗？<br>　　会（请回答问题14）<br>　　不会（请回答问题26）<br>　　20．你介意在公众场所大笑或大声谈话吗？<br>　　介意（你属于c型）<br>　　不介意（你属于b型）<br>　　21．你会经常收拾你的房间吗？<br>　　会（请回答问题16）<br>　　不会（请回答问题28）<br>　　22．你喜欢看体育节目吗？<br>　　喜欢（请回答问题23）<br>　　不喜欢（请回答问题29）<br>　　23．你认为纯友谊关系能够在异性朋友在之间存在吗？<br>　　能够（请回答问题17）<br>　　不能够（请回答问题10）<br>　　24．你想学习烹饪吗？<br>　　想（请回答问题18）<br>　　不想（请回答问题31）<br>　　25．你对互联网有兴趣吗？<br>　　有兴趣（请回答问题19）<br>　　没有太大兴趣（请回答问题32）<br>　　26．你较喜欢下列哪一种性格的人呢？<br>　　运动型（请回答问题20）<br>　　成熟型（请回答问题39）<br>　　27．你喜欢穿着及炫耀名牌时装吗？<br>　　喜欢（你属于b型）<br>　　不喜欢（你属于d型）<br>　　28．你较喜欢狗还是猫呢？<br>　　狗（请回答问题22）<br>　　猫（请回答问题34）<br>　　29．你通常会携带香水上街吗？<br>　　会（请回答问题30）<br>　　不会（请回答问题35）<br>　　30．你较喜欢太阳还是月亮？<br>　　月亮（请回答问题23）<br>　　太阳（请回答问题24）<br>　　31．你经常改变你的发型吗？<br>　　是（请回答问题25）<br>　　否（请回答问题27）<br>　　32．服务他人令你觉得很忙碌吗？<br>　　是（请回答问题26）<br>　　否（请回答问题38）<br>　　33．你通常保持整齐的头发吗？<br>　　是（请回答问题27）<br>　　否（你属于c型）<br>　　34．你有烹饪恐惧症吗？<br>　　有（请回答问题29）<br>　　没有（请回答问题35）<br>　　35．你是否拥有很多装饰品呢？<br>　　是（请回答问题36）<br>　　否（请回答问题37）<br>　　36．你喜欢在假期或节日期间购物吗？<br>　　喜欢（请回答问题37）<br>　　不喜欢（请回答问题31）<br>　　37．将来你希望制造雕像吗？<br>　　希望（请回答问题32）<br>　　不希望（请回答问题38）<br>　　38．你十分挑剔你内衣裤的款式吗？<br>　　是（请回答问题40）<br>　　否（请回答问题39）<br>　　39．你对制造手工艺有兴趣吗？<br>　　有兴趣（请回答问题33）<br>　　没兴趣（请回答问题27）<br>　　40．你是否是一个追随时装潮流的人呢？<br>　　是（你属于c型）<br>　　否（你属于d型）</p><hr><p>　　◇测试答案：<br>　　a型：你是一个外向和乐观的人。虽然你也有遭遇挫折失败时候，但开朗的你很快便会振作起来。异性朋友很喜欢你亲切且友善的性格，但也同时会令你的配偶失去安全感。不懂表达感情是你的缺点，但宽容、大量及慷慨是你受欢迎的原因。同性朋友很难了解你，因为你性格天真单纯，但这正是你吸引异性的有利条件。<br>　　b型：<br>　　你关怀照料的性格总是令朋友们觉得你是他们的大哥哥或大姐姐。朋友们都很信任你，他们觉得与你聊天很舒服，并且是一种乐趣。通常一些年纪比你小而且感情脆弱的异性都会受你吸引。<br>　　c型：<br>　　你是一个有依赖性及欠缺主见的人，因此异性朋友总是觉得你是他们的小弟弟或小妹妹。在四个类型之中，你是最适合结婚的一类。你能成功地占据配偶空闲的时间。你总希望你是众人的集中点。楚楚可怜是你给异性的印象，因此朋友们都热心地保护及照顾你。穿着清洁整齐的衣服能令你更加受欢迎。<br>　　d型：<br>　　在四个类型之中，你是最性感的一类。妩媚迷人的你很受朋友们的欢迎，而且更是众人的集中点。可是，朋友们往往只是宠爱你的外貌，所以不要过分信任异性的甜言蜜语。另外，希望你能够多些表现你的智慧及主见，这样你便能成为一个外在及内在美兼备的人。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　1．你认为你是一个有个性、有自己的思想及主见的人吗？&lt;br&gt;　　是（请回答问题2）&lt;br&gt;　　否（请回答问题8）&lt;br&gt;　　2．你比较喜欢星形还是心形的项链呢？&lt;br&gt;　　星形（请回答问题3）&lt;br&gt;　　心形（请回答问题9）&lt;br&gt;　　3．你喜欢玩洋娃娃或机器人吗？&lt;br&gt;　　喜欢（请回答问题11）&lt;br&gt;　　不喜欢（请回答问题4）</summary>
    
    
    
    <category term="读书笔记" scheme="http://yonghong.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="心理学" scheme="http://yonghong.tech/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
    <category term="九型人格" scheme="http://yonghong.tech/tags/%E4%B9%9D%E5%9E%8B%E4%BA%BA%E6%A0%BC/"/>
    
    <category term="读书笔记" scheme="http://yonghong.tech/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>解密九型人格读书笔记（3） | 九型人格测试问卷</title>
    <link href="http://yonghong.tech/2020/10/jiu-xing-ren-ge-003/"/>
    <id>http://yonghong.tech/2020/10/jiu-xing-ren-ge-003/</id>
    <published>2020-10-09T07:00:00.000Z</published>
    <updated>2020-10-09T07:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>看一看哪种类型回答“是”的次数最多呢？如果有两个以上类型答“是”的次数一样多，就要注意对于答“否”的题的拒绝强度，强烈拒绝的较少的类型，很可能就是你的类型。</p><p>　　◎1号型人格完美型<br>　　1．肯努力改正自己的缺点。<br>　　2．如果事物没有按顺序编排，就会感到焦躁。<br>　　3．想避免时间或交际上的浪费。<br>　　4．经常责怪自己或周遭的人，觉得可以做得更好。<br>　　5．即使是小错误或小缺点，也会耿耿于怀。<a id="more"></a><br>　　6．拙于放松，不能轻易地开玩笑或闲聊。<br>　　7．在脑子里以自己的量尺评判他人。<br>　　8．比别人容易忧心、挂虑。<br>　　9．对所有的事情都宁愿坦率、老实一点。<br>　　10．不愿做有违人伦，包括说谎及欺骗的事。<br>　　11．认为事情正确才是最重要的。<br>　　12．虽然该做的事很多，但时间总是不够，常被时间追着跑。<br>　　13．经常仔细核对自己如何分配、使用时间。<br>　　14．行事中规中矩，又很实际，可是很胆怯。<br>　　15．嫉恶如仇，不肯轻易饶恕。<br>　　16．如果事情不公正，就会苦恼、困惑。<br>　　17．上进心强，认为一定要出人头地。<br>　　18．认为在受到他人肯定之前，自己必须先做得完美。<br>　　19．经常被欲求、不满驱使，认为自己或他人都不够完美。<br>　　20．以对错、好坏的标准看待事物。</p><hr><p>　　◎2号型人格助人型<br>　　1．觉得有许多人依赖自己。<br>　　2．认为为他人奉献很重要。<br>　　3．经常想“成为对众人有用的人”。<br>　　4．希望得到众人的好感。<br>　　5。经常说话博取他人欢心。<br>　　6．看到他人受困，或立场痛苦，就想伸出援手。<br>　　7．不论是否喜欢，眼前有谁就照顾谁。<br>　　8．希望每个人都找自己寻求安慰，得到自己的建议。<br>　　9．虽然受人依赖会感到高兴，但被依赖过度也会觉得是负担。<br>　　10．最后才考虑自己的好处。<br>　　11．常觉得为别人尽力，却得不到感谢。<br>　　12．经常有“想待在某人身边”的感觉。<br>　　13．自以为当然会受到感谢却未得到时，就会觉得自己是牺牲者。<br>　　14．强烈觉得“爱人与被爱是人生中最重要的事”。<br>　　15．与他人心意相通时，就会感到喜悦。<br>　　16．认为通过为他人尽力的行为，可以使自己在那个人的人生中占有重要地位。<br>　　17．看到他人因为自己的帮助而成长时，就会很快乐。<br>　　18．经常以自己的空闲时间为他人解困。<br>　　19．因为在意别人对自己的看法，所以更在意别人。<br>　　20．对周围人的反应很敏感。</p><hr><p>　　◎3号型人格成就型<br>　　1．喜欢有所事事。<br>　　2．喜欢与伙伴一起工作，觉得自己要成为好伙伴。<br>　　3．执行工作又正确又专业。<br>　　4．为了完成事情，重视组织化、效率化，不肯有所浪费。<br>　　5．经常认定自己会成功。<br>　　6．明确订定目标，为了获得成果，会锁定自己现在该怎么做。<br>　　7．喜欢以进度表、分数等，来表示自己完成的成绩。<br>　　8．别人很羡慕我完成事情的行动力。<br>　　9．想给他人自己成功的印象。<br>　　10．虽然喜欢自行决定，但会随机应变而改变意见。<br>　　11．为了达到目标，有时会与对手妥协。<br>　　12．对现在所完成的事更有成就感。<br>　　13．最讨厌听到别人说自己做得不理想。<br>　　14．与继续做旧的事相比，倒更喜欢开始新的工作。<br>　　15．被别人夸奖很有说服力。<br>　　16．重视自己的工作、任务，觉得自己很能干。<br>　　17．任何事情都想具体化。<br>　　18．认为面对他人时，印象中有着众多成果是很重要的。<br>　　19．被看成完成事物有自我主张的人。<br>　　20．认为第一印象特别重要。</p><hr><p>　　◎4号型人格自我型<br>　　1．觉得很多人没有体会到人生真正的美丽与意味。<br>　　2．对自己的过去有强烈的哀愁。<br>　　3．经常想保持自己，不想做作，但并不容易。<br>　　4．心灵会被象征性的事物吸引。<br>　　5．觉得别人不像自己一样，对事物有深刻的感觉。<br>　　6．认为别人很难了解自己的感觉。<br>　　7．想时时保持礼貌、品味。<br>　　8．对自己而言，周围的气氛很重要。<br>　　9．认为人生如戏，自己正在舞台上表演。<br>　　10．对自己而言，礼貌与好的兴趣是很重要的。<br>　　11．不愿意承认自己是平凡人。<br>　　12．想到失去、死亡、痛苦时，难免会陷入深思中。<br>　　13．经常觉得难以用一般的方式表现自己的感情。<br>　　14．认为如果太拘泥于自己的感受，在感情膨胀的时候，会不知道自己有什么样的感觉。<br>　　15．对于人际关系的不理想，比他人更感到困惑。<br>　　16．有时会觉得自己是悲剧的主角。<br>　　17．曾被他人指责自以为是。<br>　　18．希望感情有剧烈的起伏，即心情时而高扬，时而低迷，如果没有这样的极端，就觉得缺乏生气。<br>　　19．艺术是自己表现感情时非常重要的手段。<br>　　20．对于别人的批评，可以不予理会。</p><hr><p>　　◎5号型人格理智型<br>　　1．拙于表现自己的感情。<br>　　2．有收集物品的习惯，认为有一一天会派上用场。<br>　　3．对于言不及义的交谈最棘手。<br>　　4．擅长综合观察，或是综合各种意见。<br>　　5．被人问及“现在有什么感受”时，就会无言以对。<br>　　6．在日常生活中，希望有私隐的时间和场所可以放松。<br>　　7．认为与其由自己打头阵，不如委任他人去做。<br>　　8．有在自己直接参与前，先观察他人动作的倾向。<br>　　9．喜欢可以避开他人的独处时间。<br>　　10．认为自己比别人安静。<br>　　11．拙于主动向他人搭讪。<br>　　12．发生问题时，认为由自己解决会更好。<br>　　13．认为拙于自我主张。<br>　　14．喜欢以思考解决问题。<br>　　15．喜欢纵观全体，掌握状况再做判断，如果有所遗漏，就会觉得自己太轻率了，责备自己的疏失。<br>　　16．认为自己对时间及金钱很吝啬。<br>　　17．如果得不到与付出成正比的报酬，就会感到不满。<br>　　18．如果自己引起麻烦，就会认为自己“太蠢了”。<br>　　19．别人有时会认为我说话太小声，而被要求“讲话大声一点”。<br>　　20．从他人处“得到的资讯”比“给人的资讯”多。</p><hr><p>　　◎6号型人格疑惑型<br>　　1．在某种权威者的身边，就会变得神经质。<br>　　2．经常因为疑惑而感到痛苦。<br>　　3．想有明确的指标，能熟知自己的立场。<br>　　4．时时提高警戒，不敢对危险掉以轻心。<br>　　5．事情想得太认真。<br>　　6．经常反问自己是不是做错了事。<br>　　7．经常觉得别人的批评是一种攻击。<br>　　8．经常犹豫不决，很在意自己的配偶或伙伴的想法。<br>　　9．只要有意愿，即使为工作粉身碎骨也在所不惜。<br>　　10．朋友认为我为人老实，愿意帮助、鼓励及体贴他人。<br>　　11．别人常说我有很好的幽默感。<br>　　12．如果不是恪遵规定，就是经常打破规则。<br>　　13．在亲密的关系中，如果站在弱势的一方，就会变得担心、易怒。<br>　　14．做事走极端，不是一拖再拖；就是向前直冲，甚至有冲人危险的倾向。<br>　　15．可以一眼看出那些想以外交辞令来操纵自己的人。<br>　　16．喜欢能预测事情。<br>　　17．认为是自己本身妨碍了自己的成功。<br>　　18．不论对方好坏，都会一直支援他。<br>　　19．觉得要将自己弄得整整齐齐，才能相对地觉得可以控制自己的生活。<br>　　20．不喜欢自大之人或野心分子。</p><hr><p>　　◎7号型人格活跃型<br>　　1．与他人相比之下，比较不会怀疑别人，或探求他人的动机。<br>　　2．喜欢任何快乐的事。<br>　　3．经常抱着事物会朝好的方向展开的心态。<br>　　4．对于别人不能像我一样有开朗的心情而感到遗憾。<br>　　5．不太关心别人的想法，经常觉得自己是幸福的。<br>　　6．经常看事物的光明面，不愿看人生的黑暗面。<br>　　7．对于接触的人不太怀有敌意。<br>　　8．喜欢说笑或开朗的谈话，不喜欢黯淡的言论。<br>　　9．自认为童心未泯，是个开朗的人。<br>　　10．在派对时喜欢引人注意。<br>　　11．‘见树不见林”真是困扰，认为事物应该以更宽广的视野掌握才对。<br>　　12．强烈认为“好”还要“更好”。<br>　　13．认为伤心事应该早早忘记。<br>　　14．宁愿对黑暗的现实视而不见，愿意对任何事说“棒极了”。<br>　　15．与其辛苦过着“有韵味的人生”，不如过着“充满快乐的人生”。<br>　　16．对于未来从不失去热情。<br>　　17．喜欢每个人都很开朗。<br>　　18．即使勉强一点，也要尽量避免“讨厌”的事。<br>　　19．比起专心于一件事，更容易不断转移关心的目标。<br>　　20．能回想起自己童年时代的幸福。</p><hr><p>　　◎8号型人格领袖型<br>　　1．愿意为了自己的需要而作战，会断然固守必要的事物。<br>　　2．可以立刻找出他人的弱点，对手一旦挑战，就立即攻击这个弱点。<br>　　3．经常对于事物表现不满。<br>　　4．不怕与他人对立，事实上也经常对立。<br>　　5．觉得行使权力很痛快。<br>　　6．一眼就可以看出是谁在一个群体中握有权力。<br>　　7．自认为是富有攻击性，自我主张强的人。<br>　　8．知道事情该怎么做。<br>　　9．既不能容忍，也不愿意表现出自己高尚、温柔的“女性的一面”。<br>　　10．不屑退缩，而喜欢到处活动。<br>　　11．对自己而言，贯彻仁义、道理是很重要的问题。<br>　　12．凡是在自己的权威之下的人，都会保护他们。<br>　　13．自认为是“朴实”的人。<br>　　14．一般而言，不太关心自我反省、自我分析。<br>　　15．认为自己是不会顺从他人的人。<br>　　16．讨厌别人多管闲事。<br>　　17．讨厌别人指责、纠正自己。<br>　　18．自认为工作很努力。<br>　　19．不会放任事物不管，必定会加以纠正。<br>　　20．认为别人的麻烦都是自找的。</p><hr><p>　　◎9号型人格平和型<br>　　1．我觉得许多人都太在意事物了。<br>　　2．认为人生处处是青山，很少会遇到狼狈的现象。<br>　　3．大多数时候，都很平稳平静。<br>　　4．最喜欢无所事事。<br>　　5．认为自己是极为乐天派的人。<br>　　6．想不出上一次的失眠是何时。<br>　　7．认为几乎所有的人都有或多或少的不同，但大致上是相同的。<br>　　8．对于事物通常不会太兴奋。<br>　　9．从不会觉得亟不可待，从未有不能等到明天的心情。<br>　　10．开始做事时，需要外来的刺激。<br>　　11．对于任何事都讨厌浪费气力，做事时会考虑节约力气。<br>　　12．心态一向是“不要拿芝麻小事来烦我”。<br>　　13．认为自己是不会感情用事的冷静裁断者，对任何一方都一视同仁。<br>　　14．最讨厌半途而废，定不下心来。<br>　　15．通常会选择抵抗的途径。<br>　　16．认为自己是个稳重的人。<br>　　17．为了使人人平和，而配合对方的行动。<br>　　18．不认为自己是多么重要的人。<br>　　19．拙于听人说话，或注意他人。<br>　　20．赞成“船到桥头自然直，忍一时风平浪静，退一步海阔天空”的想法。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;看一看哪种类型回答“是”的次数最多呢？如果有两个以上类型答“是”的次数一样多，就要注意对于答“否”的题的拒绝强度，强烈拒绝的较少的类型，很可能就是你的类型。&lt;/p&gt;
&lt;p&gt;　　◎1号型人格完美型&lt;br&gt;　　1．肯努力改正自己的缺点。&lt;br&gt;　　2．如果事物没有按顺序编排，就会感到焦躁。&lt;br&gt;　　3．想避免时间或交际上的浪费。&lt;br&gt;　　4．经常责怪自己或周遭的人，觉得可以做得更好。&lt;br&gt;　　5．即使是小错误或小缺点，也会耿耿于怀。</summary>
    
    
    
    <category term="读书笔记" scheme="http://yonghong.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="心理学" scheme="http://yonghong.tech/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
    <category term="九型人格" scheme="http://yonghong.tech/tags/%E4%B9%9D%E5%9E%8B%E4%BA%BA%E6%A0%BC/"/>
    
    <category term="读书笔记" scheme="http://yonghong.tech/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>解密九型人格读书笔记（2） | 根据描述测试九型人格</title>
    <link href="http://yonghong.tech/2020/10/jiu-xing-ren-ge-002/"/>
    <id>http://yonghong.tech/2020/10/jiu-xing-ren-ge-002/</id>
    <published>2020-10-09T03:00:00.000Z</published>
    <updated>2020-10-09T03:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>请阅读以下九段文字，根据描述，看看哪一段文字最能形容你。</p><p>　　1．我对事物的态度是宁为玉碎，不为瓦全；尤其是对我认为重要的事情更是如此。<br>　　我非常重视坚强、诚实、独立这些特质。我认为只有在东西出现眼前时，才算是真正拥有。在证明别人值得信赖之前，我不会轻易相信任何人。我喜欢别人用直接的态度对待我。我可以看出别人的不坦诚、说谎，或是想要对我不利的企图。我难以忍受别人的缺点，除非我可以了解这些缺点的产生的原因，或是我知道他们尝试改进，我才会改变自己的想法。如果我不尊重或不同意某个掌握权力的人，我就很难接受他的命令或指示。我很能照顾自己。当我生气的时候很难掩盖自己的情绪。我总是维护自己深爱的人或朋友，尤其是当他们受到不公平的对待时，我就会挺身而出。我不一定会参与每场竞争，不过我会证明自己有足以与他人匹敌的能力。<a id="more"></a><br>　　2．我用高标准的眼光看待事物，而且我希望自己可以达到这些标准。<br>　　我很容易看出错误的所在，也知道如何改正。人们会认为我是吹毛求疵或是要求完美，其实，这只是因为我无法忍受事情没有依照正确的方式完成。当我可以负责某些事情时，我会感到自豪，而且我保证可以做得非常好。当别人没有努力把事情做好，或是做出不负责任、不公平的举动时，我会感到生气，但我会努力不表现出生气的样子。我认为人生应该先苦后乐，为了工作我可以牺牲个人需要。<br>　　3．我可以轻易地觉察不同的观点。<br>　　有时候我很难做出决定，因为我总是可以看出事情的正反两面以及优缺点。觉察不同观点的能力让我可以帮助抱持不同意见的人消除歧见。我比较可以了解他人的处境、诉求和个人需要，更甚于了解自己的需要。有时候在进行重要的事情时，我会被琐碎的小事吸引而分心。我很难决定什么是最重要的事，经常为了避免冲突而顺从别人的需要。旁人觉得我很好相处，容易取悦，很容易同意别人的看法。我很难直接表现出对某人的愤怒。我希望生活是很舒服、和谐的，也希望被别人接纳。<br>　　4．我很能体会别人的感受，即使是不认识的人，我也可以看出他们的需要。<br>　　有时候，我会觉得可以了解别人的需要是一件痛苦的事，特别是当他们痛苦或不开心的时候。我很容易奉献自己，有时我希望我可以说“不”，因为我往往会为别人做得太多，为自己做得太少。如果别人觉得我想要设计或是控制他们，我会觉得很难过，因为我只不过是想要了解和帮助他们。当别人不重视我或不体谅我的时候，我会变得情绪化和过于苛求。我觉得良好的人际关系很重要，我也愿意尽一切的努力和别人维持和谐的关系。<br>　　5．不论是什么事情，我都要做到最好，这便是我做事时的强烈动机。<br>　　我已经因为我的成就得到了许多的赞美和肯定，我完成了许多成就，而且我做什么总是能够成功的。我非常认同自己做的事，我认为一个人的价值在于他达到的成就，还有这些成就赢得的赞赏。为了把事情做好，我必须花费大部分的时间，因此我会把自己的感觉和需要放在次要的位置上，以把事情做好。因为我总是可以找到事情做，所以安静地坐着对我来说很困难。如果别人浪费我的时间，我会很不耐烦。如果有人做事的速度太慢，我会很希望把他的工作接过来做。我希望在任何领域都保持领先。虽然我爱竞争，但我在团体中也会做个合作的队员。<br>　　6．我是一个安静、好分析的人。我比其他人需要多一点的独处时间。<br>　　我比较喜欢在一旁观察，胜过于参与身边的活动。我不喜欢别人对我要求太多，或希望我表达我的感受。我在独处的时候比较可以了解自己的感受。我比较喜欢回味过去的经验，胜过于实际去经历。我在独处时不会觉得无聊，因为我有丰富的精神生活。我认为我应该把时间和精力保留在单纯、简单、尽量不贫乏的生活上。<br>　　7．我有丰富的想象力，而且常常忍不住会联想到可能危及安全的事，结果让自己担忧不已。<br>　　我通常都可以看出危险所在，并且感到非常害怕，好像这些危险真的会发生一样。我在处理危险时有两极化的表现：要不就是避免所有可能的危险，要不就是勇往直前地挑战这些危险。丰富的想象力让我头脑灵活，拥有风格独特的幽默感。我希望生活可以十分稳定，但是我经常会怀疑周遭的人、事、物。我经常可以看出别人在观念上的缺点，有些人会觉得我很狡猾。我倾向于质疑权威，也不太习惯处在权威的地位。我可以看出问题的所在，所以能够理解失败者的感受；一旦我决定要效忠于某个人或理想，我便会非常忠诚。<br>　　8．我是一个乐观的人，喜欢参与新奇有趣的活动。<br>　　我的思考很活跃，经常有不同的想法，喜欢让不同的观念产生关联；当我可以让本来没有关系的概念产生关联时，我会觉得非常兴奋。我喜欢把大部分的精力投注在感兴趣的事物上，不喜欢没有回报或反复做同一件事。我喜欢参与计划的起步阶段，因为在计划的过程当中，可以考虑很多有趣的选择。如果对正在进行的事情失去兴趣，我就会转移目标，改做其他比较有趣的事。如果某件事情进行得不顺利，我会将注意力转移到其他有趣的事情上。我认为人应该享受人生。<br>　　9．我是一个感情强烈又敏感的人。<br>　　我觉得自己和其他人不一样，所以常常会觉得不被了解，而感觉孤单。别人可能会觉得我的表现过于戏剧化，也曾经有人批评我太过敏感，过度放大自己的感觉。其实我想要的是紧密的感情联系和深入的人际关系。我对于目前的人际关系感到不满，因为我总是想得到自己无法拥有的东西，却厌恶自己拥有的东西。我时常因为缺少感情联系而感到忧郁沮丧。有时候我怀疑别人拥有的东西比我多，我觉得别人的人际关系比较好，他们的生活也比我快乐。我有敏锐的审美观。我的生活充满丰富的情感与深度的内涵。</p><hr><p>　　◇测试答案<br>　　1．8号型人格领袖型。<br>　　2．1号型人格完美型。<br>　　3．9号型人格平和型。<br>　　4．2号型人格助人型。<br>　　5．3号型人格成就型。<br>　　6．5号型人格理智型。<br>　　7．6号型人格疑惑型。<br>　　8．7号型人格活跃型。<br>　　9．4号型人格自我型。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;请阅读以下九段文字，根据描述，看看哪一段文字最能形容你。&lt;/p&gt;
&lt;p&gt;　　1．我对事物的态度是宁为玉碎，不为瓦全；尤其是对我认为重要的事情更是如此。&lt;br&gt;　　我非常重视坚强、诚实、独立这些特质。我认为只有在东西出现眼前时，才算是真正拥有。在证明别人值得信赖之前，我不会轻易相信任何人。我喜欢别人用直接的态度对待我。我可以看出别人的不坦诚、说谎，或是想要对我不利的企图。我难以忍受别人的缺点，除非我可以了解这些缺点的产生的原因，或是我知道他们尝试改进，我才会改变自己的想法。如果我不尊重或不同意某个掌握权力的人，我就很难接受他的命令或指示。我很能照顾自己。当我生气的时候很难掩盖自己的情绪。我总是维护自己深爱的人或朋友，尤其是当他们受到不公平的对待时，我就会挺身而出。我不一定会参与每场竞争，不过我会证明自己有足以与他人匹敌的能力。</summary>
    
    
    
    <category term="读书笔记" scheme="http://yonghong.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="心理学" scheme="http://yonghong.tech/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
    <category term="九型人格" scheme="http://yonghong.tech/tags/%E4%B9%9D%E5%9E%8B%E4%BA%BA%E6%A0%BC/"/>
    
    <category term="读书笔记" scheme="http://yonghong.tech/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>解密九型人格读书笔记（1） | 九型人格简易测试表</title>
    <link href="http://yonghong.tech/2020/10/jiu-xing-ren-ge-001/"/>
    <id>http://yonghong.tech/2020/10/jiu-xing-ren-ge-001/</id>
    <published>2020-10-08T12:00:00.000Z</published>
    <updated>2020-10-08T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个测量表能帮助你在很短的时间内，初步判断你属于九型人格中的哪个类型。这里共有108个性格描述，纪录下你认为符合你的性格描述的题号，并参考最底部的题号分类，统计出你拥有的哪个性格类型的描述最多。统计的结果只是一个参考的结论，更准确的判断还需要对九型人格进行深入了解和揣摩分析后才能获得。<br>　　1．我很容易迷惑。<br>　　2．我不想成为一个喜欢批评的人，但很难做到。<br>　　3．我喜欢研究宇宙的道理、哲理。<br>　　4．我很注意自己是否年轻，因为那是我找乐子的本钱。<br>　　5．我喜欢独立自主，一切都靠自己。<a id="more"></a><br>　　6．当我有困难的时候，我会试着不让人知道。<br>　　7．被人误解对我而言是一件十分痛苦的事。<br>　　8．施舍比接受会给我更大的满足感。<br>　　9．我常常试探考验朋友或伴侣的忠诚。<br>　　10．我常常设想最糟糕的结果而使自己陷入苦恼中。<br>　　11．我看不起那些不像我一样坚强的人，有时我会用种种方式羞辱他们。<br>　　12．身体上的舒适对我非常重要。<br>　　13．我能触碰生活中的悲伤和不幸。<br>　　14．别人不能完成他的分内事，会令我感到失望和愤怒。<br>　　15．我时常拖延问题，不去解决。<br>　　16．我喜欢有戏剧性、多彩多姿的生活。<br>　　17．我认为自己非常不完善。<br>　　18．我对感官的需求特别强烈，喜欢美食、服装、身体的触觉刺激，并纵情享乐。<br>　　19．当别人请教我一些问题，我会事无巨细地分析得很清楚。<br>　　20．我习惯推销自己，从不觉得难为情。<br>　　21．有时我会放纵自己，做出不理智的事情。<br>　　22．帮助不到别人会让我觉得痛苦。<br>　　23．我不喜欢人家问我广泛、笼统的问题。<br>　　24．在某方面我有放纵的倾向（例如食物、药物等）。<br>　　25．我宁愿适应别人，包括我的伴侣，而不会反抗他们。<br>　　26．我最不喜欢的一件事就是虚伪。<br>　　27．我知错能改，但由于执著好强，周围的人还是感觉到有压力。<br>　　28．我常觉得很多事情都很好玩，很有趣，人生真是快乐。<br>　　29．我有时很欣赏自己充满权威，有时却又优柔寡断，依赖别人。<br>　　30．我习惯付出多于接受。<br>　　31．面对威胁时，我一是变得焦虑，一是对抗迎面而来的危险。<br>　　32．我通常是等别人来接近我，而不是我去接近他们。<br>　　33．我喜欢当主角，希望得到大家的注意。<br>　　34．别人批评我，我也不会回应和解释，因为我不想发生任何争执与冲突。<br>　　35．我有时期待别人的指导，有时却忽略别人的忠告，径直去做我想做的事。<br>　　36．我经常忘记自己的需要。<br>　　37．在重大危机中，我通常能克服我对自己的质疑和内心的焦虑。<br>　　38．我是一个天生的推销员，说服别人对我来说是一件容易的事。<br>　　39．我不相信一个我一直都无法了解的人。<br>　　40．我爱依惯例行事，不大喜欢改变。<br>　　41．我很在乎家人，在家中表现得忠诚和包容。<br>　　42．我被动而优柔寡断。<br>　　43．我很有包容力，彬彬有礼，但跟人的感情互动不深。<br>　　44．我沉默寡言，好像不会关心别人似的。<br>　　45．当沉浸在工作中或我擅长的领域时，别人会觉得我冷酷无情。<br>　　46．我常常保持警觉。<br>　　47．我不喜欢要对人尽义务的感觉。<br>　　48．如果不能完美地表态，我宁愿不说。<br>　　49．我的计划比我实际完成的还要多。<br>　　50．我野心勃勃，喜欢挑战和登上高峰的滋味。<br>　　51．我倾向于独断专行并自己解决问题。<br>　　52．我很多时候感到被遗弃。<br>　　53．我常常表现得十分忧郁的样子，充满痛苦而且内向。<br>　　54．初见陌生人时，我会表现得很冷漠、高傲。<br>　　55．我的面部表情严肃而生硬。<br>　　56．我很飘忽，常常不知自己下一刻想要什么。<br>　　57．我常对自己挑剔，期望不断改正自己的缺点，以成为一个完美的人。<br>　　58．我非常敏感，并经常怀疑那些总是很快乐的人。<br>　　59．我做事有效率，会找捷径，模仿力特强。<br>　　60．我讲理，注重实用。<br>　　61．我有很强的创造天分和想象力，喜欢将事情重新整合。<br>　　62．我不要求得到很多的注意力。<br>　　63．我喜欢每件事情都井然有序，但别人会以为我过分执著。<br>　　64．我渴望有完美的心灵伴侣。<br>　　65．我常夸耀自己，对自己的能力十分有信心。<br>　　66．如果周遭的人行为太过分，我准会让他难堪。<br>　　67．我外向，精力充沛，喜欢不断追求成就，这使我的自我感觉十分良好。<br>　　68．我是一位忠实的朋友和伙伴。<br>　　69．我知道如何让别人喜欢我。<br>　　70．我很少看到别人的功劳和好处。<br>　　71．我很容易看到别人的功劳和好处。<br>　　72．我嫉妒心强，喜欢跟别人比较。<br>　　73．我对别人做的事总是不放心，批评一番后，自己会动手再做。<br>　　74．别人会说我常带着面具做人。<br>　　75．有时我会激怒对方，引来莫名其妙的吵架，其实我是想试探对方爱不爱我。<br>　　76．我会极力保护我所爱的人。<br>　　77．我常常刻意保持兴奋的情绪。<br>　　78．我只喜欢与有趣的人为友，对一些闷蛋却懒得交往，即使他们看起来很有深度。<br>　　79．我常往外跑，四处帮助别人。<br>　　80．我有时会讲求效率而牺牲完美和原则。<br>　　81．我似乎不太懂得幽默，没有弹性。<br>　　82．我待人热情而有耐性。<br>　　83．在人群中我时常感到害羞和不安。<br>　　84．我喜欢效率，讨厌拖泥带水。<br>　　85．帮助别人达致快乐和成功是我最重要的成就。<br>　　86．付出时，别人若不欣然接受，我便会有挫折感。<br>　　87．我的肢体硬邦邦的，不习惯别人热情的付出。<br>　　88．我对大部分的社交集会不太有兴趣，除非那是我熟识的和喜爱的人。<br>　　89．很多时候我会有强烈的寂寞感。<br>　　90．人们很乐意向我表白他们所遭遇的问题。<br>　　91．我不但不会说甜言蜜语，而且别人会觉得我唠叨不停。<br>　　92．我常担心自由被剥夺，因此不爱讲承诺。<br>　　93．我喜欢告诉别人我所做的事和所知的一切。<br>　　94．我很容易认同别人为我所做的事和所知的一切。<br>　　95．我要求光明正大，为此不惜与人发生冲突。<br>　　96．我很有正义感，有时会支持不利的一方。<br>　　97．我注重小节而效率不高。<br>　　98．我容易感到沮丧和麻木更多于愤怒。<br>　　99．我不喜欢那些侵略性或过度情绪化的人。<br>　　100．我非常情绪化，一天的喜怒哀乐多变。<br>　　101．我不想别人知道我的感受与想法，除非我告诉他们。<br>　　102．我喜欢刺激和紧张的关系，而不是确定和依赖的关系。<br>　　103．我很少用心去听别人的心情，只喜欢说说俏皮话和笑话。<br>　　104．我是循规蹈矩的人，秩序对我十分有意义。<br>　　105．我很难找到一种我真正感到被爱的关系。<br>　　106．假如我想要结束一段关系，我不是直接告诉对方就是激怒他来让他离开我。<br>　　107．我温和平静，不自夸，不爱与人竞争。<br>　　108．我有时善良可爱，有时又粗野暴躁，很难捉摸。</p><hr><p>　　◇测试答案<br>　　1号型人格完美型：2，14，55，57，60，63，73，81，87，91，97，102，104，106。<br>　　2号型人格助人型：6，8，22，30，69，71，79，82，85，86，89，90。<br>　　3号型人格成就型：20，33，38，59，65，67，70，72，74，77，80，93。<br>　　4号型人格自我型：7，13，17，52，53，54，56，58，61，64，100，105。<br>　　5号型人格理智型：3，19，23，32，42，43，47，48，51，83，88，99，101。<br>　　6号型人格疑惑型：9，10，26，29，31，35，37，45，46，68，75。<br>　　7号型人格活跃型：4，16，18，21，28，49，78，92，103。<br>　　8号型人格领袖型：5，11，24，27，40，44，50，66，76，84，95，96。<br>　　9号型人格平和型：1，12，15，25，34，36，39，41，62，94，98，107，108。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个测量表能帮助你在很短的时间内，初步判断你属于九型人格中的哪个类型。这里共有108个性格描述，纪录下你认为符合你的性格描述的题号，并参考最底部的题号分类，统计出你拥有的哪个性格类型的描述最多。统计的结果只是一个参考的结论，更准确的判断还需要对九型人格进行深入了解和揣摩分析后才能获得。&lt;br&gt;　　1．我很容易迷惑。&lt;br&gt;　　2．我不想成为一个喜欢批评的人，但很难做到。&lt;br&gt;　　3．我喜欢研究宇宙的道理、哲理。&lt;br&gt;　　4．我很注意自己是否年轻，因为那是我找乐子的本钱。&lt;br&gt;　　5．我喜欢独立自主，一切都靠自己。</summary>
    
    
    
    <category term="读书笔记" scheme="http://yonghong.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="心理学" scheme="http://yonghong.tech/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
    <category term="九型人格" scheme="http://yonghong.tech/tags/%E4%B9%9D%E5%9E%8B%E4%BA%BA%E6%A0%BC/"/>
    
    <category term="读书笔记" scheme="http://yonghong.tech/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>技术爱好者周刊 第1期 | 2020年10月5日</title>
    <link href="http://yonghong.tech/weekly-001/"/>
    <id>http://yonghong.tech/weekly-001/</id>
    <published>2020-10-05T02:24:00.000Z</published>
    <updated>2020-10-05T02:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>技术爱好者周刊，每周一发布，欢迎提<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dhbmd5b25naG9uZy95b25naG9uZy1tZS9pc3N1ZXM=">issue<i class="fa fa-external-link-alt"></i></span>贡献内容。</p></blockquote><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1YW55Zi93ZWVrbHkvYmxvYi9tYXN0ZXIvZG9jcy9pc3N1ZS0xMjcubWQ=">科技爱好者周刊（第 127 期）：未来人人开发软件，几乎没人编码<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BvbGFyaXMxMTE5L2dvbGFuZ3dlZWtseS9ibG9iL21hc3Rlci9kb2NzL2lzc3VlLTA2My5tZA==">Go语言爱好者周刊：第 63 期<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3plbmFueS93ZWVrbHkvYmxvYi9tYXN0ZXIvc29mdHdhcmUvMjAyMC8wOTI4Lm1k">zenany/weekly - 2020.09.28 - 低代码，要怎么低？和低代码有关的 10 个问题<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N3aWZ0T2xkRHJpdmVyL2lPUy1XZWVrbHkvYmxvYi9tYXN0ZXIvUmVwb3J0cy8yMDIwLyUyMzEzMC0yMDIwLjA5LjI4Lm1k">老司机 iOS 周报 #130 | 2020-09-28<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9yd2Vla2x5Lm9yZy8yMDIwLTM5Lmh0bWw=">R Weekly 2020-39 shinydashboardPlus, Calendar<i class="fa fa-external-link-alt"></i></span></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;技术爱好者周刊，每周一发布，欢迎提&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL3dhbmd5b25naG9uZy95b25naG9uZy1tZS9pc3N1ZXM=&quot;&gt;issue&lt;</summary>
      
    
    
    
    <category term="技术爱好者周刊" scheme="http://yonghong.tech/categories/%E6%8A%80%E6%9C%AF%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A/"/>
    
    
    <category term="技术爱好者周刊" scheme="http://yonghong.tech/tags/%E6%8A%80%E6%9C%AF%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>毕昇 JDK 11 开源了！</title>
    <link href="http://yonghong.tech/release/bishengjdk-11/"/>
    <id>http://yonghong.tech/release/bishengjdk-11/</id>
    <published>2020-10-04T13:10:00.000Z</published>
    <updated>2020-10-04T13:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>毕昇JDK是华为内部OpenJDK定制版Huawei JDK的开源版本，是一个高性能、多平台支持、可用于生产环境的OpenJDK发行版。Huawei JDK运行在华为内部500多个产品上，积累了大量使用场景和java开发者反馈的问题和诉求，解决了业务实际运行中遇到的多个问题，并在ARM架构上进行了性能优化，毕昇JDK运行在大数据等场景下可以获得更好的性能。毕昇JDK 11目前仅支持Linux/AArch64平台。毕昇JDK同时是OpenJDK的下游，现在和未来也会持续稳定为OpenJDK社区做出贡献。</p><p>二进制可以从<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9rdW5wZW5nL2FyY2hpdmUvY29tcGlsZXIvYmlzaGVuZ19qZGsv">这里<i class="fa fa-external-link-alt"></i></span>下载。</p><a id="more"></a><h2 id="平台支持"><a href="#平台支持" class="headerlink" title="平台支持"></a>平台支持</h2><p>毕昇JDK 当前支持 <code>Linux/AArch64</code> 平台。</p><h2 id="支持特性"><a href="#支持特性" class="headerlink" title="支持特性"></a>支持特性</h2><p><strong>毕昇JDK 11在ARM上支持了实验特性的ZGC</strong>，用户可以通过以下选项打开ZGC</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">java</span> <span class="selector-tag">-XX</span><span class="selector-pseudo">:+UnlockExperimentalVMOptions</span> <span class="selector-tag">-XX</span><span class="selector-pseudo">:+UseZGC</span></span><br></pre></td></tr></table></figure><p>详细介绍请见<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vb3BlbmV1bGVyL2Jpc2hlbmdqZGstMTEvd2lraXMvWkdDJTIwR2V0dGluZyUyMFN0YXJ0ZWQ/c29ydF9pZD0yODc5MTY4">毕昇JDK ZGC介绍<i class="fa fa-external-link-alt"></i></span>。</p><p><a href="https://gitee.com/openeuler/bishengjdk-11/wikis/FastSerializer?sort_id=2879166"><strong>快速序列化</strong></a> 对于一些需要使用Java原生序列化接口而无法使用第三方序列化框架的场景，我们对Java序列化做了一些优化，用户可以使用如下命令打开：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="attr">XX:</span>+UnlockExperimentalVMOptions -<span class="attr">XX:</span>+UseFastSerializer -DfastSerializerEscapeMode=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>该参数不能兼容所有序列化场景，对于<code>序列化对象在读写两端不一致</code>或者<code>classmeta信息在运行时发生改变</code>等场景，fastSerializer会无法支持，这时需要保证打开了<code>-DfastSerializerEscapeMode=true</code>选项保证可以回退到原生的序列化模式。</p><h2 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a>安装指南</h2><p>您可以使用tar压缩包格式或者yum源方式来安装JDK（Java Development Kit）或者JRE（Java Runtime Environment）。</p><p>JDK是JRE的超集，包含了JRE的所有内容，并包含javac/jdb等开发者必须的编译器和调试器。JRE仅提供运行时库、Java虚拟机和其他一些运行java应用程序所必须的组件。请注意JRE不只包含Java SE规范的内容，也包含一些规范之外java应用程序常用的内容。</p><p>用户可以通过以下两种方式来安装：</p><ul><li>tar压缩包格式（.tar.gz）：通过这种方式您可以将JDK安装到系统的任意位置，且不会和系统中其他JDK产生影响。但是这种方式会需要用户进行一些手动设置。详情请见下表。</li><li>从yum源安装（.rpm）：通过这种方式您可以将JDK安装到系统的某个固定路径中，并为所有用户提供，这种安装方式需要root权限。详情请见下表。</li></ul><table><thead><tr><th>下载文件</th><th>操作指南</th><th>支持架构</th><th>安装所需权限</th><th>Sha256</th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9rdW5wZW5nL2FyY2hpdmUvY29tcGlsZXIvYmlzaGVuZ19qZGsvYmlzaGVuZy1qZGstMTEuMC44LWxpbnV4LWFhcmNoNjQudGFyLmd6">bisheng-jdk-11.0.8-linux-aarch64.tar.gz<i class="fa fa-external-link-alt"></i></span></td><td><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vb3BlbmV1bGVyL2Jpc2hlbmdqZGstMTEvd2lraXMvJUU2JUFGJTk1JUU2JTk4JTg3SkRLJTIwMTElMjAlRTUlQUUlODklRTglQTMlODUlRTYlOEMlODclRTUlOEQlOTc/c29ydF9pZD0yODkxMTYwIzI=">在 Linux/AArch64 平台上安装JDK 11<i class="fa fa-external-link-alt"></i></span></td><td>Linux/AArch64</td><td>Anyone</td><td><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9rdW5wZW5nL2FyY2hpdmUvY29tcGlsZXIvYmlzaGVuZ19qZGsvYmlzaGVuZy1qZGstMTEuMC44LWxpbnV4LWFhcmNoNjQudGFyLmd6LnNoYTI1Ng==">sha256<i class="fa fa-external-link-alt"></i></span></td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9rdW5wZW5nL2FyY2hpdmUvY29tcGlsZXIvYmlzaGVuZ19qZGsvYmlzaGVuZy1qcmUtMTEuMC44LWxpbnV4LWFhcmNoNjQudGFyLmd6">bisheng-jre-11.0.8-linux-aarch64.tar.gz<i class="fa fa-external-link-alt"></i></span></td><td><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vb3BlbmV1bGVyL2Jpc2hlbmdqZGstMTEvd2lraXMvJUU2JUFGJTk1JUU2JTk4JTg3SkRLJTIwMTElMjAlRTUlQUUlODklRTglQTMlODUlRTYlOEMlODclRTUlOEQlOTc/c29ydF9pZD0yODkxMTYwIzE=">在 Linux/AArch64 平台上安装JRE 11<i class="fa fa-external-link-alt"></i></span></td><td>Linux/AArch64</td><td>Anyone</td><td><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9rdW5wZW5nL2FyY2hpdmUvY29tcGlsZXIvYmlzaGVuZ19qZGsvYmlzaGVuZy1qcmUtMTEuMC44LWxpbnV4LWFhcmNoNjQudGFyLmd6LnNoYTI1Ng==">sha256<i class="fa fa-external-link-alt"></i></span></td></tr><tr><td>从yum源安装</td><td>即将到来</td><td>*</td><td>Root权限</td><td>*</td></tr></tbody></table><h3 id="在-Linux-AArch64-平台上安装JDK-11"><a href="#在-Linux-AArch64-平台上安装JDK-11" class="headerlink" title="在 Linux/AArch64 平台上安装JDK 11"></a>在 Linux/AArch64 平台上安装JDK 11</h3><ul><li><p>下载压缩包 <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9rdXBlbmcvYXJjaGl2ZS9jb21waWxlci9iaXNoZW5nX2pkay9iaXNoZW5nLWpkay0xMS4wLjgtbGludXgtYWFyY2g2NC50YXIuZ3o=">bisheng-jdk-11.0.8-linux-aarch64.tar.gz<i class="fa fa-external-link-alt"></i></span>.</p></li><li><p>进入到你想要将JDK安装的目录中，并将 .tar.gz 压缩包拷贝到当前目录。</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/path/</span>to/jdk</span><br></pre></td></tr></table></figure><ul><li>将 .tar.gz 压缩包解压缩：</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar zxvf bisheng-jdk<span class="number">-11.0</span><span class="number">.8</span>-linux-aarch64.tar.gz</span><br></pre></td></tr></table></figure><p>JDK的安装目录为 jdk-11.0.8。</p><ul><li>如果您想节省磁盘空间，您可以删除 .tar.gz 压缩包。</li></ul><h3 id="在-Linux-AArch64-平台上安装JRE-11"><a href="#在-Linux-AArch64-平台上安装JRE-11" class="headerlink" title="在 Linux/AArch64 平台上安装JRE 11"></a>在 Linux/AArch64 平台上安装JRE 11</h3><ul><li><p>下载压缩包 <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9rdXBlbmcvYXJjaGl2ZS9jb21waWxlci9iaXNoZW5nX2pkay9iaXNoZW5nLWpyZS0xMS4wLjgtbGludXgtYWFyY2g2NC50YXIuZ3o=">bisheng-jre-11.0.8-linux-aarch64.tar.gz<i class="fa fa-external-link-alt"></i></span>.</p></li><li><p>进入到你想要将JRE安装的目录中，并将 .tar.gz 压缩包拷贝到当前目录。</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/path/</span>to/jre</span><br></pre></td></tr></table></figure><ul><li>将 .tar.gz 压缩包解压缩：</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar zxvf bisheng-jre<span class="number">-11.0</span><span class="number">.8</span>-linux-aarch64.tar.gz</span><br></pre></td></tr></table></figure><p>JRE的安装目录为 jre-11.0.8。</p><ul><li>如果您想节省磁盘空间，您可以删除 .tar.gz 压缩包。</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vb3BlbmV1bGVyL2Jpc2hlbmdqZGstMTE=">openeuler/bishengjdk-11<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;毕昇JDK是华为内部OpenJDK定制版Huawei JDK的开源版本，是一个高性能、多平台支持、可用于生产环境的OpenJDK发行版。Huawei JDK运行在华为内部500多个产品上，积累了大量使用场景和java开发者反馈的问题和诉求，解决了业务实际运行中遇到的多个问题，并在ARM架构上进行了性能优化，毕昇JDK运行在大数据等场景下可以获得更好的性能。毕昇JDK 11目前仅支持Linux/AArch64平台。毕昇JDK同时是OpenJDK的下游，现在和未来也会持续稳定为OpenJDK社区做出贡献。&lt;/p&gt;
&lt;p&gt;二进制可以从&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9rdW5wZW5nL2FyY2hpdmUvY29tcGlsZXIvYmlzaGVuZ19qZGsv&quot;&gt;这里&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;下载。&lt;/p&gt;</summary>
    
    
    
    <category term="release" scheme="http://yonghong.tech/categories/release/"/>
    
    
    <category term="JDK" scheme="http://yonghong.tech/tags/JDK/"/>
    
    <category term="Java" scheme="http://yonghong.tech/tags/Java/"/>
    
    <category term="release" scheme="http://yonghong.tech/tags/release/"/>
    
    <category term="毕昇" scheme="http://yonghong.tech/tags/%E6%AF%95%E6%98%87/"/>
    
    <category term="bisheng" scheme="http://yonghong.tech/tags/bisheng/"/>
    
    <category term="bishengjdk" scheme="http://yonghong.tech/tags/bishengjdk/"/>
    
  </entry>
  
  <entry>
    <title>毕昇 JDK 8 开源了！</title>
    <link href="http://yonghong.tech/release/bishengjdk-8/"/>
    <id>http://yonghong.tech/release/bishengjdk-8/</id>
    <published>2020-10-04T13:00:00.000Z</published>
    <updated>2020-10-04T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>毕昇JDK是华为内部OpenJDK定制版Huawei JDK的开源版本，是一个高性能、可用于生产环境的OpenJDK发行版。Huawei JDK运行在华为内部500多个产品上，积累了大量使用场景和java开发者反馈的问题和诉求，解决了业务实际运行中遇到的多个问题，并在ARM架构上进行了性能优化，毕昇JDK运行在大数据等场景下可以获得更好的性能。毕昇JDK 8与Java SE标准兼容，目前仅支持Linux/AArch64平台。毕昇JDK同时是OpenJDK的下游，现在和未来也会持续稳定为OpenJDK社区做出贡献。</p><p>二进制可以从<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9rdW5wZW5nL2FyY2hpdmUvY29tcGlsZXIvYmlzaGVuZ19qZGsv">这里<i class="fa fa-external-link-alt"></i></span>下载。</p><a id="more"></a><h2 id="平台支持"><a href="#平台支持" class="headerlink" title="平台支持"></a>平台支持</h2><p>毕昇JDK 当前支持 <code>Linux/AArch64</code> 平台。</p><h2 id="支持特性"><a href="#支持特性" class="headerlink" title="支持特性"></a>支持特性</h2><p><strong>毕昇JDK已经升级至8u262版本</strong>，感谢OpenJDK社区众多开发者的贡献，现在毕昇JDK也已支持JFR，它是默认关闭的，用户可以使用以下命令在java应用启动的时候启用JFR，您还需要一个jmc 7.0以上的版本来读取jfr dump文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">java</span> <span class="selector-tag">-XX</span><span class="selector-pseudo">:+FlightRecorder</span></span><br></pre></td></tr></table></figure><p><a href="https://gitee.com/openeuler/bishengjdk-11/wikis/FastSerializer?sort_id=2879166"><strong>快速序列化</strong></a> 对于一些需要使用Java原生序列化接口而无法使用第三方序列化框架的场景，我们对Java序列化做了一些优化，用户可以使用如下命令打开：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="attr">XX:</span>+UnlockExperimentalVMOptions -<span class="attr">XX:</span>+UseFastSerializer -DfastSerializerEscapeMode=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>该参数不能兼容所有序列化场景，对于<code>序列化对象在读写两端不一致</code>或者<code>classmeta信息在运行时发生改变</code>等场景，fastSerializer会无法支持，这时需要保证打开了<code>-DfastSerializerEscapeMode=true</code>选项保证可以回退到原生的序列化模式</p><h2 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a>安装指南</h2><p>您可以使用tar压缩包格式或者yum源方式来安装JDK（Java Development Kit）或者JRE（Java Runtime Environment）。</p><p>JDK是JRE的超集，包含了JRE的所有内容，并包含javac/jdb等开发者必须的编译器和调试器。JRE提供运行时库、Java虚拟机和其他运行java应用程序所必须的组件。请注意JRE不只包含Java SE规范的内容，也包含一些规范之外java应用程序常用的内容。</p><p>用户可以通过以下两种方式来安装：</p><ul><li>tar压缩包格式（.tar.gz）：通过这种方式您可以将JDK安装到系统的任意位置，且不会和系统中其他JDK产生影响。但是这种方式会需要用户进行一些手动设置。详情请见下表。</li><li>从yum源安装：通过这种方式您可以将JDK安装到系统的某个固定路径中，并为所有用户提供，这种安装方式需要root权限。<code>当前只有openEuler操作系统支持该操作</code>，详情请见下表。</li></ul><table><thead><tr><th>下载文件</th><th>操作指南</th><th>支持架构</th><th>安装所需权限</th><th>Sha256</th></tr></thead><tbody><tr><td><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9rdW5wZW5nL2FyY2hpdmUvY29tcGlsZXIvYmlzaGVuZ19qZGsvYmlzaGVuZy1qZGstOHUyNjItbGludXgtYWFyY2g2NC50YXIuZ3o=">bisheng-jdk-8u262-linux-aarch64.tar.gz<i class="fa fa-external-link-alt"></i></span></td><td><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vb3BlbmV1bGVyL2Jpc2hlbmdqZGstOC93aWtpcy8lRTYlQUYlOTUlRTYlOTglODdKREslMjA4JTIwJUU1JUFFJTg5JUU4JUEzJTg1JUU2JThDJTg3JUU1JThEJTk3P3NvcnRfaWQ9Mjg5MTE3OSMx">在 Linux/AArch64 平台上安装JDK 8<i class="fa fa-external-link-alt"></i></span></td><td>Linux/AArch64</td><td>任何人</td><td><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9rdW5wZW5nL2FyY2hpdmUvY29tcGlsZXIvYmlzaGVuZ19qZGsvYmlzaGVuZy1qZGstOHUyNjItbGludXgtYWFyY2g2NC50YXIuZ3ouc2hhMjU2">sha256<i class="fa fa-external-link-alt"></i></span></td></tr><tr><td><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9rdW5wZW5nL2FyY2hpdmUvY29tcGlsZXIvYmlzaGVuZ19qZGsvYmlzaGVuZy1qcmUtOHUyNjItbGludXgtYWFyY2g2NC50YXIuZ3o=">bisheng-jre-8u262-linux-aarch64.tar.gz<i class="fa fa-external-link-alt"></i></span></td><td><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vb3BlbmV1bGVyL2Jpc2hlbmdqZGstOC93aWtpcy8lRTYlQUYlOTUlRTYlOTglODdKREslMjA4JTIwJUU1JUFFJTg5JUU4JUEzJTg1JUU2JThDJTg3JUU1JThEJTk3P3NvcnRfaWQ9Mjg5MTE3OSMy">在 Linux/AArch64 平台上安装JRE 8<i class="fa fa-external-link-alt"></i></span></td><td>Linux/AArch64</td><td>任何人</td><td><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9rdW5wZW5nL2FyY2hpdmUvY29tcGlsZXIvYmlzaGVuZ19qZGsvYmlzaGVuZy1qcmUtOHUyNjItbGludXgtYWFyY2g2NC50YXIuZ3ouc2hhMjU2">sha256<i class="fa fa-external-link-alt"></i></span></td></tr><tr><td>从yum源安装</td><td>即将推出</td><td>*</td><td>root权限</td><td>*</td></tr></tbody></table><h3 id="在-Linux-AArch64-平台上安装JDK-8"><a href="#在-Linux-AArch64-平台上安装JDK-8" class="headerlink" title="在 Linux/AArch64 平台上安装JDK 8"></a>在 Linux/AArch64 平台上安装JDK 8</h3><ul><li>下载压缩包 <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9rdW5wZW5nL2FyY2hpdmUvY29tcGlsZXIvYmlzaGVuZ19qZGsvYmlzaGVuZy1qZGstOHUyNjItbGludXgtYWFyY2g2NC50YXIuZ3o=">bisheng-jdk-8u262-linux-aarch64.tar.gz<i class="fa fa-external-link-alt"></i></span>.</li><li>进入到你想要将JDK安装的目录中，并将 .tar.gz 压缩包拷贝到当前目录。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd <span class="regexp">/path/</span>to/jdk</span><br></pre></td></tr></table></figure><ul><li>将 .tar.gz 压缩包解压缩：</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar zxvf bisheng-jdk<span class="number">-8</span>u262-linux-aarch64.tar.gz</span><br></pre></td></tr></table></figure><p>JDK的安装目录为 jdk-8u262.</p><ul><li>如果您想节省磁盘空间，您可以删除 .tar.gz 压缩包。</li></ul><h3 id="在-Linux-AArch64-平台上安装JRE-8"><a href="#在-Linux-AArch64-平台上安装JRE-8" class="headerlink" title="在 Linux/AArch64 平台上安装JRE 8"></a>在 Linux/AArch64 平台上安装JRE 8</h3><ul><li>下载压缩包 <span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9rdW5wZW5nL2FyY2hpdmUvY29tcGlsZXIvYmlzaGVuZ19qZGsvYmlzaGVuZy1qcmUtOHUyNjItbGludXgtYWFyY2g2NC50YXIuZ3o=">bisheng-jre-8u262-linux-aarch64.tar.gz<i class="fa fa-external-link-alt"></i></span>.</li><li>进入到你想要将JDK安装的目录中，并将 .tar.gz 压缩包拷贝到当前目录。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd <span class="regexp">/path/</span>to/jre</span><br></pre></td></tr></table></figure><ul><li>将 .tar.gz 压缩包解压缩：</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar zxvf bisheng-jre<span class="number">-8</span>u262-linux-aarch64.tar.gz</span><br></pre></td></tr></table></figure><p>JRE的安装目录为 jre-8u262.</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vb3BlbmV1bGVyL2Jpc2hlbmdqZGstOA==">openeuler/bishengjdk-8<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;毕昇JDK是华为内部OpenJDK定制版Huawei JDK的开源版本，是一个高性能、可用于生产环境的OpenJDK发行版。Huawei JDK运行在华为内部500多个产品上，积累了大量使用场景和java开发者反馈的问题和诉求，解决了业务实际运行中遇到的多个问题，并在ARM架构上进行了性能优化，毕昇JDK运行在大数据等场景下可以获得更好的性能。毕昇JDK 8与Java SE标准兼容，目前仅支持Linux/AArch64平台。毕昇JDK同时是OpenJDK的下游，现在和未来也会持续稳定为OpenJDK社区做出贡献。&lt;/p&gt;
&lt;p&gt;二进制可以从&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9taXJyb3JzLmh1YXdlaWNsb3VkLmNvbS9rdW5wZW5nL2FyY2hpdmUvY29tcGlsZXIvYmlzaGVuZ19qZGsv&quot;&gt;这里&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;下载。&lt;/p&gt;</summary>
    
    
    
    <category term="release" scheme="http://yonghong.tech/categories/release/"/>
    
    
    <category term="JDK" scheme="http://yonghong.tech/tags/JDK/"/>
    
    <category term="Java" scheme="http://yonghong.tech/tags/Java/"/>
    
    <category term="release" scheme="http://yonghong.tech/tags/release/"/>
    
    <category term="毕昇" scheme="http://yonghong.tech/tags/%E6%AF%95%E6%98%87/"/>
    
    <category term="bisheng" scheme="http://yonghong.tech/tags/bisheng/"/>
    
    <category term="bishengjdk" scheme="http://yonghong.tech/tags/bishengjdk/"/>
    
  </entry>
  
  <entry>
    <title>SWOT分析法</title>
    <link href="http://yonghong.tech/wiki/swot/"/>
    <id>http://yonghong.tech/wiki/swot/</id>
    <published>2020-10-04T12:10:00.000Z</published>
    <updated>2020-10-04T12:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自 <span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9TV09UJUU1JTg4JTg2JUU2JTlFJTkwJUU2JUIzJTk1LzE1MDIyMw==">百度百科：SWOT分析法<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><img src="https://up-img.yonghong.tech/pic/2020/10/04-20-34-rdK27d-fpdd02.jpg" alt="SWOT分析法"></p><p>所谓SWOT分析，即基于内外部竞争环境和竞争条件下的态势分析，就是将与研究对象密切相关的各种主要内部优势、劣势和外部的机会和威胁等，通过调查列举出来，并依照矩阵形式排列，然后用系统分析的思想，把各种因素相互匹配起来加以分析，从中得出一系列相应的结论，而结论通常带有一定的决策性。</p><p>运用这种方法，可以对研究对象所处的情景进行全面、系统、准确的研究，从而根据研究结果制定相应的发展战略、计划以及对策等。</p><p>S （strengths）是优势、W （weaknesses）是劣势，O （opportunities）是机会、T （threats）是威胁。按照企业竞争战略的完整概念，战略应是一个企业“能够做的”（即组织的强项和弱项）和“可能做的”（即环境的机会和威胁）之间的有机组合。</p><a id="more"></a><h2 id="基本解释"><a href="#基本解释" class="headerlink" title="基本解释"></a>基本解释</h2><p>所谓SWOT分析，即基于内外部竞争环境和竞争条件下的态势分析，就是将与研究对象密切相关的各种主要内部优势、劣势和外部的机会和威胁等，通过调查列举出来，并依照矩阵形式排列，然后用系统分析的思想，把各种因素相互匹配起来加以分析，从中得出一系列相应的结论，而结论通常带有一定的决策性。</p><p>运用这种方法，可以对研究对象所处的情景进行全面、系统、准确的研究，从而根据研究结果制定相应的发展战略、计划以及对策等。</p><p>S （strengths）是优势、W （weaknesses）是劣势，O （opportunities）是机会、T （threats）是威胁。按照企业竞争战略的完整概念，战略应是一个企业“能够做的”（即组织的强项和弱项）和“可能做的”（即环境的机会和威胁）之间的有机组合。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>SWOT分析方法从某种意义上来说隶属于企业内部分析方法，即根据企业自身的条件在既定内进行分析。SWOT分析有其形成的基础。著名的竞争战略专家迈克尔.波特提出的竞争理论从产业结构入手对一个企业“可能做的”方面进行了透彻的分析和说明，而能力学派管理学家则运用价值链解构企业的价值创造过程，注重对公司的资源和能力的分析。</p><p>SWOT分析，就是在综合了前面两者的基础上，以资源学派学者为代表，将公司的内部分析（即20世纪80年代中期管理学界权威们所关注的研究取向），与以能力学派为代表的产业竞争环境的外部分析（即更早期战略研究所关注的中心主题，以安德鲁斯与迈克尔.波特为代表）结合起来，形成了自己结构化的平衡系统分析体系。 与其他的分析方法相比较，SWOT分析从一开始就具有显著的结构化和系统性的特征。就结构化而言，首先在形式上，SWOT分析法表现为构造SWOT结构矩阵，并对矩阵的不同区域赋予了不同分析意义。其次内容上，SWOT分析法的主要理论基础也强调从结构分析入手对企业的外部环境和内部资源进行分析。</p><h2 id="分析模型"><a href="#分析模型" class="headerlink" title="分析模型"></a>分析模型</h2><h3 id="优势与劣势分析（SW）"><a href="#优势与劣势分析（SW）" class="headerlink" title="优势与劣势分析（SW）"></a>优势与劣势分析（SW）</h3><p>由于企业是一个整体，并且由于竞争优势来源的广泛性，所以，在做优劣势分析时必须从整个价值链的每个环节上，将企业与竞争对手做详细的对比。如产品是否新颖，制造工艺是否复杂，销售渠道是否畅通，以及价格是否具有竞争性等。如果一个企业在某一方面或几个方面的优势正是该行业企业应具备的关键成功要素，那么，该企业的综合竞争优势也许就强一些。需要指出的是，衡量一个企业及其产品是否具有竞争优势，只能站在现有潜在用户角度上，而不是站在企业的角度上。</p><h3 id="机会与威胁分析（OT）"><a href="#机会与威胁分析（OT）" class="headerlink" title="机会与威胁分析（OT）"></a>机会与威胁分析（OT）</h3><p>比如当前社会上流行的盗版威胁：盗版替代品限定了公司产品的最高价，替代品对公司不仅有威胁，可能也带来机会。企业必须分析，替代品给公司的产品或服务带来的是 “灭顶之灾”呢，还是提供了更高的利润或价值；购买者转而购买替代品的转移成本；公司可以采取什么措施来降低成本或增加附加值来降低消费者购买盗版替代品的风险。</p><h3 id="整体分析"><a href="#整体分析" class="headerlink" title="整体分析"></a>整体分析</h3><p>从整体上看，SWOT可以分为两部分：第一部分为SW，主要用来分析内部条件；第二部分为OT，主要用来分析外部条件。利用这种方法可以从中找出对自己有利的、值得发扬的因素，以及对自己不利的、要避开的东西，发现存在的问题，找出解决办法，并明确以后的发展方向。根据这个分析，可以将问题按轻重缓急分类，明确哪些是急需解决的问题，哪些是可以稍微拖后一点儿的事情，哪些属于战略目标上的障碍，哪些属于战术上的问题，并将这些研究对象列举出来，依照矩阵形式排列，然后用系统分析的所想，把各种因素相互匹配起来加以分析，从中得出一系列相应的结论而结论通常带有一定的决策性，有利于领导者和管理者做出较正确的决策和规划。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>SWOT分析法常常被用于制定集团发展战略和分析竞争对手情况，在战略分析中，它是最常用的方法之一。进行SWOT分析时，主要有以下几个方面的内容：</p><h3 id="分析环境因素"><a href="#分析环境因素" class="headerlink" title="分析环境因素"></a>分析环境因素</h3><p>运用各种调查研究方法，分析出公司所处的各种环境因素，即外部环境因素和内部能力因素。外部环境因素包括机会因素和威胁因素，它们是外部环境对公司的发展直接有影响的有利和不利因素，属于客观因素，内部环境因素包括优势因素和弱点因素，它们是公司在其发展中自身存在的积极和消极因素，属主观因素，在调查分析这些因素时，不仅要考虑到历史与现状，而且更要考虑未来发展问题。</p><p>优势，是组织机构的内部因素，具体包括：有利的竞争态势；充足的财政来源；良好的企业形象；技术力量；规模经济；产品质量；市场份额；成本优势；广告攻势等。</p><p>劣势，也是组织机构的内部因素，具体包括：设备老化；管理混乱；缺少关键技术；研究开发落后；资金短缺；经营不善；产品积压；竞争力差等。</p><p>机会，是组织机构的外部因素，具体包括：新产品；新市场；新需求；外国市场壁垒解除；竞争对手失误等。</p><p>威胁，也是组织机构的外部因素，具体包括：新的竞争对手；替代产品增多；市场紧缩；行业政策变化；经济衰退；客户偏好改变；突发事件等。</p><p>SWOT方法的优点在于考虑问题全面，是一种系统思维，而且可以把对问题的“诊断”和“开处方”紧密结合在一起，条理清楚，便于检验。</p><h3 id="构造SWOT矩阵"><a href="#构造SWOT矩阵" class="headerlink" title="构造SWOT矩阵"></a>构造SWOT矩阵</h3><p>将调查得出的各种因素根据轻重缓急或影响程度等排序方式，构造SWOT矩阵。在此过程中，将那些对公司发展有直接的、重要的、大量的、迫切的、久远的影响因素优先排列出来，而将那些间接的、次要的、少许的、不急的、短暂的影响因素排列在后面。</p><h3 id="制定行动计划"><a href="#制定行动计划" class="headerlink" title="制定行动计划"></a>制定行动计划</h3><p>在完成环境因素分析和SWOT矩阵的构造后，便可以制定出相应的行动计划。制定计划的基本思路是：发挥优势因素，克服弱点因素，利用机会因素，化解威胁因素；考虑过去，立足当前，着眼未来。运用系统分析的综合分析方法，将排列与考虑的各种环境因素相互匹配起来加以组合，得出一系列公司未来发展的可选择对策。</p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>成功应用SWOT分析法的简单规则：</p><ul><li>进行SWOT分析的时候必须对公司的优势与劣势有客观的认识。</li><li>进行SWOT分析的时候必须区分公司的现状与前景。</li><li>进行SWOT分析的时候必须考虑全面。</li><li>进行SWOT分析的时候必须与竞争对手进行比较，比如优于或是劣于你的竞争对手。</li><li>保持SWOT分析法的简洁化，避免复杂化与过度分析。</li><li>SWOT分析法因人而异。</li></ul><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><p>SWOT方法的贡献就在于用系统的思想将这些似乎独立的因素相互匹配起来进行综合分析，使得企业战略计划的制定更加科学全面。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文转载自 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9TV09UJUU1JTg4JTg2JUU2JTlFJTkwJUU2JUIzJTk1LzE1MDIyMw==&quot;&gt;百度百科：SWOT分析法&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://up-img.yonghong.tech/pic/2020/10/04-20-34-rdK27d-fpdd02.jpg&quot; alt=&quot;SWOT分析法&quot;&gt;&lt;/p&gt;
&lt;p&gt;所谓SWOT分析，即基于内外部竞争环境和竞争条件下的态势分析，就是将与研究对象密切相关的各种主要内部优势、劣势和外部的机会和威胁等，通过调查列举出来，并依照矩阵形式排列，然后用系统分析的思想，把各种因素相互匹配起来加以分析，从中得出一系列相应的结论，而结论通常带有一定的决策性。&lt;/p&gt;
&lt;p&gt;运用这种方法，可以对研究对象所处的情景进行全面、系统、准确的研究，从而根据研究结果制定相应的发展战略、计划以及对策等。&lt;/p&gt;
&lt;p&gt;S （strengths）是优势、W （weaknesses）是劣势，O （opportunities）是机会、T （threats）是威胁。按照企业竞争战略的完整概念，战略应是一个企业“能够做的”（即组织的强项和弱项）和“可能做的”（即环境的机会和威胁）之间的有机组合。&lt;/p&gt;</summary>
    
    
    
    <category term="wiki" scheme="http://yonghong.tech/categories/wiki/"/>
    
    
    <category term="wiki" scheme="http://yonghong.tech/tags/wiki/"/>
    
    <category term="SWOT" scheme="http://yonghong.tech/tags/SWOT/"/>
    
    <category term="SWOT分析" scheme="http://yonghong.tech/tags/SWOT%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>STAR法则</title>
    <link href="http://yonghong.tech/wiki/star/"/>
    <id>http://yonghong.tech/wiki/star/</id>
    <published>2020-10-04T12:00:00.000Z</published>
    <updated>2020-10-04T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自 <span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9TVEFSJUU2JUIzJTk1JUU1JTg4JTk5LzkwNTYwNzA=">百度百科：STAR法则<i class="fa fa-external-link-alt"></i></span></p></blockquote><p><img src="https://up-img.yonghong.tech/pic/2020/10/04-20-39-CAldGX-3y4j70.jpg" alt="STAR法则"></p><p>STAR法则是情境(situation)、目标（target）、行动(action)、结果(result)四项的缩写。STAR法则是一种常常被面试官使用的工具，用来收集面试者与工作相关的具体信息和能力。STAR法则比起传统的面试手法来说，可以更精确地预测面试者未来的工作表现。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>STAR法则,即为Situation Target Action Result的缩写，具体含义是:</p><ul><li>Situation: 事情是在什么情况下发生</li><li>Target 你是如何明确你的目标的</li><li>Action: 针对这样的情况分析，你采用了什么行动方式</li><li>Result: 结果怎样，在这样的情况下你学习到了什么</li></ul><p>简而言之，STAR法则，就是一种讲述自己故事的方式，或者说，是一个清晰、条理的作文模板。不管是什么，合理熟练运用此法则，可以轻松的对面试官描述事物的逻辑方式，表现出自己分析阐述问题的清晰性、条理性和逻辑性。</p><h2 id="详细释义"><a href="#详细释义" class="headerlink" title="详细释义"></a>详细释义</h2><p>STAR法则，500强面试题回答时的技巧法则，备受面试者成功者和500强HR的推崇。</p><p>由于这个法则被广泛应用于面试问题的回答，尽管我们还在写简历阶段，但是，写简历时能把面试的问题就想好，会使自己更加主动和自信，做到简历，面试关联性，逻辑性强，不至于在一个月后去面试，却把简历里的东西都忘掉了（更何况有些朋友会稍微夸大简历内容）</p><p>在我们写简历时，每个人都要写上自己的工作经历，活动经历，想必每一个同学，都会起码花上半天甚至更长的时间去搜寻脑海里所有有关的经历，争取找出最好的东西写在简历上。</p><p>但是此时，我们要注意了，简历上的任何一个信息点都有可能成为日后面试时的重点提问对象，所以说，不能只管写上让自己感觉最牛的经历就完事了，要想到今后，在面试中，你所写的经历万一被面试官问到，你真的能回答得流利，顺畅，且能通过这段经历，证明自己正是适合这个职位的人吗？</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>写简历时就要准备好面试时的个人故事，以便应付各种千奇百怪的开放性问题。</p><p>为了使大家轻松应对这一切，我向大家推荐“个人事件模块”的方法，以使自己迅速完成这看似庞大的工程。</p><h3 id="个人事件模块"><a href="#个人事件模块" class="headerlink" title="个人事件模块"></a>个人事件模块</h3><ol><li>头脑风暴。</li></ol><p>在脑海里仔细想出从大一到大四自己参与过所有活动（尤其是能突出你某些能力的活动），包括：</p><ul><li>社团活动 职务 时间 所做事情</li><li>在公司实习的经历 职务 时间 所做过的事情</li><li>与他人一起合作的经历（课题调研，帮助朋友办事）</li></ul><p>（回忆要尽量的详细，按时间倒序写在纸上，如大一上学期发生、大一下学期发生。如此类推）<br>我相信这一步，很多朋友都已经做了，但是仅仅这样就满足了，就直接写在简历上当完事了，那是不行的，想提高竞争力，还得继续。。</p><ol start="2"><li>STAR法则应用</li></ol><p>将每件事用S T A R 四点写出，将重要的事情做成表格。</p><p>例：大一辩论比赛获得冠军</p><ul><li>S系里共有5支队伍参赛，实力。。。，我们小组。。。。。</li><li>T熟悉辩论流程，掌握辩论技巧，获得系冠军</li><li>A自己主动整理资料，组织小组学习流程，编制训练题，小组训练，根据每个人的特点，分配任务（详细，尽量详细，包括当中遇到的困难都要回忆起来，自己是怎么解决的）</li><li>R获得系辩论赛冠军</li></ul><p>以上这个例子中，可以让HR迅速了解你整个活动的前因后果，同时，也突出了你在这个活动过程中的领导能力，沟通能力，主动解决问题的能力等等。</p><p>将刚才在头脑风暴中，想到的事情都用这个方法做出表格。一般来说，特别突出的事情应该要达到7，8件。</p><p>这个时候，个人事件模块的工作就算完成了，但是，怎么运用呢？还得再做多一步。</p><h3 id="挖掘闪光点"><a href="#挖掘闪光点" class="headerlink" title="挖掘闪光点"></a>挖掘闪光点</h3><p>开放性问题大家都要回答吧？大家也都知道，其实每一个开放性问题都在考查自己的每一项能力，如领导能力，沟通能力，适应能力等等。而挖掘闪光点就是在这些事件模块中找出你所能体现的这些能力，如上例辩论赛中所体现的领导能力，沟通能力，主动解决问题。这时候，就可以在下面加多一行，能力体现。</p><p>大一辩论比赛获得冠军</p><ul><li>S 系里共有5支队伍参赛，实力。。。，我们小组。。。。。</li><li>T 熟悉辩论流程，掌握辩论技巧，获得系冠军</li><li>R 获得系辩论赛冠军</li></ul><p>能力沟通能力，协作能力，领导能力，主动解决问题能力</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有了事情模块，也知道了每个事件自己所体现出的能力，这时候的你，还需要害怕那些开放性问题吗？</p><p>以上所说都是主要为面试而准备的，但是，写简历阶段时就可以应用这些模块，针对你某阶段的某一件事，将模块中的A，R两项以简洁的语言写上。这样，当HR问你简历上的问题时，你就可以有备而回答之啦！当然，针对职位的不同，要求自然也不同，但是，这一切都可以参考STAR法则来解决，例如，你要申请的是销售类的，你就将关于沟通能力，营销经验的事例写上，并且突出自己与其的相关性，这样，自然就可以提高简历的命中率。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文转载自 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9TVEFSJUU2JUIzJTk1JUU1JTg4JTk5LzkwNTYwNzA=&quot;&gt;百度百科：STAR法则&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://up-img.yonghong.tech/pic/2020/10/04-20-39-CAldGX-3y4j70.jpg&quot; alt=&quot;STAR法则&quot;&gt;&lt;/p&gt;
&lt;p&gt;STAR法则是情境(situation)、目标（target）、行动(action)、结果(result)四项的缩写。STAR法则是一种常常被面试官使用的工具，用来收集面试者与工作相关的具体信息和能力。STAR法则比起传统的面试手法来说，可以更精确地预测面试者未来的工作表现。&lt;/p&gt;</summary>
    
    
    
    <category term="wiki" scheme="http://yonghong.tech/categories/wiki/"/>
    
    
    <category term="wiki" scheme="http://yonghong.tech/tags/wiki/"/>
    
    <category term="STAR" scheme="http://yonghong.tech/tags/STAR/"/>
    
    <category term="STAR法则" scheme="http://yonghong.tech/tags/STAR%E6%B3%95%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Chaos Mesh® 1.0 GA，让混沌工程变得简单！</title>
    <link href="http://yonghong.tech/release/chaos-mesh-1-0-ga/"/>
    <id>http://yonghong.tech/release/chaos-mesh-1-0-ga/</id>
    <published>2020-10-04T03:00:00.000Z</published>
    <updated>2020-10-04T03:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自 <span class="exturl" data-url="aHR0cHM6Ly9waW5nY2FwLmNvbS9ibG9nLWNuL2NoYW9zLW1lc2gtMS4wLWdhLw==">Chaos Mesh® 1.0 GA，让混沌工程变得简单！<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>Chaos Mesh 是一个云原生的混沌测试平台，在去年的最后一天，我们开源了这个项目，以帮助大家更好的进行混沌实验。从开源到现在近一年的时间里，Chaos Mesh 在所有贡献者的共同努力下，在不断完善新功能的同时，也在易用性和稳定性上取得了阶段性的成果。今天，我们自豪的宣布 Chaos Mesh 1.0 正式发布！</p><p>Chaos Mesh 1.0 是一个里程碑，不仅支持更多混沌注入的类型，提高了框架组件的稳定性，并且增加了 Chaos Dashboard 组件用来改善 Chaos Mesh 的易用性。下面请跟随我们的脚步梳理 Chaos Mesh 1.0 有什么样的惊喜。</p><a id="more"></a><h2 id="核心亮点"><a href="#核心亮点" class="headerlink" title="核心亮点"></a>核心亮点</h2><h3 id="1-丰富易用的混沌实验类型"><a href="#1-丰富易用的混沌实验类型" class="headerlink" title="1. 丰富易用的混沌实验类型"></a>1. 丰富易用的混沌实验类型</h3><p>混沌实验的核心是注入故障，Chaos Mesh 从分布式系统的出发，充分考虑分布式系统可能出现的故障，提供更加全面、细粒度的故障类型，能全方位的帮用户对网络、磁盘、文件系统、操作系统等进行故障注入。同时，使用 Chaos Mesh，不需要应用做任何修改，做到真正的被测试系统无感知。Chaos Mesh 目前支持的故障注入有：</p><ul><li>pod-kill：模拟 Kubernetes Pod 被 kill。</li><li>pod-failure：模拟 Kubernetes Pod 持续不可用，可以用来模拟节点宕机不可用场景。</li><li>container-kill：模拟 Container 被 kill。</li><li>network-latency：模拟网络延迟。</li><li>network-loss：模拟网络丢包。</li><li>network-duplication：模拟网络包重复。</li><li>network-corrupt：模拟网络包损坏。</li><li>network-partition：模拟网络分区。</li><li>cpu-burn：模拟 CPU 压力。</li><li>memory-burn：模拟 Memory 压力。</li><li>clock-skew：模拟时钟偏移。</li><li>io-latency：模拟文件系统 I/O 延迟。</li><li>io-fault：模拟文件系统 I/O 错误。</li><li>io-attribution-override：模拟文件异常。</li><li>kernel-injection: 模拟内核故障。</li></ul><h3 id="2-简单易用的可视化界面"><a href="#2-简单易用的可视化界面" class="headerlink" title="2. 简单易用的可视化界面"></a>2. 简单易用的可视化界面</h3><p>Chaos Mesh 从用户角度出发，不仅可以提供通过 YAML 文件定义混沌实验的方式，还单独开发了 Chaos Dashbaord 组件，提供可视化支持。Chaos Dashboard 极大简化了混沌实验的复杂度，用户可以直接通过可视化界面来管理和监控混沌实验，仅需鼠标点一点就能够定义混沌实验的范围、指定混沌注入类型、定义调度规则，以及在界面上获取到混沌实验的结果等。</p><p><img src="https://up-img.yonghong.tech/pic/2020/10/04-11-25-1-dash-0jvUgx.gif" alt="dashboard"></p><h3 id="3-提供-Grafana-插件支持"><a href="#3-提供-Grafana-插件支持" class="headerlink" title="3. 提供 Grafana 插件支持"></a>3. 提供 Grafana 插件支持</h3><p>Chaos Mesh 为了进一步提高混沌实验的可观测性，单独开发了 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoYW9zLW1lc2gvY2hhb3MtbWVzaC1kYXRhc291cmNl">Grafana 插件<i class="fa fa-external-link-alt"></i></span>，方便用户直接将混沌实验的运行信息展示在自己的监控面板上。用户在 Grafana 上安装了此插件后，可以直接在应用的监控面板上开启混沌实验信息按钮，此时混沌实验的相关信息会以 <span class="exturl" data-url="aHR0cHM6Ly9ncmFmYW5hLmNvbS9kb2NzL2dyYWZhbmEvbGF0ZXN0L2Rhc2hib2FyZHMvYW5ub3RhdGlvbnMv">Annotations<i class="fa fa-external-link-alt"></i></span> 的方式在当前的面板上展示出来，这样用户就可以在一个界面上同时观察到应用的运行情况以及当前运行的混沌实验信息。</p><p><img src="https://up-img.yonghong.tech/pic/2020/10/04-11-25-2-Grafana%E6%8F%92%E4%BB%B6-MbtpyP.png" alt="Grafana插件"></p><h3 id="4-安全可控的混沌实验"><a href="#4-安全可控的混沌实验" class="headerlink" title="4. 安全可控的混沌实验"></a>4. 安全可控的混沌实验</h3><p>当在进行混沌实验的时候，我们需要严格的控制实验范围，只影响需要测试的应用程序，避免导致整体应用的雪崩。Chaos Mesh 在 1.0 版本中不仅提供了丰富的 Selectors 用来控制实验范围，还支持设置被保护的 Namespaces 用来保护重要应用。此外，在 1.0 中 Chaos Mesh 还支持在 Namespace 权限使用，也就是说用户可以在单个 Namespace 下安装 Chaos Mesh 或者是把 Chaos Mesh 的权限范围限制在特定某个 Namespace 下，如此一来可以更大程度控制实验的“爆炸半径”，提供更加安全的混沌实验体现。</p><h2 id="快速体验"><a href="#快速体验" class="headerlink" title="快速体验"></a>快速体验</h2><p>大家通过 install.sh 安装脚本或者是使用 Helm 工具就可以在自己的 Kubernetes 环境下快速的部署 Chaos Mesh，具体安装步骤可以参考 <span class="exturl" data-url="aHR0cHM6Ly9jaGFvcy1tZXNoLm9yZy9kb2NzL2luc3RhbGxhdGlvbi9pbnN0YWxsYXRpb24=">Chaos Mesh 部署文档<i class="fa fa-external-link-alt"></i></span>。此外社区的小伙伴也贡献了在线 Chaos Mesh 简单教程，想要快速尝试的小伙伴也可以直接按照课程，在线试用，课程地址：<span class="exturl" data-url="aHR0cHM6Ly9jaGFvcy1tZXNoLm9yZy9pbnRlcmFjdGl2ZVR1dG9yaWFsJUUzJTgwJTgy">https://chaos-mesh.org/interactiveTutorial。<i class="fa fa-external-link-alt"></i></span></p><p>对于 1.0 GA 之前版本的用户，请参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoYW9zLW1lc2gvY2hhb3MtbWVzaC9yZWxlYXNlcy90YWcvdjEuMC4w">1.0 Release Note<i class="fa fa-external-link-alt"></i></span> 了解 1.0 的变更内容和升级指南。</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢所有 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoYW9zLW1lc2gvY2hhb3MtbWVzaC9ncmFwaHMvY29udHJpYnV0b3Jz">Chaos Mesh 的贡献者<i class="fa fa-external-link-alt"></i></span> ，Chaos mesh 能够走到 1.0 GA 离不开每一位贡献者的努力！</p><p>最后欢迎大家为 Chaos Mesh 提交 issue 或者参考文档开始提交代码，Chaos Mesh 期待大家的参与和反馈！</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文转载自 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9waW5nY2FwLmNvbS9ibG9nLWNuL2NoYW9zLW1lc2gtMS4wLWdhLw==&quot;&gt;Chaos Mesh® 1.0 GA，让混沌工程变得简单！&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Chaos Mesh 是一个云原生的混沌测试平台，在去年的最后一天，我们开源了这个项目，以帮助大家更好的进行混沌实验。从开源到现在近一年的时间里，Chaos Mesh 在所有贡献者的共同努力下，在不断完善新功能的同时，也在易用性和稳定性上取得了阶段性的成果。今天，我们自豪的宣布 Chaos Mesh 1.0 正式发布！&lt;/p&gt;
&lt;p&gt;Chaos Mesh 1.0 是一个里程碑，不仅支持更多混沌注入的类型，提高了框架组件的稳定性，并且增加了 Chaos Dashboard 组件用来改善 Chaos Mesh 的易用性。下面请跟随我们的脚步梳理 Chaos Mesh 1.0 有什么样的惊喜。&lt;/p&gt;</summary>
    
    
    
    <category term="release" scheme="http://yonghong.tech/categories/release/"/>
    
    
    <category term="release" scheme="http://yonghong.tech/tags/release/"/>
    
    <category term="Chaos Mesh" scheme="http://yonghong.tech/tags/Chaos-Mesh/"/>
    
  </entry>
  
  <entry>
    <title>句读-2020年09月</title>
    <link href="http://yonghong.tech/judou-2020-09/"/>
    <id>http://yonghong.tech/judou-2020-09/</id>
    <published>2020-10-03T01:00:00.000Z</published>
    <updated>2020-10-03T01:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>生活如果没有目标，就会变得懒散。一旦决定“今天这样做”，生活一下子就会张弛有度。中村恒子</p></blockquote><a id="more"></a><ul><li><p>我从来不想显得不友好，可是我也从来没有刻意努力显得友好。因为有时我还是想独自一人，不被打扰。石黑一雄 《远山淡影》</p></li><li><p>用疑问句回答疑问句时，一般就是说中了。《四重奏》</p></li><li><p>不了解别人的痛苦，又要去安慰，那总是很困难的事。小仲马 《茶花女》</p></li><li><p>有时候别人对你很糟糕，不代表你就该被糟糕地对待。很多人爱你，关心你，希望你要知道。</p></li><li><p>没有人天生就强、就弱或意志坚定。是后来才变强，后来才意志坚定。命运不在人身上，而在人四周。阿贝尔·加缪</p></li><li><p>能被一个人放在心上，从来都不是理所当然的事，不管那个人是谁，是家人还是朋友，都非常难得，应该要好好珍惜才对。《想见你》</p></li><li><p>年轻人常常觉得自己很叛逆，但是回看历史，年轻人常常是最随波逐流的，因为他们的内在自我还不够强大，所以往往隐身于群体去获得力量，把潮流当作思想。刘瑜</p></li><li><p>凡事都有可能，永远别说永远。《放牛班的春天》</p></li><li><p>那些住进日记里很多页的人，最后还是走丢了，好像我们的交集也只存在于那几页纸上。就是初霁</p></li><li><p>人生苦短，感到欢乐的弹指之间，若不开怀大笑，日后岂不后悔？森鸥外 《泡沫记》</p></li><li><p>我想现代社会的忧郁就是这么回事，人们对幸福生活的定义愈来愈高，以前人的普通生活成了现在的悲惨生活。北野武</p></li><li><p>生活如果没有目标，就会变得懒散。一旦决定“今天这样做”，生活一下子就会张弛有度。中村恒子</p></li><li><p>你无需告诉每个人，那一个个艰难的日子是如何熬过来的，但，总有一天你要向这个世界大声呐喊：我成功的走过了人生中灰暗的时光。德卡先生</p></li><li><p>不要太在乎一些人，越在乎，越卑微。周国平</p></li><li><p>我在和每一段我以为会走得长远的友谊告别。 只希望我再也不会因她们伤心难过了。夏至粥五</p></li><li><p>人的一生，你所经历的一些东西是必定的，或许在你来到这个世界之前，你已经看过自己的剧本了，所以才会选择以这个身份来到这个世界，所以就一定会有你觉得值得的事情。里予</p></li><li><p>明知世界上没有安慰可言，他就自己创造安慰。明知生活没有什么意义，他就自己创造生活的意义。罗曼·罗兰</p></li><li><p>人生太过复杂，我也不是万事明了，能送给你的只有四个字“好好感受”。田村正和</p></li><li><p>太多人活得不像自己。思想是别人的意见，生活是别人的模仿，情感是别人的引述。奧斯卡·王尔德</p></li><li><p>生活自会消化一切，既不要人帮忙，也不要人同意。契诃夫 《游猎惨剧》</p></li><li><p>我的经验是，碰到任何困难都要赶快往前走，不要欣赏那个让你摔倒的那个坑。 ​​​​黄永玉</p></li><li><p>我注意到：一个懒惰的人，一个不愿动的人，一旦动起来，就会持之以恒动下去，就跟他坚持待着不动时一样，好像他不喜欢的倒不是动本身，而是开始和停止。威廉·福克纳 《我弥留之际》</p></li><li><p>你的生活深度取决于你对年幼者的呵护，对年长者的同情，对奋斗者的怜悯体恤，对弱者及强者的包容。因为生命中总有一天你会发现其中每一个角色你都扮演过。乔治·华盛顿</p></li><li><p>所有的人类都是活在主观之中，只要改变自己的看法，世界就会改变。从那一瞬间开始，人就会获得重生。《被讨厌的勇气》</p></li><li><p>我对这个世界生气，它也对我生气，我对这个世界不满，它也对我不满，我发泄了什么出去，它就照样把什么送回来。德卡先生</p></li><li><p>生活只能向后理解。 但它必须向前发展。索伦·克尔凯郭尔</p></li><li><p>性情中人，很容易犯两个错误：一个是因为别人细节上的不合心意或者犯了某个私家忌讳就唾弃之，退避三舍；另一个是因为别人说了一句你一直想听的话，就引为知己，死心塌地。潘向黎 《万念》</p></li><li><p>你有没有过这种情况：在一个陌生的地方，看到一个陌生人，心想「这可能是我这辈子唯一和他相遇的瞬间」。然后就很难过。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;生活如果没有目标，就会变得懒散。一旦决定“今天这样做”，生活一下子就会张弛有度。中村恒子&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="句读" scheme="http://yonghong.tech/categories/%E5%8F%A5%E8%AF%BB/"/>
    
    
    <category term="句读" scheme="http://yonghong.tech/tags/%E5%8F%A5%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>欧陆词典每日一句-2020年09月</title>
    <link href="http://yonghong.tech/eudic-2020-09/"/>
    <id>http://yonghong.tech/eudic-2020-09/</id>
    <published>2020-10-03T00:00:00.000Z</published>
    <updated>2020-10-03T00:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>There is nothing permanent except change. 盖将自其变者而观之，则天地曾不能以一瞬。</p></blockquote><a id="more"></a><ul><li><p>Don’t let the noise of other’s opinion drown out your own inner voice. 不要让别人的意见淹没了你自已内心的声音。</p></li><li><p>Without you, without the affectionate hand you extended to the small poor child that I was, without your teaching and example, none of this would have happened. 如果没有您，如果不是您用慈爱的手抚慰我这个可怜的小孩，如果不是您的谆谆教诲和以身作则，这一切的一切都无从谈起。</p></li><li><p>It’s nothing that a gallant girl can’t handle. 没有勇敢的女孩做不了的事情。</p></li><li><p>End of sermon. As Buddha says: live like a mighty river. 说教到此就告一段落。正如佛陀所言：像一条浩荡的河流般生活。</p></li><li><p>I’ve seen a thousand moons: harvest moons like gold coins, winter moons as white as ice chips, new moons like baby swans’ feathers. 我看过无数次月亮：满月如金币，寒月洁白似冰屑，新月宛如小天鹅的羽毛。</p></li><li><p>Learning another language gives the learner the ability to step inside the mind and context of that other culture. 学习外语能让学习者深入到异域文化的里层。</p></li><li><p>Home is the place in the world that totally belongs to you. 家是一个完全属于你自己的地方。</p></li><li><p>The first in time and the first in importance of the influences upon the mind is that of nature. 在所有对头脑的影响中，大自然的影响可谓在时间上最先，在作用上最为重要。</p></li><li><p>As the saying goes, a friend in need is a friend indeed. 老话说，患难见真情。</p></li><li><p>So take this new opportunity to look about and fill your lungs with that fantastic land, while it and you are still there. 所以趁现在这个机会四处看看，趁你还站在那片土地上，尽情地呼吸吧。</p></li><li><p>An individual human existence should be like a river — small at first, narrowly contained within its banks, and rushing passionately. 一个人的存在应该像一条河流：起初很小，被紧紧地夹在两岸中间，接着热情地奔走。</p></li><li><p>Money means a win-win situation for me and the others. 金钱意味着能为我和其他人带来双赢。</p></li><li><p>Music is life. What would this world be without good music? No matter what kind it is. 音乐就是生活。这个世界如果没有好音乐会成什么样子呢？不论哪类音乐都是如此。</p></li><li><p>I prefer to take my time and enjoy the scenery along the way. 我喜欢花些时间享受沿途的风景。</p></li><li><p>If the land is destined to form the hills again, let real human beings learn to choose the higher ground. 如果陆地注定要上升，就让人类重新选择生存的峰顶。</p></li><li><p>And the only thing people regret is that they don’t live boldly enough, that they don’t invest enough heart, didn’t love enough. 人们唯一遗憾的是，他们没有足够勇敢地生活，没有投入足够的心力，爱得不够铭心刻骨。</p></li><li><p>You have to be abroad, you have to be hermetically sealed off from your intimates, from your home to realize what a gift this going home is. 只有远在海外漂泊，彻底与亲朋挚友切断联系才懂得回家是怎样的幸福。</p></li><li><p>I don’t think it’s reliable to judge a person by the first glance. 我认为不能依靠第一印象来判断一个人。</p></li><li><p>And don’t be afraid of the dark. 不要惧怕黑暗。</p></li><li><p>The whole art of knowledge is only the art of awakening the natural curiosity of young minds for the purpose of satisfying it afterwards. 教育的全部艺术，就是将幼小心灵中天生的好奇心唤醒，以便在日后使其满足。</p></li><li><p>Happiness is a butterfly, which when pursued, is always just beyond your grasp, but which, if you will sit down quietly, may alight upon you. 幸福有如蝴蝶，你追逐它时永远捉不到，你静坐下来，它却可能落在你身上。</p></li><li><p>There is nothing permanent except change. 唯有变化才是永恒的。（盖将自其变者而观之，则天地曾不能以一瞬）</p></li><li><p>If 1000 challengers are under your feet, count me as the challenger 1001. 纵使你脚下有一千名挑战者，那就把我算作第一千零一名。</p></li><li><p>If the sea is doomed someday to break its levees, my heart must flood with all the bitter waters. 如果海洋注定要决堤，就让所有的苦水都注入我心中。</p></li><li><p>A good friend should be willing to help you when you are in trouble, comfort you when you are frustrated. 一个好朋友应该会在你困难时候拉一把，在你沮丧时给个肩膀依靠。</p></li><li><p>What is glory without virtue? 如果没有美德，荣耀又算得了什么呢？</p></li><li><p>Live your life with passion, with some drive! 用激情来点燃你的生活，积极地面对一切！</p></li><li><p>Education is more valuable than money, in the long run. 从长远来看，教育比金钱更有价值。</p></li><li><p>Good negotiators learn fast. Poor negotiators remain like that and go on losing negotiations. 优秀的谈判者学习得很快。拙劣的谈判者保持现状，并且谈判会继续失利。</p></li><li><p>Don’t be too concerned with the opinions of others. 不要太在意别人的意见。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;There is nothing permanent except change. 盖将自其变者而观之，则天地曾不能以一瞬。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="学英语" scheme="http://yonghong.tech/categories/%E5%AD%A6%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="http://yonghong.tech/tags/%E8%8B%B1%E8%AF%AD/"/>
    
    <category term="学英语" scheme="http://yonghong.tech/tags/%E5%AD%A6%E8%8B%B1%E8%AF%AD/"/>
    
    <category term="欧陆词典" scheme="http://yonghong.tech/tags/%E6%AC%A7%E9%99%86%E8%AF%8D%E5%85%B8/"/>
    
    <category term="每日一句" scheme="http://yonghong.tech/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>如何写一份有效的技术简历？</title>
    <link href="http://yonghong.tech/technical-resume/"/>
    <id>http://yonghong.tech/technical-resume/</id>
    <published>2020-10-01T01:00:00.000Z</published>
    <updated>2020-10-01T01:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自 <span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDIwLzAxL3RlY2huaWNhbC1yZXN1bWUuaHRtbA==">如何写一份有效的技术简历？<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>现在找工作的程序员很多，都需要写简历。</p><p>我见过很多简历，写得很糟糕，看不出这个人的亮点在哪里。一个人总是有亮点的，对不对。</p><p>一些同学私下找我，让我帮忙修改简历。我在这里把自己的看法写出来，开发者的简历应该怎么写，效果最好。以后再有人找我，就让他看这篇文章。</p><a id="more"></a><p><img src="https://up-img.yonghong.tech/pic/2020/10/01-12-21-bg2020010407-Z8h4C2.jpg" alt="img"></p><p>如果你按照本文的建议，我保证你会写出一份令人印象深刻的简历，拿到面试的机会大大增加。</p><h2 id="一、以项目为主体，设计你的简历"><a href="#一、以项目为主体，设计你的简历" class="headerlink" title="一、以项目为主体，设计你的简历"></a>一、以项目为主体，设计你的简历</h2><p>根据<span class="exturl" data-url="aHR0cHM6Ly93d3cucHJuZXdzd2lyZS5jb20vbmV3cy1yZWxlYXNlcy9sYWRkZXJzLXVwZGF0ZXMtcG9wdWxhci1yZWNydWl0ZXItZXllLXRyYWNraW5nLXN0dWR5LXdpdGgtbmV3LWtleS1pbnNpZ2h0cy1vbi1ob3ctam9iLXNlZWtlcnMtY2FuLWltcHJvdmUtdGhlaXItcmVzdW1lcy0zMDA3NDQyMTcuaHRtbA==">一项研究<i class="fa fa-external-link-alt"></i></span>，招聘人员（尤其是大公司的）在2018年仅花费大约7.4秒，分析一份简历。几秒钟的时间，如果找不到感兴趣的点，他就会 Pass 你的简历。</p><p>所以，你动手写简历之前，脑袋里面要有一个观念： 简历是用来传递信息的，一定要突出重点内容。不要写得密密麻麻，堆砌各种无关的信息，这样只会埋没你的长处，让招聘人员抓不到重点。</p><p><img src="https://up-img.yonghong.tech/pic/2020/10/01-12-21-bg2020010503-z34rj4.jpg" alt="img"></p><p>那么，你应该把什么信息，放到简历上面呢？</p><p><strong>对于开发者来说，你的项目就是你的简历。你需要突出你的项目，和项目涉及的技能，让招聘人员一目了然。</strong> 简历的主体，至少一半以上的内容，应该是你做过的项目，或者取得的成就，这是最有证明能力的东西。</p><p>如果你是学生，简历不必写你的绩点、上过的课程、得过的奖学金，当过学生会干部，组织过社团活动、通过四六级考试等等。那些东西对企业没用，缺乏有针对性的证明能力。</p><p>你也不要描述自己的工作态度，比如”具有团队合作精神”、”积极进取”、”努力工作”，这是默认你应该做到的，不是得分项。</p><h2 id="二、针对企业的需要，突出你的技能"><a href="#二、针对企业的需要，突出你的技能" class="headerlink" title="二、针对企业的需要，突出你的技能"></a>二、针对企业的需要，突出你的技能</h2><p>下一个问题是，项目经历应该怎么写，才能一眼打动企业的招聘人员？</p><p>大家要这么想，企业招聘的目的，是找到帮他解决问题的人，或者说，招聘帮他干活的人。如果你让他看到，你可以胜任他的工作，他就会想要你。</p><p>企业也没有把握什么人能胜任，他只能假设，如果你掌握了工作所需要的几种核心技能，就是初步合格的人选。</p><p>所以，企业在简历上寻找的，就是你有没有他需要的那几种技能。这才是招聘人员最关心的信息。 <strong>所以，简历应该突出的就是，你拥有企业想要的技能，你的经历证明你可以胜任。</strong></p><p><img src="https://up-img.yonghong.tech/pic/2020/10/01-12-21-bg2020010504-oHXOY5.jpg" alt="img"></p><p>企业想要的技能，往往是一些特定的技术。你应该在简历里面包括这些技术的关键字，而且要写得详细一点，不要只写技术的大类。比如，应聘 Java 岗位，就不要只写掌握 Java，而要写掌握 Spring 或者 Hibernate。</p><p>注意，写技术名词的时候，不要拼错单词，也不要写错大小写，比如把 jQuery 写成 Jquery，把 TypeScript 写成 Typescript，这会显得不专业。</p><h2 id="三、项目的三要素"><a href="#三、项目的三要素" class="headerlink" title="三、项目的三要素"></a>三、项目的三要素</h2><p>事实上，项目信息的写法有一个公式。</p><blockquote><p>项目 = 产品 + 技术 + 结果</p></blockquote><p>据说，谷歌要求应聘者描述经历时，每段经历必须提供下面三个信息：</p><blockquote><ul><li>做了什么产品</li><li>用到了什么技术</li><li>取得了什么结果</li></ul></blockquote><p>比如，”领导了 X 功能的开发，使其集成到 Y 产品，带来额外的 Z 收入”。</p><p><img src="https://up-img.yonghong.tech/pic/2020/10/01-12-21-bg2020010410-ihgfgO.jpg" alt="img"></p><p>除了三个基本信息，项目描述还要注意下面几点。</p><p>（1）主要介绍新项目，你过去3年～4年的经历最关键。不要详细描述较旧的项目。</p><p>（2）突出项目规模，比如用户数量、数据有多少 TB、每天的收入金额或交易量。</p><p>（3）最好都用动词开头，这样让人感到简洁有力。为了避免单调，动词也可以适当变化，”开发”、”实现”、”部署”、”完成”这些词都可以换着用。</p><h2 id="四、量化你的项目，给出数字"><a href="#四、量化你的项目，给出数字" class="headerlink" title="四、量化你的项目，给出数字"></a>四、量化你的项目，给出数字</h2><p>最后一点，每个项目的描述都需要量化，最好能给出数字。这能够大大提高简历的可信度和专业性，给招聘人员留下深刻印象。</p><p><img src="https://up-img.yonghong.tech/pic/2020/10/01-12-21-bg2020010411-UrRsi5.jpg" alt="img"></p><p>请看下面这些改写的例子，加入了量化，效果好了很多。</p><p>改写前：</p><blockquote><p>设计和实现 CRM 系统的 X 功能。</p></blockquote><p>改写后：</p><blockquote><p><strong>设计并实施了 X，这是 CRM 系统的一项新功能，可使2万名用户轻松跟踪他们的业务支出。</strong></p></blockquote><p>改写前：</p><blockquote><p>结合使用 OAuth 和 JavaScript，实现了社交网站登录和个人资料的自动填充。</p></blockquote><p>改写后：</p><blockquote><p><strong>通过使用 OAuth 和 JavaScript，实现了社交网站登录和个人资料自动填充，将网站的转化率提高了20％。</strong></p></blockquote><p>改写前：</p><blockquote><p>使用 Ajax 技术减少页面加载时间。</p></blockquote><p>改写后：</p><blockquote><p><strong>使用 Ajax 技术减少了30％的页面加载时间。</strong></p></blockquote><p>改写前：</p><blockquote><p>与同事合作，部署了一些 Web 应用程序，并排查故障。</p></blockquote><p>改写后：</p><blockquote><p><strong>与后端工程师团队合作，一起开发、部署、故障排查了7个的 Web 应用程序。</strong></p></blockquote><p>改写前：</p><blockquote><p>参与了将网站前端转为 React 框架的工作。</p></blockquote><p>改写后：</p><blockquote><p><strong>与一个同事合作，在一周内，将网站前端转换为 React 框架。</strong></p></blockquote><p>改写前：</p><blockquote><p>使用 Less 开发了一个客户端的全新 CSS 样式。</p></blockquote><p>改写后：</p><blockquote><p><strong>使用 Less 开发了一个客户端的全新 CSS 样式，使文件大小减少了70％，将首屏显示的时间减少了2倍。</strong></p></blockquote><h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>应聘 IT 行业，难度其实是不高的。因为整个行业非常缺工程师，尤其是中高级工程师。</p><p>企业自己也知道，不太容易招到水平很高的高级工程师。因为大家都在抢人，遇到合适的人选，出手稍慢，可能就被其他公司截走了。所以，只要你的水平能满足企业的最低要求，他们就愿意招你，至少会给面试机会。</p><p><img src="https://up-img.yonghong.tech/pic/2020/10/01-12-21-bg2020010412-BruItd.jpg" alt="img"></p><p>作为应聘者，你只要能证明自己具有合格的项目开发能力，就肯定可以很轻松地拿到 Offer。因此，你真正要做的是：提高自己的能力，多做项目。然后，按照上面的几点建议，把项目信息忠实地反映在简历上，就一定能够顺利地找到工作。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文转载自 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDIwLzAxL3RlY2huaWNhbC1yZXN1bWUuaHRtbA==&quot;&gt;如何写一份有效的技术简历？&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在找工作的程序员很多，都需要写简历。&lt;/p&gt;
&lt;p&gt;我见过很多简历，写得很糟糕，看不出这个人的亮点在哪里。一个人总是有亮点的，对不对。&lt;/p&gt;
&lt;p&gt;一些同学私下找我，让我帮忙修改简历。我在这里把自己的看法写出来，开发者的简历应该怎么写，效果最好。以后再有人找我，就让他看这篇文章。&lt;/p&gt;</summary>
    
    
    
    <category term="文案风格" scheme="http://yonghong.tech/categories/%E6%96%87%E6%A1%88%E9%A3%8E%E6%A0%BC/"/>
    
    
    <category term="文案风格" scheme="http://yonghong.tech/tags/%E6%96%87%E6%A1%88%E9%A3%8E%E6%A0%BC/"/>
    
    <category term="写作规范" scheme="http://yonghong.tech/tags/%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/"/>
    
    <category term="格式规范" scheme="http://yonghong.tech/tags/%E6%A0%BC%E5%BC%8F%E8%A7%84%E8%8C%83/"/>
    
    <category term="简历" scheme="http://yonghong.tech/tags/%E7%AE%80%E5%8E%86/"/>
    
    <category term="技术简历" scheme="http://yonghong.tech/tags/%E6%8A%80%E6%9C%AF%E7%AE%80%E5%8E%86/"/>
    
  </entry>
  
</feed>
