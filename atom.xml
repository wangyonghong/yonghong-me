<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>永红的互联网手记</title>
  
  <subtitle>我相信好代码和好产品改变世界！</subtitle>
  <link href="http://yonghong.tech/atom.xml" rel="self"/>
  
  <link href="http://yonghong.tech/"/>
  <updated>2021-07-09T14:24:00.000Z</updated>
  <id>http://yonghong.tech/</id>
  
  <author>
    <name>王永红(Micheal Wang)</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>看看大厂是如何用云原生解决千万视频会议难题的</title>
    <link href="http://yonghong.tech/2021/07/cloud-native-for-videoconferencing/"/>
    <id>http://yonghong.tech/2021/07/cloud-native-for-videoconferencing/</id>
    <published>2021-07-09T14:24:00.000Z</published>
    <updated>2021-07-09T14:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="腾讯：揭秘日活千万腾讯会议全量云原生化上TKE技术实践"><a href="#腾讯：揭秘日活千万腾讯会议全量云原生化上TKE技术实践" class="headerlink" title="腾讯：揭秘日活千万腾讯会议全量云原生化上TKE技术实践"></a>腾讯：揭秘日活千万腾讯会议全量云原生化上TKE技术实践</h2><p>文章链接：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTA0MTkyODMwNjAzMjcy">https://juejin.cn/post/6844904192830603272<i class="fa fa-external-link-alt"></i></span></p><p>本文总结了腾讯会议在TKE容器化部署时用到的平台相关特性，包括业务镜像自动分批灰度发布、ConfigMap分批灰度发布、Pod内A/B容器ms级切换发布、多集群发布管理、基于DynamicQuota的产品配额管理、探测节点和集群稳定性问题以提升自愈能力等。</p><h2 id="华为：远程办公利器华为云WeLink，如何练就硬核抗压能力？"><a href="#华为：远程办公利器华为云WeLink，如何练就硬核抗压能力？" class="headerlink" title="华为：远程办公利器华为云WeLink，如何练就硬核抗压能力？"></a>华为：远程办公利器华为云WeLink，如何练就硬核抗压能力？</h2><p>文章链接：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDYzODgxMzM=">https://zhuanlan.zhihu.com/p/106388133<i class="fa fa-external-link-alt"></i></span></p><p>业务快速增长带来的挑战聚焦在海量请求的冲击，从消息到语音模块、视频会议系统，华为云WeLink核心业务采用全容器化架构，结合华为云容器引擎单集群百万容器的超大规模支撑，可以迅速在新扩容的云服务器上启动业务，每秒最快可新增1000业务实例，大大降低了业务高峰时段的断线率、故障率和请求等待时长。更能通过瑶光的二次调度进行热点消除，保障计算资源压力的平均分布，助力业务平稳运行。</p><span id="more"></span><h2 id="字节：字节跳动容器化场景下的性能优化实践"><a href="#字节：字节跳动容器化场景下的性能优化实践" class="headerlink" title="字节：字节跳动容器化场景下的性能优化实践"></a>字节：字节跳动容器化场景下的性能优化实践</h2><p>文章链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY24vYXJ0aWNsZS9tdS0xYkZITm1yZGQwa3liZ1BYeA==">https://www.infoq.cn/article/mu-1bFHNmrdd0kybgPXx<i class="fa fa-external-link-alt"></i></span></p><p>字节跳动资源调度团队负责私有云平台 TCE 的底层 Kubernetes 集群的开发和维护工作。TCE 托管了头条、抖音、字节国际化业务等内部上万个在线微服务。随着这些业务的快速发展，集群规模不断扩大，机器负载越来越高，运维难度和成本问题越发显著。原生 Kubernetes 作为控制面系统，并不能很好地解决这些问题。为了提升系统可见性，我们基于 eBPF 实现了系统监控，使内核能更好地理解微服务，极大地提升了问题诊断效率。为提升资源利用率，我们通过动态超售，实现了业务实例的高密度部署，并通过优化 Kubernetes 资源模型，有效保证了延时敏感服务的 QoS。</p><h2 id="微软：Advancing-Microsoft-Teams-on-Azure—operating-at-pandemic-scale"><a href="#微软：Advancing-Microsoft-Teams-on-Azure—operating-at-pandemic-scale" class="headerlink" title="微软：Advancing Microsoft Teams on Azure—operating at pandemic scale"></a>微软：Advancing Microsoft Teams on Azure—operating at pandemic scale</h2><p>文章链接：<span class="exturl" data-url="aHR0cHM6Ly9henVyZS5taWNyb3NvZnQuY29tL2VuLXVzL2Jsb2cvYWR2YW5jaW5nLW1pY3Jvc29mdC10ZWFtcy1vbi1henVyZS1vcGVyYXRpbmctYXQtcGFuZGVtaWMtc2NhbGUv">https://azure.microsoft.com/en-us/blog/advancing-microsoft-teams-on-azure-operating-at-pandemic-scale/<i class="fa fa-external-link-alt"></i></span></p><h2 id="Zoom：Zoom-deploys-its-core-videoconferencing-service-on-Oracle-Cloud"><a href="#Zoom：Zoom-deploys-its-core-videoconferencing-service-on-Oracle-Cloud" class="headerlink" title="Zoom：Zoom deploys its core videoconferencing service on Oracle Cloud"></a>Zoom：Zoom deploys its core videoconferencing service on Oracle Cloud</h2><p>文章链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemRuZXQuY29tL2FydGljbGUvem9vbS1kZXBsb3lzLWl0cy1jb3JlLXZpZGVvY29uZmVyZW5jaW5nLXNlcnZpY2Utb24tb3JhY2xlLWNsb3VkLw==">https://www.zdnet.com/article/zoom-deploys-its-core-videoconferencing-service-on-oracle-cloud/<i class="fa fa-external-link-alt"></i></span></p><h2 id="声网：企业云原生创新与实践"><a href="#声网：企业云原生创新与实践" class="headerlink" title="声网：企业云原生创新与实践"></a>声网：企业云原生创新与实践</h2><p>视频链接：<span class="exturl" data-url="aHR0cHM6Ly95dW5xaS5hbGl5dW4uY29tLzIwMjAvc2Vzc2lvbjg4P2xpdmVJZD00NDE5MQ==">https://yunqi.aliyun.com/2020/session88?liveId=44191<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;腾讯：揭秘日活千万腾讯会议全量云原生化上TKE技术实践&quot;&gt;&lt;a href=&quot;#腾讯：揭秘日活千万腾讯会议全量云原生化上TKE技术实践&quot; class=&quot;headerlink&quot; title=&quot;腾讯：揭秘日活千万腾讯会议全量云原生化上TKE技术实践&quot;&gt;&lt;/a&gt;腾讯：揭秘日活千万腾讯会议全量云原生化上TKE技术实践&lt;/h2&gt;&lt;p&gt;文章链接：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTA0MTkyODMwNjAzMjcy&quot;&gt;https://juejin.cn/post/6844904192830603272&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本文总结了腾讯会议在TKE容器化部署时用到的平台相关特性，包括业务镜像自动分批灰度发布、ConfigMap分批灰度发布、Pod内A/B容器ms级切换发布、多集群发布管理、基于DynamicQuota的产品配额管理、探测节点和集群稳定性问题以提升自愈能力等。&lt;/p&gt;
&lt;h2 id=&quot;华为：远程办公利器华为云WeLink，如何练就硬核抗压能力？&quot;&gt;&lt;a href=&quot;#华为：远程办公利器华为云WeLink，如何练就硬核抗压能力？&quot; class=&quot;headerlink&quot; title=&quot;华为：远程办公利器华为云WeLink，如何练就硬核抗压能力？&quot;&gt;&lt;/a&gt;华为：远程办公利器华为云WeLink，如何练就硬核抗压能力？&lt;/h2&gt;&lt;p&gt;文章链接：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDYzODgxMzM=&quot;&gt;https://zhuanlan.zhihu.com/p/106388133&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;业务快速增长带来的挑战聚焦在海量请求的冲击，从消息到语音模块、视频会议系统，华为云WeLink核心业务采用全容器化架构，结合华为云容器引擎单集群百万容器的超大规模支撑，可以迅速在新扩容的云服务器上启动业务，每秒最快可新增1000业务实例，大大降低了业务高峰时段的断线率、故障率和请求等待时长。更能通过瑶光的二次调度进行热点消除，保障计算资源压力的平均分布，助力业务平稳运行。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://yonghong.tech/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://yonghong.tech/tags/MySQL/"/>
    
    <category term="UPDATE" scheme="http://yonghong.tech/tags/UPDATE/"/>
    
    <category term="数据库" scheme="http://yonghong.tech/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 08 —— JVM 垃圾回收器</title>
    <link href="http://yonghong.tech/java-advance/08-jvm-gc/"/>
    <id>http://yonghong.tech/java-advance/08-jvm-gc/</id>
    <published>2021-07-02T13:00:00.000Z</published>
    <updated>2021-07-02T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="垃圾回收器概述"><a href="#垃圾回收器概述" class="headerlink" title="垃圾回收器概述"></a>垃圾回收器概述</h2><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商，不同版本的 JVM 来实现。</p><p>由于 JDK 的版本处于高速迭代过程中，因此 Java 发展至今已经衍生了众多的 GC 版本。</p><span id="more"></span><p>从不同角度分析垃圾收集器，可以将 GC 分为不同的类型。</p><p>Java 不同版本的新特性需要关注的点：</p><ul><li>语法层面，Lambda表达式，switch 表达式，自动装箱、拆箱，enum，&lt;&gt;，…</li><li>API 层面：Stream API，新的时间日期，Optional，String，集合框架</li><li>底层优化：JVM 的优化，元空间，静态域，字符串常量池，GC 的变化，多语言的支持</li></ul><h2 id="垃圾回收器的分类"><a href="#垃圾回收器的分类" class="headerlink" title="垃圾回收器的分类"></a>垃圾回收器的分类</h2><ul><li><p>按线程数分，可以分为串行垃圾回收器（Serial Collector）和并行垃圾回收器（Parallel Collector）。</p><ul><li><p>串行回收指的是在同一时间段内只允许有一个 CPU 用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p></li><li><p>在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以串行回收器默认被应用在客户端的 Client 模式下的 JVM 中。</p></li><li><p>在并发能力比较强的 CPU 上，并行回收器产生的停顿时间要短于串行回收器。</p></li></ul></li><li><p>和串行回收相反，并行收集可以运用多个 CPU 同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了 STW 机制。</p></li><li><p>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。</p><ul><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li><li>独占式垃圾回收器一旦运行，就停止应用程序中的所有用于线程，直到垃圾回收过程完全结束。</li></ul></li><li><p>按碎片处理方式分，可以分为压缩式垃圾回收器和非压缩式垃圾回收器。</p><ul><li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。（再分配对象空间使用指针碰撞）</li><li>非压缩式的垃圾回收器不进行这步操作。（再分配对象空间使用空闲列表）</li></ul></li><li><p>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</p></li></ul><h2 id="评估-GC-的性能指标"><a href="#评估-GC-的性能指标" class="headerlink" title="评估 GC 的性能指标"></a>评估 GC 的性能指标</h2><ul><li><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例<ul><li>总运行时间：程序的运行时间 + 内存回收的时间</li></ul></li><li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li><li><strong>暂停时间</strong>：<strong>执行垃圾收集时，程序的工作线程被暂停的时间</strong>。</li><li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li><li><strong>内存占用</strong>：Java 堆区所占的内存大小。</li><li>快速：一个对象从诞生到被回收所经历的时间。</li></ul><p>吞吐量、暂停时间、内存占用，这三者共同构成一个不可能三角。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p><p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升有有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面的效果。</p><p>简单来说，主要抓住两点：<strong>吞吐量</strong>和<strong>暂停时间</strong>。</p><h3 id="吞吐量（throughput）"><a href="#吞吐量（throughput）" class="headerlink" title="吞吐量（throughput）"></a>吞吐量（throughput）</h3><p>吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）</p><ul><li>比如：虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%</li></ul><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p><p>吞吐量优先，意味着在单位时间内，STW 的时间最短：0.2 + 0.2 = 0.4</p><h3 id="暂停时间（pause-time）"><a href="#暂停时间（pause-time）" class="headerlink" title="暂停时间（pause time）"></a>暂停时间（pause time）</h3><p>暂停时间是指一个时间段内应用程序线程暂停，让 GC 线程执行的状态</p><ul><li>例如，GC 期间 100 毫秒的暂停时间意味着在这 100 毫秒期间内没有应用程序线程是活动的。</li></ul><p>暂停时间优先，意味着尽可能让单次 STW 的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5</p><h3 id="吞吐量-vs-暂停时间"><a href="#吞吐量-vs-暂停时间" class="headerlink" title="吞吐量 vs 暂停时间"></a>吞吐量 vs 暂停时间</h3><p>高吞吐量较好因为这会让应用程序的最终用户感觉到只有应用程序线程在做”生产性“工作。直觉上，吞吐量越高程序运行越快。</p><p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是 GC 还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的 200 毫秒暂停都可能打断终端用户体验。因此具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。</p><p>不幸的是 ”高吞吐量“ 和 ”低暂停时间“ 是一对相互竞争的目标（矛盾）。</p><ul><li>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致 GC 需要更长的暂停时间来执行内存回收。</li><li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li></ul><p>在设计（或使用）GC 算法时，我们必须确定我们的目标：一个 GC 算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折中。</p><p>现在标准：在最大吞吐量优先的情况下，降低停顿时间。 </p><h2 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h2><h3 id="垃圾收集器发展史"><a href="#垃圾收集器发展史" class="headerlink" title="垃圾收集器发展史"></a>垃圾收集器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是 Grabage Collection，对应的产品我们称为 Garbage Collector。</p><ul><li>1993 年随 JDK 1.3.1 一起来的是串行方式的 Serial GC，它是第一款 GC。ParNew 垃圾收集器是 Serial 收集器的多线程版本。</li><li>2002 年 2 月 26 日，Parallel GC 和 Concurrent Mark Sweep GC 跟随 JDK 1.4.2 一起发布。</li><li>Parallel GC 在 JDK 6 之后成为 HotSpot 默认 GC。</li><li>2012 年，在 JDK 1.7u4 版本中，G1 可用。</li><li>2017 年，JDK 9 中 G1 变成默认的垃圾收集器，以替代 CMS。</li><li>2018 年 3 月，JDK 10 中 G1 垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li><li>2018 年 9 月，JDK 11 发布。引入 Epsilon 垃圾回收器，又被称为 ”No-Op“（无操作）</li><li>2019 年 3 月，JDK 12 发布。增强 G1，自动返回未用堆内存给操作系统。同时，引入 Shenandoah GC，是一个低停顿时间的 GC（Experimental）。</li><li>2019 年 9 月，JDK 13 发布。增强 ZGC，自动返回未用堆内存给操作系统。</li><li>2020 年 3 月，JDK 14 发布。删除 CMS 垃圾回收器。拓展 ZGC 在 macOS 和 Windows 上的应用。</li></ul><h3 id="7-款经典的垃圾回收器"><a href="#7-款经典的垃圾回收器" class="headerlink" title="7 款经典的垃圾回收器"></a>7 款经典的垃圾回收器</h3><p>串行回收器：Serial、Serial Old</p><p>并行回收器：ParNew、Parallel Scavenge、Parallel Old</p><p>并发回收器：CMS、G1</p><h3 id="7-款经典的垃圾回收器与垃圾分代之间的关系"><a href="#7-款经典的垃圾回收器与垃圾分代之间的关系" class="headerlink" title="7 款经典的垃圾回收器与垃圾分代之间的关系"></a>7 款经典的垃圾回收器与垃圾分代之间的关系</h3><p>新生代收集器：Serial、ParNew、Parallel Scavenge</p><p>老年代收集器：Serial Old、Parallel Old、CMS</p><p>整堆垃圾收集器：G1</p><h3 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h3><p><img src="https://up-img.yonghong.tech/pic/2021/05/12-20-45-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB-BZidDy.png" alt="垃圾收集器的组合关系"></p><ul><li><p>两个收集器间有连线，表明它们可以搭配使用：</p><p>Serial / Serial Old 、Serial / CMS 、ParNew / Serial Old 、 ParNew / CMS 、Parallel Scavenge / Serial Old 、Parallel Scavenge / Parallel Old 、G1</p></li><li><p>其中 Serial Old 作为 CMS 出现 ”Concurrent Mode Failure“ 失败的后备预案。</p></li><li><p>（红色虚线）由于维护和兼容性测试的版本，在  JDK 8 时将 Serial + CMS、ParNew + Serial Old 这两个组合声明为废弃（JEP 173），并在 JDK 9 中完全取消了这些组合的支持（JEP 214），即，移除了这些组合。</p></li><li><p>（绿色虚线）JDK 14 中：弃用 Parallel Scavenge 和 Serial Old 组合（JEP 366）</p></li><li><p>（青色虚线）JDK 14中：删除 CMS 垃圾回收器（JEP 363）</p></li></ul><h3 id="如何查看默认的垃圾回收器"><a href="#如何查看默认的垃圾回收器" class="headerlink" title="如何查看默认的垃圾回收器"></a>如何查看默认的垃圾回收器</h3><p><code>-XX:+PrintCommandLineFlags</code> 查看命令行相关参数（包含使用的垃圾收集器）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure><p>使用命令行指令： jinfo -flag 相关垃圾回收器参数 进程 ID</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jinfo -flag UseParallelGC 58951</span></span><br><span class="line">-XX:-UseParallelGC</span><br><span class="line"><span class="meta">$</span><span class="bash"> jinfo -flag UseParallelOldGC 58951</span></span><br><span class="line">-XX:-UseParallelOldGC</span><br><span class="line"><span class="meta">$</span><span class="bash"> jinfo -flag UseG1GC 58951</span></span><br><span class="line">-XX:-UseG1GC</span><br><span class="line"><span class="meta">$</span><span class="bash"> jinfo -flag UseConcMarkSweepGC 58951</span></span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure><h2 id="垃圾回收器介绍"><a href="#垃圾回收器介绍" class="headerlink" title="垃圾回收器介绍"></a>垃圾回收器介绍</h2><h3 id="Serial-回收器：串行回收"><a href="#Serial-回收器：串行回收" class="headerlink" title="Serial 回收器：串行回收"></a>Serial 回收器：串行回收</h3><p>Serial 收集器是最基本、历史最悠久的垃圾收集器了。JDK 1.3 之前回收新生代唯一的选择。</p><p>Serial 收集器作为 HotSpot 中 Client 模式下的默认新生垃圾收集器。</p><p>Serial 收集器采用复制算法、串行回收和 STW 机制的方式执行内存回收。</p><p>除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。Serial Old 收集器同样也采用了串行回收和 STW 机制，只不过内存回收算法使用的是标记-压缩算法。</p><ul><li>Serial Old 是运行在 Client 模式下默认的老年代的垃圾回收器。</li><li>Serial Old 在 Server 模式下主要有两个用途：①与新生代的 Parallel Scavenge 配合使用 ②作为老年代 CMS 收集器的后备垃圾收集方案。</li></ul><p>这个收集器是一个单线程的收集器，但它的 ”单线程“ 的意义并不仅仅说明它<strong>只会使用一个 CPU 或一条收集线程去完成垃圾收集工作</strong>，更重要的是在它进行垃圾收集时，<strong>必须暂停其他所有的工作线程</strong>，直到它收集结束。</p><p>优势：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p><ul><li>运行在 Client 模式下的虚拟机是个不错的选择。</li></ul><p>在用户的桌面应用场景中，可用内存一般不大（几十 MB 至一两百 MB），可以在较短时间内完成垃圾回收（几十 ms 至一百多 ms），只要不频繁发生，使用串行回收器是可以接受的。</p><h4 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h4><p>在 HotSpot 虚拟机中，使用 <code>-XX:UseSerialGC</code> 参数可以指定年轻代和老年代都是用串行收集器。</p><ul><li>等价于新生代使用 Serial GC，且老年代使用 Serial Old GC。</li></ul><p>总结：这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核 CPU 才可以用。现在都不是单核的了。</p><p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在 Java Web 应用程序中是不会采用串行垃圾收集器的。</p><h3 id="ParNew-回收器：并行回收"><a href="#ParNew-回收器：并行回收" class="headerlink" title="ParNew 回收器：并行回收"></a>ParNew 回收器：并行回收</h3><p>如果说 Serial GC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本。</p><ul><li>Par 是 Parallel 的缩写，New：只能处理的是新生代</li></ul><p>ParNew 收集器除了采用<strong>并行回收</strong>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew 收集器在年轻代中同样也是<strong>采用复制算法、STW 机制</strong>。</p><p>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器。</p><ul><li>对于新生代，回收次数频繁，使用并行方式高效。</li><li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li></ul><p>由于 ParNew 收集器是基于并行回收，那么是否可以断定 ParNew 收集器的回收效率在任何场景下都会比 Serial 收集器更高效？</p><ul><li>ParNew 收集器运行在多 CPU 环境下，由于可以充分利用多 CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li><li>但是在单个 CPU 的环境下，ParNew 收集器不比 Serial 收集器更高效。虽然 Serial 收集器是基于串行回收，但是由于 CPU 不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li></ul><p>除 Serial 外，目前只有 ParNew GC 能与 CMS 收集器配合工作。</p><h4 id="参数配置-1"><a href="#参数配置-1" class="headerlink" title="参数配置"></a>参数配置</h4><p>在程序中，开发人员可以通过选项 <code>-XX:+UseParNewGC</code> 手动指定使用 ParNew 收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p><p><code>-XX:ParallelGCThreads</code> 限制线程数量，默认开启和 CPU 数相同的线程数。</p><h3 id="Parallel-回收器：吞吐量优先"><a href="#Parallel-回收器：吞吐量优先" class="headerlink" title="Parallel 回收器：吞吐量优先"></a>Parallel 回收器：吞吐量优先</h3><p>HotSpot 的年轻代中除了拥有 ParNew 收集器是基于并行回收以外，Parallel Scavenge 收集器同样也采用了复制算法、并行回收和 STW 机制。</p><p>那么 Parallel 收集器的出现是否多此一举？</p><ul><li>和 ParNew 收集器不同，Parallel Scavenge 收集器的目标是达到一个<strong>可控的吞吐量</strong>（Throughput），它也被称为吞吐量优先的垃圾收集器。</li><li>自适应调节策略也是 Parallel Scavenge 与 ParNew 的一个重要区别。</li></ul><p>高吞吐量则可以高效地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p><p>Parallel 收集器在 JDK 1.6 时提供了用于执行老年代垃圾收集的 Parallel Old 收集器，用来代替老年代的 Serial Old 收集器。</p><p>Parallel Old 收集器采用了<strong>标记-压缩算法</strong>，但同样也是基于<strong>并行回收</strong>和 STW 机制。</p><p>在吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错。</p><p>在 Java 8 中，默认也是此垃圾收集器。</p><h4 id="参数配置-2"><a href="#参数配置-2" class="headerlink" title="参数配置"></a>参数配置</h4><ul><li><code>-XX:+UserParallelGC</code> 手动指定年轻代使用 Parallel 并行收集器执行内存回收任务。</li><li><code>-XX:+UseParallelOld</code> 手动指定老年代都是使用并行回收收集器。<ul><li>上面两个参数，分别适用于新生代和老年代。默认 JDK 8 是开启的。</li><li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li></ul></li><li><code>-XX:ParallelGCTheads</code> 设置年轻代并行收集器的线程数。一般地，最好与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能。<ul><li>在默认情况下，当 CPU 数量小于 8 个，ParallelGCThreads 的值等于 CPU 数量。</li><li>当 CPU 数量大于 8 个，ParallelGCThreads 的值等于 <code>3 + ((5 * CPU_COUNT) / 8 )</code>。</li></ul></li><li><code>-XX:MaxGCPauseMillis</code> 设置垃圾收集器最大停顿时间（即 STW 的时间）。单位是毫秒。<ul><li>为了尽可能地把停顿时间控制在 MaxGCPauseMillis 以内，收集器在工作时会调整 Java 堆大小或者其他一些参数。</li><li>对于用户来讲，停顿时间越短体验越好。但是在服务端，我们注重高并发，整体的吞吐量。所以服务器端适合 Parallel，进行控制</li><li><strong>该参数使用需要谨慎。</strong></li></ul></li><li><code>-XX:GCTimeRatio</code> 垃圾收集时间占总时间的比例（= 1 / (N + 1)）。用于衡量吞吐量的大小。<ul><li>取值范围（0, 100）。默认值 99，也就是垃圾回收时间不超过 1%。</li><li>与前一个 <code>-XX:MaxGCPauseMillis</code> 参数有一定的矛盾性。暂停时间越长，Radio 参数就容易超过设定的比例。</li></ul></li><li><code>-XX:+UseAdaptiveSizePolicy</code> 设置 Parallel Scavenge 收集器具有自适应调节策略。<ul><li>在这种模式下，年轻代的大小，Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。</li><li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调度工作。</li></ul></li></ul><h3 id="CMS-回收器：低延迟"><a href="#CMS-回收器：低延迟" class="headerlink" title="CMS  回收器：低延迟"></a>CMS  回收器：低延迟</h3><p>在 JDK 1.5 时期，HotSpot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是 HotSpot 虚拟中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</p><p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><ul><li>目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。</li></ul><p>CMS 的垃圾收集算法采用 标记-清除 算法，并且也会 STW。</p><p>不幸的是，CMS 作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 收集器配合工作，所以在 JDK 1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。</p><p>在 G1 出现之前，CMS 使用还是非常广泛的，一直到今天，任然有很多系统使用 CMS GC。</p><h4 id="CMS-工作原理"><a href="#CMS-工作原理" class="headerlink" title="CMS 工作原理"></a>CMS 工作原理</h4><p>CMS 整个过程比之前的收集器要复杂，整个过程分为 4 个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段、并发清除阶段。</p><ul><li>初始标记（Initial-Mark）阶段：在这个阶段中，程序用所有的工作线程都将会因为 STW 机制而出现短暂的暂停，这个阶段的主要任务<strong>仅仅是标记出 GC Roots 能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<strong>速度非常快</strong>。</li><li>并发标记（Concurrent-Mark）阶段：<strong>从 GC Roots 的直接关联对象开始遍历整个对象图的过程</strong>，这个过程<strong>耗时较长</strong>但是<strong>不需要停顿用户线程</strong>，可以与垃圾收集线程一起并发运行。</li><li>重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或交叉运行，因此为了<strong>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li>并发清除（Concurrent-Sweep）阶段：此阶段<strong>清理删除掉标记阶段的已经死亡的对象，释放内存空间</strong>。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li></ul><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>尽管 CMS 收集器采用的是并发回收（非独占式），但是在其<strong>初始化标记和再次标记这两个阶段中仍然需要执行 STW 机制暂停程序中的工作线程</strong>，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要 STW，只是尽可能的缩短暂停时间。</p><p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低延迟的。</p><p>另外，由于在垃圾收集阶段用户线程没有中断，所以在 CMS 回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了在进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在 CMS 工作过程中依然有足够的内存空间支持应用程序运行。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次 ”Concurrent Mode Failure“ 失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p><p>CMS 收集器的垃圾收集算法采用的是 标记-清除 算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能选择空闲列表（Free List）执行内存分配。</p><p>有人会觉得既然 Mark Sweep 会造成内存碎片，那么为什么不把算法换成 Mark Compact 呢？</p><p>答案其实很简单，因为当并发清除的时候，用 Compact 整理内存的话，原来的用户线程使用的内存还怎么用？要保证用户线程能继续执行，前提得是它运行的资源不受影响。Mark Compact 更适合 STW 这种场景下使用。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>并发收集</li><li>低延迟</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发 Full GC。</li><li>对 CPU 资源非常敏感，在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li><li>无法处理浮动垃圾，可能会出现 ”Concurrent Mode Failure“ 失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间。</li></ul><h4 id="参数配置-3"><a href="#参数配置-3" class="headerlink" title="参数配置"></a>参数配置</h4><ul><li><code>-XX:+UseConcMarkSweepGC</code> 手动指定使用 CMS 收集器执行内存回收任务。<ul><li>开启该参数后会自动将 <code>-XX:+UseParNewGC</code> 打开。即：年轻代使用 ParNew 收集器 + 老年代使用 CMS 收集器 + 老年代的备用收集器 Serial Old 收集器</li></ul></li><li><code>-XX:CMSInitiatingOccupanyFraction</code> 设置堆内存使用率的阈值，一旦到达该阈值，便开始进行回收。<ul><li>JDK 5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68% 时，会执行一次 CMS 回收。JDK 6 及以上的版本默认值为 92%。</li><li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低 Full GC 的执行次数。</li></ul></li><li><code>-XX:+UseCMSCompactAtFullCollection</code> 用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</li><li><code>-XX:CMSFullGCsBeforeCompaction</code> 设置在执行多少次 Full GC 后对内存空间进行压缩整理。</li><li><code>-XX:ParallelCMSThreads</code> 设置 CMS 的线程数量。<ul><li>CMS 默认启动的线程数是 （ParallelCMSThreads + 3） / 4</li><li>ParallelCMSThreads 是年轻代并行收集器（ParNew）的线程数。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ul></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>HotSpot 有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、CMS GC 这三个 GC 有什么不同呢？</p><ul><li>如果你想要最小化地使用内存和并行开销，请选择 Serial GC</li><li>如果你想要最大化应用程序的吞吐量，请选择 Parallel GC</li><li>如果你想要最小化 GC 的中断或停顿时间，请选择 CMS GC</li></ul><p>JDK 9 新特性：CMS 被标记为 Deprecate 了（JEP291）</p><ul><li>如果对 JDK 9 及以上版本的 HotSpot 虚拟机使用参数 <code>-XX:+UseConcMarkSweepGC</code> 来开启 CMS 收集器的话，用户会收到一个警告信息，提示 CMS 为了将会被去除。</li></ul><p>JDK 14 新特性：去除 CMS 垃圾收集器（JEP363）</p><ul><li>移除了 CMS 垃圾收集器，如果在 JDK 14 中使用 <code>-XX:+UseConcMarkSweepGC</code> 的话，JVM 不会报错，只是给出警告，但是不会退出。JVM 会自动使用默认的 GC。</li></ul><h3 id="G1-回收器：区域化分代式"><a href="#G1-回收器：区域化分代式" class="headerlink" title="G1 回收器：区域化分代式"></a>G1 回收器：区域化分代式</h3><p><strong>1.既然我们已经有了前面几个强大的 GC，为什么还要发布 Garbage First（G1）GC？</strong></p><p>原因就在于对于应用程序所应用的<strong>业务越来越庞大、复杂，用户越来越多</strong>，没有 GC 就不能保证应用程序正常进行，而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。G1（Garbage First）垃圾回收器是在 Java 7 Update 4 之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p><p>与此同时，为了适应现在<strong>不断扩大的内存和不断增加的处理器数量</strong>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p><p><strong>官方给 G1 设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起”全功能收集器“的重任与期望。</strong></p><p><strong>2.为什么名字叫做 Garbage First（G1）呢？</strong></p><p>因为 G1 是一个并行回收器，它把堆内存分割成很多不相关的区域（Region）（物理上不连续的）。使用不同的 Region 来表示 Eden、Survivor0、Survivor1、老年代等。</p><p>G1 GC 有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的 Region</strong>。</p><p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给 G1 一个名字：垃圾优先（Garbage First）。</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>G1（Garbage First）是一款面向服务端应用的垃圾收集器，主要针对配备多核 CPU 及大容量内存的机器，以极高概率满足 GC 停顿时间的同时，还兼具高吞吐量的性能特征。</p><p>在 JDK 1.7 版本正式启用，移除了 Experimental 的标识，是 JDK 9 以后的默认垃圾回收器，取代了 CMS 回收器以及 Parallel + Parallel Old 组合。被 Oracle 官方称为 ”全功能的垃圾收集器“。</p><p>与此同时，CMS 已经在 JDK 9 中被标记为废弃（Deprecated）。在  JDK 8 中还不是默认的垃圾回收器，需要使用 <code>-XX:+UseG1GC</code> 来使用。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>与其他的 GC 收集相比，G1 使用了全新的<strong>分区算法</strong>，其特定如下所示：</p><ul><li><strong>并行与并发</strong><ul><li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力。此时用户线程 STW</li><li>并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。</li></ul></li><li><strong>分代收集</strong><ul><li>从分代上看，<strong>G1 依然属于分代型垃圾回收器</strong>，它会区分年轻代和老生代，年轻代依然有 Eden 区和 Survivor 区。但从堆的结构上看，它不要求整个 Eden 区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将<strong>堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代</strong>。</li><li>和之前的各类回收器不同，它同时<strong>兼顾年轻代和老年代</strong>。对比其他回收器，或者工作在年轻代，或者工作在老年代。</li></ul></li><li><strong>空间整合</strong><ul><li>CMS：”标记-清除“ 算法、内存碎片、若干次 GC 后进行一次碎片整理</li><li>G1 将内存划分成为一个个的 Region。内存的回收是以 Region 作为基本单位的。<strong>Region 之间是复制算法</strong>，但整体上实际可看做是<strong>标记-压缩（Mark-Compact）算法</strong>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当 Java 堆非常大的时候，G1 的优势更加明显。</li></ul></li><li><strong>可预测的停顿时间模型</strong>（即软实时 soft real-time）<ul><li>这是 G1 相对于 CMS 的另一大优势，G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。<ul><li>由于分区的原因，G1 可以只选择部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的 Region。</strong>保证了 G1 收集器在有限的时间内可以<strong>获取尽可能高的收集效率。</strong></li><li>相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延迟停顿，但是最差情况要好很多。</li></ul></li></ul></li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比 CMS 要高。</p><p>从经验上说，在小内存应用上 CMS 的表现大概率会优于 G1，而  G1 在大内存应用上则发挥其优势。平衡点在 6-8 GB 之间。</p><h4 id="参数配置-4"><a href="#参数配置-4" class="headerlink" title="参数配置"></a>参数配置</h4><ul><li><code>-XX:+UseG1GC</code> 手动指定使用 G1 收集器执行内存回收任务。JDK 9 及以后默认开启。</li><li><code>-XX:G1HeapRegionSize</code> 设置每个 Region 的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域。默认是堆内存的 1/2000。</li><li><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大 GC 停顿时间指标（JJVM 会尽力实现，但不保证达到）。默认值是 200 ms。</li><li><code>-XX:ParallelGCThread</code> 设置 STW 工作线程数的值。最多设置为 8。</li><li><code>-XX:ConcGCThreads</code>设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1/4 左右。</li><li><code>-XX:InitiatingHeapOccupanyPercent</code> 设置触发并发 GC 周期的 Java 堆占用率阈值。超过此值，就触发 GC。默认值是 45。</li></ul><h4 id="常见操作步骤"><a href="#常见操作步骤" class="headerlink" title="常见操作步骤"></a>常见操作步骤</h4><p>G1 的设计原则就是简化 JVM 性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li>第一步，开启 G1 垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li></ul><p>G1 中提供了三种垃圾回收模式：Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</li><li>最主要的应用是需要低 GC 延迟，并具有大堆的应用程序提供解决方案</li><li>如：在堆大小约 6GB 或更大时，可预测的暂停时间可以低于 0.5 秒；G1 通过每次只清理一部分而不是全部的 Region 的增量式清理来保证每次 GC 停顿时间不会太长。</li><li>用来替换掉 CMS 收集器，在下面的情况时，使用 G1 可能比 CMS 好：<ul><li>超过 50% 的 Java 堆被活动数据占用</li><li>对象分配频率或年代提升频率变化很大</li><li>GC 停顿时间过长（长于 0.5 至 1 秒）</li></ul></li><li>HotSpot 垃圾收集器里，除了 G1 以外，其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，即当 JVM 的 GC 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。（啥意思？）</li></ul><h4 id="分区-Region：化整为零"><a href="#分区-Region：化整为零" class="headerlink" title="分区 Region：化整为零"></a>分区 Region：化整为零</h4><p>使用 G1 收集器时，它将整个 Java 堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32 MB 之间，且为 2 的 N 次幂，即 1 MB，2 MB，4 MB，8 MB，16 MB，32 MB。可以通过 <code>-XX:G1HeapRegionSize</code> 设定。所有的 Region 大小相同，且在 JVM 生命周期内不会被改变。</p><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。通过 Region 的动态分配方式实现逻辑上的连续。</p><p>一个 Region 有可能属于 Eden、Survivor 或者 Old/Tenured 内存区域。但是一个 Region 只可能属于一个角色。图中的 E 表示该 Region 属于 Eden 内存区域，S 表示属于 Survivor 内存区域，O 表示属于 Old 内存区域。图中空白的表示未使用的内存空间。</p><p>G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H 块。主要用于存储大对象，如果超过一个 Region 的50%，就放到 H。（这里老师讲解有误，在《JVM G1源码分析和调优》书中写到：对于大对象分为两类，一类是大于HeapRegionSize的一半，但是小于HeapRegionSize，即一个完整的堆分区可以保存，则直接从空闲列表直接拿一个堆分区，或者分配一个新的堆分区。如果是连续对象，则需要多个堆分区，思路同上，但是处理的时候需要加锁。）</p><p>设置 H 的原因：</p><p>对于堆中的大对象，默认直接会分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放大对象。<strong>如果一个 H 区装不下一个大对象，那么 G1 会寻找连续的 H 区来存储。</strong>为了能找到连续的 H 区，有时候不得不启用 Full GC。G1 的大多数行为都把 H 区作为老年代的一部分来看待。</p><h4 id="垃圾回收过程"><a href="#垃圾回收过程" class="headerlink" title="垃圾回收过程"></a>垃圾回收过程</h4><p>G1 GC 的垃圾回收过程主要包括如下三个环节：</p><ul><li>年轻代 GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC）</li><li>（如果需要，单线程、独占式、高强度的 Full GC 还是继续存在的。它针对 GC 的评估失败提供了一种失败保护机制，即强力回收。）</li></ul><p>Young GC → Young GC + Concurrent Marking → Mixed GC → Full GC</p><p>应用程序分配内存，<strong>当年轻代的 Eden 区用尽时开始年轻代回收过程</strong>；G1 年轻代收集阶段是一个<strong>并行</strong>的<strong>独占式</strong>收集器。在年轻代回收期，G1 GC 暂停所有应用程序线程，启动所线程执行年轻代回收。然后<strong>从年轻代区间移动存活对象到 Survivor 区间或者老年代区间，也有可能是两个区间都会涉及</strong>。</p><p>当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程。</p><p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC 从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的 G1 回收器和其他 GC 不同<strong>，G1 的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的 Region 就可以了</strong>。同时，这个老年代 Region 是和年轻代一起被回收的。</p><p>举个例子：一个 Web 服务器，Java 进程最大堆内存为 4 G，每分钟响应 1500 个请求，每 45 秒钟会新分配大约 2 G 内存。G1 会每 45 秒钟进行一次年轻代回收，每 31 个小时整个堆的使用率会达到 45 %，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p><h5 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a>Remembered Set</h5><ul><li>一个对象被不同区域引用的问题</li><li>一个 Region 不可能是孤立的，一个 Region 中的对象可能被其他任意 Region 中的对象引用，判断对象存活时，是否需要扫描整个 Java 堆才能保证准确？</li><li>在其他的分代收集器，也存在这样的问题（而 G1 更突出）</li><li>回收新生代也不得不同时扫描老年代？</li><li>这样的话会降低 Minor GC 的效率</li></ul><p>解决方法：</p><ul><li>无论 G1 还是其他分代收集器，JVM 都是使用 Remembered Set 来避免全局扫描；</li><li>每个 Region 都有一个对应的 Remembered Set；</li><li>每次 Reference 类型数据写操作时，都会产生一个写屏障（Write Barrier）暂时中断操作；</li><li>然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的 Region（其他收集器：检查老年代对象是否引用了新生代对象）；</li><li>如果不同，通过 CardTable（Remembered Set 的实现） 把相关引用信息记录到引用指向对象所在 Region 对应的 Remembered Set 中；</li><li>当进行垃圾收集时，在 GC Roots 的枚举范围加入 Remembered Set，就可以保证不进行全局扫描，也不会有遗漏。</li></ul><h4 id="垃圾回收过程一：年轻代回收过程"><a href="#垃圾回收过程一：年轻代回收过程" class="headerlink" title="垃圾回收过程一：年轻代回收过程"></a>垃圾回收过程一：年轻代回收过程</h4><p>JVM 启动时，G1 先准备好 Eden 区，程序在运行过程中不断创建对象到 Eden 区，当 Eden 空间耗尽时，G1 会启动一次年轻代垃圾回收过程。</p><p>年轻代垃圾回收只会收集 Eden 区和 Survivor 区。</p><p>YGC 时，首先 G1 停止应用程序的执行（STW），G1 创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代 Eden 区和 Survivor 区所有的内存分段。</p><p>然后开始如下回收过程：</p><ul><li><p><strong>第一阶段，扫描根。</strong></p><p>根是指 static 变量指向的对象，正在执行的方法调用链上的局部变量等。根引用连同 RSet 记录的外部引用作为扫描存活对象的入口。</p></li><li><p><strong>第二阶段，更新 RSet。</strong></p><p>处理 Dirty Card Queue 中的 card，更新 RSet。此阶段完成后，<strong>RSet 可以准确的反映老年代对所在的内存分段中对象的引用。</strong></p></li><li><p><strong>第三阶段：处理 RSet。</strong></p><p>识别被老年代对象所指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象。</p></li><li><p><strong>第四阶段：复制对象。</strong></p><p>此阶段，对象树被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的内存分段，Survivor 区内存段中存活的对象如果年龄未达到阈值，年龄会加 1，达到阈值会被复制到 Old 区中的内存分段，如果 Survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间。</p></li><li><p><strong>第五阶段：处理引用。</strong></p><p>处理 Soft、Weak、Phantom、Final、JNI Weak 等引用（这里可能描述不准确）。最终 Eden 空间的数据为空，GC 停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p></li></ul><p>注：对于应用程序的引用赋值语句 object.fieled = object，JVM 会在之前和之后执行特殊的操作以在 Dirty Card Queue 中入队一个保存了对象引用信息的 card，在年轻代回收的时候，G1 会对 Dirty Card Queue 中所有的 card 进行处理，以更新 RSet，保证 RSet 实时准确的反映引用关系。</p><p>那为什么不在引用赋值语句处直接更新 RSet 呢？这是为了性能的需要，RSet 的处理需要线程同步，开销会很大，使用队列性能会好很多。</p><h4 id="垃圾回收过程二：老年代并发标记过程"><a href="#垃圾回收过程二：老年代并发标记过程" class="headerlink" title="垃圾回收过程二：老年代并发标记过程"></a>垃圾回收过程二：老年代并发标记过程</h4><ul><li><strong>1.初始标记过程（STW）</strong>：标记从根节点直接可达的对象。这个阶段是 STW 的，并且会触发一次年轻代 GC。</li><li><strong>2.根区域扫描（Root Region Scanning）</strong>：G1 GC 扫描 Survivor 区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在 Young GC 之前完成。</li><li><strong>3.并发标记（Concurrent Marking）</strong>：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被 Young GC 中断。在并发标记阶段，若发现区域对象中所有的对象都是垃圾，那这个区域会被立即回收（实时回收）。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li><strong>4.再次标记（Remark,STW）</strong>：由于应用程序持续进行，需要修正上一次的标记结果。是 STW 的。G1 中采用了比 CMS 更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li><li><strong>5.独占清理（cleanup,STW）</strong>:计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是 STW 的。</li><li><strong>6.并发清理阶段</strong>：识别并清理完全空闲的区域</li></ul><h4 id="垃圾回收过程三：混合回收过程"><a href="#垃圾回收过程三：混合回收过程" class="headerlink" title="垃圾回收过程三：混合回收过程"></a>垃圾回收过程三：混合回收过程</h4><p>当越来越多的对象晋升到老年代 Old Region 时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，该算法并不是一个 Old GC，除了回收整个 Young Region，还会回收一部分的 Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些 Old Region 进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC 并不是 Full GC。</p><ul><li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过 <code>-XX:G1MixedGCCountTarget</code> 设置）被回收。</li><li>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden 区内存分段，Survivor 区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li><li>由于老年代中的内存分段默认分8次回收，G1 会优先回收垃圾多的内存分段。<strong>垃圾占内存分段比例越高的，越会被先回收。</strong>并且有一个阈值会决定内存分段是否被回收。<code>-XX:G1MixedGCLiveThresholdPercent</code> ，默认为 65%，意思是垃圾占内存分段比例要达到 65% 才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</li><li>混合回收并不一定要进行 8 次。有一个阈值 <code>-XX:G1HeapWastePercent</code>，默认值为 10%，意思是允许整个堆内存中有 10% 的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于 10%，则不再进行混合回收。因为 GC 会花费很多的时间但是回收到的内存却很少。</li></ul><h4 id="垃圾回收可选过程四：Full-GC"><a href="#垃圾回收可选过程四：Full-GC" class="headerlink" title="垃圾回收可选过程四：Full GC"></a>垃圾回收可选过程四：Full GC</h4><p>G1的初衷就是要避免 Full GC 的出现。但是如果上述方式不能正常工作，G1 会停止应用程序的执行（Stop-The-World），使用<strong>单线程</strong>的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p><p>要避免 Full GC 的发生，一旦发生 Full GC，需要对JVM参数进行调整。什么时候会发生 Full GC 呢？比如堆内存太小，当 G1 在复制存活对象的时候没有空的内存分段可用，则会回退到 Full GC，这种情况可以通过增大内存解决。</p><p>导致 G1 Full GC 的原因可能有两个：</p><ul><li>Evacuation 的时候没有足够的 To Space 来存放晋升的对象；</li><li>并发处理过程完成之前空间耗尽。</li></ul><h4 id="G1-补充"><a href="#G1-补充" class="headerlink" title="G1 补充"></a>G1 补充</h4><p>从 Oracle 官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到 G1 只是回一部分 Region，停顿时间是用户可控制的，所以并不迫切去实现，<strong>而选择把这个特性放到了 G1 之后出现的低延迟垃圾收集器（即 ZGC）中。</strong>另外，还考虑到 G1 不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。 </p><h4 id="G1-回收器的优化建议"><a href="#G1-回收器的优化建议" class="headerlink" title="G1 回收器的优化建议"></a>G1 回收器的优化建议</h4><ol><li>年轻代大小<ul><li>避免使用 -Xmn 或 -XX:NewRatio 等相关选项显式设置年轻代大小，因为固定年轻代的大小会覆盖可预测的暂停时间目标。我们让 G1 自己去调整</li></ul></li><li>暂停时间目标不要太过严苛<ul><li>G1 GC 的吞吐量目标是 90% 的应用程序时间和 10% 的垃圾回收时间</li><li>评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul></li></ol><h2 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h2><p>截止 JDK 1.8，一共有 7 款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p><table><thead><tr><th>垃圾收集器</th><th>分类</th><th>作用位置</th><th>使用算法</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>Serial</td><td>串行运行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>适用于单 CPU 环境下的 Client 模式</td></tr><tr><td>ParNew</td><td>并行运行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>多 CPU 环境 Server 模式下与 CMS 配合使用</td></tr><tr><td>Parallel</td><td>并行运行</td><td>新生代</td><td>复制算法</td><td>吞吐量优先</td><td>适用于后台运算而不需要太多交互的场景</td></tr><tr><td>Serial Old</td><td>串行运行</td><td>老年代</td><td>标记-压缩算法</td><td>响应速度优先</td><td>适用于单 CPU 环境下的 Client 模式</td></tr><tr><td>Parallel Old</td><td>并行运行</td><td>老年代</td><td>标记-压缩算法</td><td>吞吐量优先</td><td>适用于后台运算而不需要太多交互的场景</td></tr><tr><td>CMS</td><td>并发运行</td><td>老年代</td><td>标记-清除算法</td><td>响应速度优先</td><td>适用于互联网或 B/S 业务</td></tr><tr><td>G1</td><td>并发、并行运行</td><td>新生代、老年代</td><td>标记-压缩算法、复制算法</td><td>响应速度优先</td><td>面向服务端应用</td></tr></tbody></table><p>GC 发展阶段</p><p>Serial → Parallel → CMS → G1 → ZGC</p><h3 id="怎么选择垃圾回收器"><a href="#怎么选择垃圾回收器" class="headerlink" title="怎么选择垃圾回收器"></a>怎么选择垃圾回收器</h3><p>Java 垃圾收集器的配置对于 JVM 优化来说是一个很重要的选择，选择合适的垃圾收集器可以让 JVM 的性能有一个很大的提升。怎么选择垃圾收集器？</p><ol><li>优先调整堆的大小让 JVM 自适应完成。</li><li>如果内存小于 100M，使用串行收集器</li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li><li>如果是多 CPU、需要高吞吐量、允许停顿时间超过 1 秒，选择并行或者 JVM 自己选择</li><li>如果是多 CPU、追求低停顿时间，需快速响应（比如延迟不能超过 1 秒，如互联网应用），使用并发收集器</li><li>官方推荐 G1，性能高。现在互联网的项目，基本都是使用 G1。</li></ol><p>最后需要明确一个观点：</p><ol><li>没有最好的收集器，更没有万能的收集算法</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ol><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><ol><li>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。这里较通用、基础性的部分如下：<ul><li>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</li><li>垃圾收集器工作的基本流程。</li></ul></li><li>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</li></ol><h2 id="GC-日志分析"><a href="#GC-日志分析" class="headerlink" title="GC 日志分析"></a>GC 日志分析</h2><h3 id="GC-日志参数设置"><a href="#GC-日志参数设置" class="headerlink" title="GC 日志参数设置"></a>GC 日志参数设置</h3><p><strong>通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略。</strong></p><p>内存分配与垃圾回收的参数列表</p><ol><li>-XX:+PrintGC ：输出GC日志。类似：-verbose:gc</li><li>-XX:+PrintGCDetails ：输出GC的详细日志</li><li>-XX:+PrintGCTimestamps ：输出GC的时间戳（以基准时间的形式）</li><li>-XX:+PrintGCDatestamps ：输出GC的时间戳（以日期的形式，如2013-05-04T21: 53: 59.234 +0800）</li><li>-XX:+PrintHeapAtGC ：在进行GC的前后打印出堆的信息</li><li>-Xloggc:…/logs/gc.log ：日志文件的输出路径</li></ol><h3 id="GC-日志查看工具"><a href="#GC-日志查看工具" class="headerlink" title="GC 日志查看工具"></a>GC 日志查看工具</h3><p>GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat 等</p><h3 id="GC-日志补充说明"><a href="#GC-日志补充说明" class="headerlink" title="GC 日志补充说明"></a>GC 日志补充说明</h3><ol><li>“[GC” 和 “[Full GC” 说明了这次垃圾收集的停顿类型，如果有 Full 则说明 GC 发生了 “Stop The World”</li><li>使用 Serial 收集器在新生代的名字是 Default New Generation，因此显示的是 “[DefNew”</li><li>使用 ParNew 收集器在新生代的名字会变成 “ParNew”，意思是 “Parallel New Generation”</li><li>使用 Parallel scavenge 收集器在新生代的名字是 “PSYoungGen”</li><li>老年代的收集和新生代道理一样，名字也是收集器决定的</li><li>使用 G1 收集器的话，会显示为 “garbage-first heap”</li><li>Allocation Failure 表明本次引起 GC 的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</li><li>[PSYoungGen: 5986K-&gt;696K(8704K) ] 5986K-&gt;704K (9216K)<ul><li>中括号内：GC 回收前年轻代大小，回收后大小，（年轻代总大小）</li><li>括号外：GC 回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li></ul></li><li>user 代表用户态回收耗时，sys 内核态回收耗时，real 实际耗时。由于多核线程切换的原因，时间总和可能会超过 real 时间</li></ol><h2 id="垃圾回收器的新发展"><a href="#垃圾回收器的新发展" class="headerlink" title="垃圾回收器的新发展"></a>垃圾回收器的新发展</h2><h3 id="垃圾回收器的发展过程"><a href="#垃圾回收器的发展过程" class="headerlink" title="垃圾回收器的发展过程"></a>垃圾回收器的发展过程</h3><p>GC 仍然处于飞速发展之中，目前的默认选项 G1 GC 在不断的进行改进，很多我们原来认为的缺点，例如串行的 Full GC、Card Table 扫描的低效等，都已经被大幅改进，例如，JDK10 以后，Full GC 已经是并行运行，在很多场景下，其表现还略优于 Parallel GC 的并行 Full GC 实现。 </p><p>即使是 Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，<strong>在 Serverless 等新的应用场景下，Serial GC 找到了新的舞台。</strong></p><p>比较不幸的是 CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在 JDK 9 中已经被标记为废弃，并在 JDK 14 版本中移除。</p><p>现在 G1 回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK 11出现）和 Shenandoah（Open JDK 12），其特点：主打低停顿时间。</p><h3 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h3><p><strong>Open JDK12的Shenandoash GC：低停顿时间的GC（实验性）</strong></p><p>Shenandoah 无疑是众多 GC 中最孤独的一个。是第一款不由 Oracle 公司团队领导开发的 Hotspot 垃圾收集器。不可避免的受到官方的排挤。比如号称 openJDK 和 OracleJDK 没有区别的 Oracle 公司仍拒绝在 Oracle JDK12 中支持 Shenandoah。</p><p>Shenandoah 垃圾回收器最初由 RedHat 进行的一项垃圾收集器研究项目 Pauseless GC 的实现，旨在针对 JVM 上的内存回收实现低停顿的需求。在 2014 年贡献给 OpenJDK。</p><p>Red Hat 研发 Shenandoah 团队对外宣称，Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200MB 还是200GB，99.9% 的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p><p><img src="https://up-img.yonghong.tech/pic/2021/05/12-20-51-shenandoah-benchmark-XybNYb.png" alt="shenandoah-benchmark"></p><p>这是 RedHat 在 2016 年发表的论文数据，测试内容是使用 ES 对 200GB 的维基百科数据进行索引。从结果看：</p><ol><li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li><li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li></ol><p>总结</p><ol><li>Shenandoah GC 的弱项：高运行负担下的吞吐量下降。</li><li>Shenandoah GC 的强项：低延迟时间。</li></ol><p>相关解读：尚硅谷宋红康Java12&amp;13新特性教程(深入解读java12&amp;13)</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWpKNDExTTdrUQ==">https://www.bilibili.com/video/BV1jJ411M7kQ<i class="fa fa-external-link-alt"></i></span></p><h3 id="令人震惊、革命性的-ZGC"><a href="#令人震惊、革命性的-ZGC" class="headerlink" title="令人震惊、革命性的 ZGC"></a>令人震惊、革命性的 ZGC</h3><p>官方文档：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMTIvZ2N0dW5pbmcv">https://docs.oracle.com/en/java/javase/12/gctuning/<i class="fa fa-external-link-alt"></i></span></p><p>ZGC 与 Shenandoah 目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</p><p>《深入理解Java虚拟机》一书中这样定义 ZGC：ZGC 收集器是一款基于 Region 内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现<strong>可并发的标记-压缩算法</strong>的，以<strong>低延迟为首要目标</strong>的一款垃圾收集器。</p><p>ZGC 的工作过程可以分为 4 个阶段：<strong>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</strong> 等。</p><p>ZGC 几乎在所有地方并发执行的，除了<strong>初始标记的是 STW 的</strong>。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p><p>在 ZGC 的强项停顿时间测试上，它毫不留情的将 Parallel、G1 拉开了两个数量级的差距。无论平均停顿、95% 停顿、99.8% 停顿、99. 98% 停顿，还是最大停顿时间，ZGC 都能毫不费劲控制在 10 毫秒以内。</p><p>虽然 ZGC 还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</p><h3 id="面向大堆的-AliGC"><a href="#面向大堆的-AliGC" class="headerlink" title="面向大堆的 AliGC"></a>面向大堆的 AliGC</h3><p>AliGC 是阿里巴巴 JVM 团队基于 G1 算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p><p><img src="https://up-img.yonghong.tech/pic/2021/05/12-20-51-aligc_1-FPAp6p.png" alt="12-20-51-aligc_1-FPAp6p"></p><p><img src="https://up-img.yonghong.tech/pic/2021/05/12-20-51-aligc_2-CKMw3y.png" alt="12-20-51-aligc_2-CKMw3y"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;垃圾回收器概述&quot;&gt;&lt;a href=&quot;#垃圾回收器概述&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收器概述&quot;&gt;&lt;/a&gt;垃圾回收器概述&lt;/h2&gt;&lt;p&gt;垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商，不同版本的 JVM 来实现。&lt;/p&gt;
&lt;p&gt;由于 JDK 的版本处于高速迭代过程中，因此 Java 发展至今已经衍生了众多的 GC 版本。&lt;/p&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 07 —— JVM 垃圾回收相关概念</title>
    <link href="http://yonghong.tech/java-advance/07-jvm-gc/"/>
    <id>http://yonghong.tech/java-advance/07-jvm-gc/</id>
    <published>2021-06-25T13:00:00.000Z</published>
    <updated>2021-06-25T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc() 的理解"></a>System.gc() 的理解</h2><p>在默认情况下，通过 System.gc() 或者 Runtime.getRuntime().gc() 的调用，<strong>会显示触发 Full GC</strong>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p><p>然而 System.gc() 调用附带一个免责声明，无法保证对垃圾收集器的调用。</p><span id="more"></span><p>JVM 实现者可以通过 System.gc() 调用来决定 JVM 的 GC 行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用 System.gc()。</p><p>例子1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemGCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemGCTest();</span><br><span class="line">        System.gc(); <span class="comment">// 提醒 JVM 的垃圾回收器执行 GC</span></span><br><span class="line"></span><br><span class="line">        System.runFinalization(); <span class="comment">// 强制调用未被使用对象的 finalize 方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了重写的 finalize 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVarGCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 10M</span></span><br><span class="line">        System.gc(); <span class="comment">// 不能回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 10M</span></span><br><span class="line">        buffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc(); <span class="comment">// 可以回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 10M</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.gc(); <span class="comment">// 不能回收，局部变量表中仍然有引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 10M</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">        System.gc(); <span class="comment">// 可以回收，局部变量表中 value 和 buffer 使用同一个 Slot</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fun1();</span><br><span class="line">        System.gc(); <span class="comment">// 可以回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalVarGCTest local = <span class="keyword">new</span> LocalVarGCTest();</span><br><span class="line">        local.fun5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h2><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>内存溢出相对于内存泄露来说，尽管更容易理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p><p>由于 GC 一直在发展，所以一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现 OOM 的情况。</p><p>大多数情况下，GC 会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的 Full GC 操作，这时候会回收大量的内存，供应用程序继续使用。</p><p>Java Doc 中对 OutOfMemoryError 的解释是，<strong>没有空闲内存，并且垃圾收集器也无法提供更多内存。</strong></p><p>1.首先说没有空闲内存的情况：说明 Java 虚拟机的堆内存不够。原因有二：</p><ul><li><p>Java 虚拟机的堆内存设置不够</p><p>比如：可能存在内存泄露问题：也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显示指定 JVM 堆大小或者指定数值偏小。我们可以通过 -Xms、-Xmx 来调整。</p></li><li><p>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在引用）</p><p>对于老版本的 Oracle JDK，因为永久代的大小时有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OOM 也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似 intern 字符串缓存占用太多空间，也会导致 OOM 问题。对应的异常信息，会标记出来和永久代相关：”java.lang.OutOfMemoryError: PermGen Space”</p><p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 OOM 有所改观，出现 OOM 异常的信息则变成了 “java.lang.OutOfMemoryError: Metaspace”。直接内存不足，也会导致 OOM。</p></li></ul><p>2.垃圾收集器无法提供更多内存，这里面隐含着一层意思是，在抛出 OOM 之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p><ul><li>例如：在引用机制分析中，涉及到 JVM 会去尝试回收软引用指向的对象等。</li><li>在 java.nio.BITs.reserveMemory() 方法中，我们能清楚地看到，System.gc() 会被调用，以清理空间。</li></ul><p>当然，也不是在任何情况下垃圾收集器都会被触发的。</p><ul><li>比如，我们去分配一个超大对象。类似一个超大数组超过堆的最大值，JVM 可以判断出垃圾收集并不能解决这个问题，所以直接抛出 OOM。</li></ul><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>内存泄露也称作 存储渗漏。严格来说，<strong>只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄露</strong>。</p><p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对对象的生命周期变得很长甚至导致 OOM，也可以叫做宽泛意义上的内存泄露。</p><p>尽管内存泄露并不会立刻引起程序崩溃，但是一旦发生内存泄露，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现 OOM 异常，导致程序崩溃。</p><p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小决定于磁盘交换区设定的大小。</p><p>举例：</p><p>1.单例模式</p><p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄露的产生。</p><p>2.一些提供 close 的资源未关闭导致内存泄露</p><p>数据库连接（dataSource.getConnection()），网络连接（socket）和 io 连接必须手动 close，否则是不能被回收的。</p><h2 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h2><p>Stop The World，简称 STW，指的是 GC 事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为 STW。</p><ul><li>可达性分析算法中枚举根节点（GC Roots）会导致所有 Java 执行线程停顿。<ul><li>分析工作必须在一个能确保一致性的快照中进行</li><li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li><li>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证。=</li></ul></li></ul><p>被 STW 中断的应用程序线程会在完成 GC 之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少 STW 的发生。</p><p>STW 事件和采用哪款 GC 无关，所有的 GC 都有这个事件。</p><p>哪怕是 G1 也不能完全避免 STW 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能得缩短了暂停时间。</p><p>STW 是 JVM 在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p><p>开发中不要用 System.gc()；会导致 STW 的发生。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopTheWorldTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WorkThread workThread = <span class="keyword">new</span> WorkThread();</span><br><span class="line">        PrintThread printThread = <span class="keyword">new</span> PrintThread();</span><br><span class="line">        workThread.start();</span><br><span class="line">        printThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line">                    list.add(buffer);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (list.size() &gt; <span class="number">10000</span>) &#123;</span><br><span class="line">                    list.clear();</span><br><span class="line">                    System.gc(); <span class="comment">// 触发 Full GC，引发 STW</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> t = System.currentTimeMillis() - startTime;</span><br><span class="line">                    System.out.println(t / <span class="number">1000</span> + <span class="string">&quot;.&quot;</span> + t % <span class="number">1000</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h2><h3 id="并发（Concurrent）"><a href="#并发（Concurrent）" class="headerlink" title="并发（Concurrent）"></a>并发（Concurrent）</h3><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p><p>并发不是真正意义上的“同时进行”，只是 CPU 把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于 CPU 处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p><h3 id="并行（Parallel）"><a href="#并行（Parallel）" class="headerlink" title="并行（Parallel）"></a>并行（Parallel）</h3><p>当系统有一个以上 CPU 时，当一个 CPU 执行一个进程时，另一个 CPU 可以执行另一个进程，两个进行互不抢占 CPU 资源，可以同时进行，我们称之为并行。</p><p>其实决定并行的因素不是 CPU 的数量，而是 CPU 的核心数量，比如一个 CPU 多个核也可以并行。</p><p>适合科学计算，后台处理等弱交互场景。</p><h3 id="并发-vs-并行"><a href="#并发-vs-并行" class="headerlink" title="并发 vs 并行"></a>并发 vs 并行</h3><p>并发，指的是多个事情，在同一时间段内同时发生了。</p><p>并行，指的是多个事情，在同一时间点上同时发生了。</p><p>并发的多个任务之间是互相抢占资源的，</p><p>并行的多个任务之间是不互相抢占资源的。</p><p>只有在多 CPU 或者一个 CPU 多核的情况中，才会发生并行。</p><p>否则，看似同时发生的事情，其实都是并发执行的，</p><h3 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h3><p>并发和并行，在谈论垃圾收集器的上下午语境中，它们可以解释如下：</p><ul><li>并行：只多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。<ul><li>如 ParNew、Parallel Scavenge、Parallel Old</li></ul></li><li>串行<ul><li>相较于并行的概念，单线程执行。</li><li>如果内存不够，则程序暂停，启动 JVM 垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li></ul></li><li>并发：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。<ul><li>用户程序在继续运行，而垃圾收集程序线程运行于另一个 CPU 上。</li><li>如：CMS、G1</li></ul></li></ul><h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><h3 id="安全点（Safe-Point）"><a href="#安全点（Safe-Point）" class="headerlink" title="安全点（Safe Point）"></a>安全点（Safe Point）</h3><p>程序执行时并非在所有的地方都可以停顿下来开始 GC，只有在特定位置才能停顿下来开始 GC，这些位置称为 安全点（Safe Point）。</p><p>Safe Point 的选择很重要，<strong>如果太少可能导致 GC 等待的时间太长，如果太频繁可能导致运行时的性能问题</strong>。大部分指令的执行时间都非常短暂，通常会根据 “是否具有让程序长时间执行的特性” 为标准。比如：选择一些执行时间较长的指令作为 Safe Point，如<strong>方法调用、循环跳转和异常跳转</strong>等。</p><p>如何在 GC 发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p><ul><li><p>抢占式中断：（目前没有虚拟机采用了）</p><p>首先中断所有线程，如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</p></li><li><p>主动式中断：</p><p>设置一个中断标志，各个线程运行到 Safe Point 的时候主动轮询到这个标志，如果中断标志为真，则将自己进行中断挂起。</p></li></ul><h3 id="安全区域（Safe-Region）"><a href="#安全区域（Safe-Region）" class="headerlink" title="安全区域（Safe Region）"></a>安全区域（Safe Region）</h3><p>Safe Point 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safe Point。但是，程序 “不执行” 的时候呢？例如线程处于 Sleep 状态或 Blocked 状态，这个时候线程无法响应 JVM 的中断请求，“走” 到安全点去中断挂起，JVM 也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p><p><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始 GC 都是安全的。</strong>我们也可以把 Safe Region 看做是拓展了的 Safe Point。</p><p>实际执行时：</p><ul><li>当线程运行到 Safe Region 的代码时，首先标识已经进入了 Safe Region，如果这段时间内发生 GC，JVM 会忽略标识为 Safe Region 状态的线程。</li><li>当线程离开 Safe Region 时，会检查 JVM 是否已经完成 GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开 Safe Region 的信号为止。</li></ul><hr><h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h2><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p><p>【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</p><p>在 JDK 1.2 版本后，Java 对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Preference）和虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。</p><p>除强引用外，其他 3 种引用均可以在 java.lang.ref 包中找到它们的身影。如下图，显示了这 3 种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p><p>Reference 子类中只有终结器引用是包内可见的，其他 3 种类型均为 public，可以在应用程序中直接使用。</p><ul><li>强引用：最传统的引用的定义，是指在程序代码之中普遍存在的引用赋值，即类似 “Object obj = new Object()” 这种引用关系。<strong>无论任何情况下，只要强引用关系还在，垃圾收集器就永远不会回收掉被引用的对象。</strong></li><li>软引用：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li><li>弱引用：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li>虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。<strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</strong></li></ul><h2 id="再谈引用：强引用（不回收）"><a href="#再谈引用：强引用（不回收）" class="headerlink" title="再谈引用：强引用（不回收）"></a>再谈引用：强引用（不回收）</h2><p>在 Java 程序中，最常见的引用类型是强引用（普通对象99%以上都是强引用），也就是我们最常见的普通对象引用，也就是默认的引用类型。</p><p>当在 Java 语言中使用 new 操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p><p>强引用的对象是可触及的，垃圾回收器就永远不会回收掉被引用的对象。</p><p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p><p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及的，在一定条件下，都是可以被回收的。所以，强引用时造成 Java 内存泄露的主要原因之一。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;强引用&quot;</span>);</span><br></pre></td></tr></table></figure><p>强引用具备以下特点：</p><ul><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向对象。</li><li>强引用可能导致内存泄露。</li></ul><h2 id="再谈引用：软引用（内存不足即回收）"><a href="#再谈引用：软引用（内存不足即回收）" class="headerlink" title="再谈引用：软引用（内存不足即回收）"></a>再谈引用：软引用（内存不足即回收）</h2><p>软引用是用来描述一些还有用，但是非必需的对象。只要被软引用关联着的对象，在系统将要发生内存溢出异常前会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><p>软引用通常用来实现内存敏感的缓存。比如：高速缓存（如，MyBatis 的缓存）就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就能保证了使用缓存的同时，不会耗尽内存。</p><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p><p>类似弱引用，只不过 Java 虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object(); <span class="comment">// 声明强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sr = <span class="keyword">new</span> SoftReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">// 销毁强引用</span></span><br></pre></td></tr></table></figure><h2 id="再谈引用：弱引用（发现即回收）"><a href="#再谈引用：弱引用（发现即回收）" class="headerlink" title="再谈引用：弱引用（发现即回收）"></a>再谈引用：弱引用（发现即回收）</h2><p>弱引用也是用来描述那些非必需对象，<strong>只</strong>被弱引用关联的对象<strong>只能生存到下一次垃圾收集发生为止</strong>。在系统 GC 时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p><p>但是，由于垃圾回收器的线程通常优先级低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p><p>弱引用和软引用一样，在构造弱引用同时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p><p><strong>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。</strong>如果这么做，当系统内存不足时，这些缓存数据就会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object(); <span class="comment">// 声明强引用</span></span><br><span class="line">WeakReference&lt;Object&gt; wr = <span class="keyword">new</span> WeakReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">// 销毁强引用</span></span><br></pre></td></tr></table></figure><p>弱引用对象与软引用对象最大的不同就在于，当 GC 在进行回收时，需要通过算法检查是够回收软引用对象，而对于弱引用，GC 总是进行回收。弱引用对象更容易、更快被 GC 回收。</p><p>面试题：开发中使用过 WeakHashMap 吗？</p><p>图片缓存等。</p><h2 id="再谈引用：虚引用（对象回收跟踪）"><a href="#再谈引用：虚引用（对象回收跟踪）" class="headerlink" title="再谈引用：虚引用（对象回收跟踪）"></a>再谈引用：虚引用（对象回收跟踪）</h2><p>也称为 “幽灵引用” 或者 “幻影引用”，是所有引用类型中最弱的一个。</p><p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p><p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的 get() 方法取得对象时，总是 null。</p><p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</p><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会回收对象后，将这个虚引用加入引用队列，以通知应用程序对象回收情况。</p><p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object(); <span class="comment">// 声明强引用</span></span><br><span class="line">ReferenceQueue phantomQueue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference&lt;Object&gt; pr = <span class="keyword">new</span> PhantomReference&lt;&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">// 销毁强引用</span></span><br></pre></td></tr></table></figure><h2 id="再谈引用：终结器引用"><a href="#再谈引用：终结器引用" class="headerlink" title="再谈引用：终结器引用"></a>再谈引用：终结器引用</h2><p>它用于实现对象的 finalize 方法，也可以称为终结器引用。</p><p>无需手动编码，其内部配合引用队列使用。</p><p>在 GC 时，终结器引用入队。由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;System-gc-的理解&quot;&gt;&lt;a href=&quot;#System-gc-的理解&quot; class=&quot;headerlink&quot; title=&quot;System.gc() 的理解&quot;&gt;&lt;/a&gt;System.gc() 的理解&lt;/h2&gt;&lt;p&gt;在默认情况下，通过 System.gc() 或者 Runtime.getRuntime().gc() 的调用，&lt;strong&gt;会显示触发 Full GC&lt;/strong&gt;，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。&lt;/p&gt;
&lt;p&gt;然而 System.gc() 调用附带一个免责声明，无法保证对垃圾收集器的调用。&lt;/p&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 06 —— JVM 垃圾回收算法</title>
    <link href="http://yonghong.tech/java-advance/06-jvm-gc-algo/"/>
    <id>http://yonghong.tech/java-advance/06-jvm-gc-algo/</id>
    <published>2021-06-18T13:00:00.000Z</published>
    <updated>2021-06-18T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么会有-GC"><a href="#为什么会有-GC" class="headerlink" title="为什么会有 GC"></a>为什么会有 GC</h1><p>本质上是内存资源的有限性，因此需要大家共享使用，手工申请，手动释放。</p><p>垃圾收集，不是 Java 语言的伴生产物。早在 1960 年，第一门开始使用内存动态分配和垃圾收集技术的 Lisp 语言诞生。</p><p>关于垃圾收集有三个经典问题：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><span id="more"></span><p>垃圾收集机制是 Java 语言的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java 的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p><p>面试题：</p><ul><li>垃圾回收器，各自优缺点，CMS、G1</li><li>GC 算法有哪些，目前的 JDK 版本采用什么回收算法</li><li>GC 两种判定方法</li><li>分代回收</li><li>垃圾收集策略和算法</li><li>平时如何搭配使用垃圾回收器</li><li>什么情况触发垃圾回收</li><li>System.gc() runtime.gc()</li><li>Java  GC 机制，GC Roots 有哪些</li><li>CMS 回收停顿了几次，为什么？</li></ul><h1 id="什么是垃圾（Garbage）"><a href="#什么是垃圾（Garbage）" class="headerlink" title="什么是垃圾（Garbage）"></a>什么是垃圾（Garbage）</h1><p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。An object is considered garbage when it  can no longer be  reached from any pointer in the running program .</p><p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占用的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</p><h1 id="为什么需要垃圾回收"><a href="#为什么需要垃圾回收" class="headerlink" title="为什么需要垃圾回收"></a>为什么需要垃圾回收</h1><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停的生产而从来不打扫一样。</p><p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便 JVM 将整理出的内存分配给新的对象。</p><p>随着应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有 GC 就不能保证应用程序的正常进行。而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。</p><h1 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h1><p>在早期的 C/C++ 时代，垃圾回收基本上是手工进行的。开发人员可以使用 new 关键字进行内存申请，并使用 delete 关键字进行内存释放。比如以下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> cmBaseGroupBridge();</span><br><span class="line"><span class="comment">// 如果注册失败，使用 delete 关键字释放该对象所占用内存区域</span></span><br><span class="line"><span class="keyword">if</span> (pBridg-&gt;Register(kDestroy) != NO_ERROR) &#123;</span><br><span class="line">    <span class="keyword">delete</span> pBridge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄露，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。</p><p>有了垃圾回收机制后，上述代码块极有可能变成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> cmBaseGroupBridge();</span><br><span class="line">pBridg-&gt;Register(kDestroy);</span><br></pre></td></tr></table></figure><p>现在，除了 Java 以外，C#、Python、Ruby 等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式已经成为现代开发语言必备的标准。</p><h1 id="Java-垃圾回收机制"><a href="#Java-垃圾回收机制" class="headerlink" title="Java 垃圾回收机制"></a>Java 垃圾回收机制</h1><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低了内存泄漏和内存溢出的风险。</p><ul><li>没有垃圾回收器，java 也会和 cpp 一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li></ul><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专注地专心于业务开发。</p><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy90ZWNobm90ZXMvZ3VpZGVzL3ZtL2djdHVuaW5nL3RvYy5odG1s">Oracle 官网关于垃圾回收的介绍<i class="fa fa-external-link-alt"></i></span></p><p>担忧：</p><p>对于 Java 开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于”自动“，那么这将会是一场灾难，最严重的就会弱化 Java 开发人员在程序出现内存溢出时定位问题和解决问题的能力。</p><p>此时，了解 JVM 的自动内存分配和内存回收原理就显得非常重要，只有在真正了解 JVM 是如何管理内存后，我们才能够在遇见 OOM 时，快速地根据错误异常日志定位问题和解决问题。</p><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集册很难过为系统达到更高并发量的瓶颈时，我们就必须对这些”自动化“的技术是是必要的监控和调优。</p><p>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至全堆和方法区的回收。</p><hr><ul><li>其中，Java 堆是垃圾收集器的工作重点</li></ul><p>从次数上讲：</p><ul><li>频繁收集年轻代</li><li>较少收集老年代</li><li>基本不动方法区/永久代/元空间</li></ul><h1 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h1><h2 id="垃圾标记阶段"><a href="#垃圾标记阶段" class="headerlink" title="垃圾标记阶段"></a>垃圾标记阶段</h2><p>在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活的对象，哪些是已经死亡的对象</strong>。只有被标记为已经死亡的对象，GC 才会在执行垃圾回收时，释放掉其所占有的内存空间，因此这个过程我们称为<strong>垃圾标记阶段</strong>。</p><p>那么在 JVM 中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p><p>判断对象存活一般有两种方式：<strong>引用计数法</strong>和<strong>可达性分析算法</strong>。</p><h3 id="方式一：引用计数算法"><a href="#方式一：引用计数算法" class="headerlink" title="方式一：引用计数算法"></a>方式一：引用计数算法</h3><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的<strong>引用计数器属性用于记录对象被引用的情况</strong>。</p><p>对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，即表示对象 A 不可能再被使用，可进行回收。</p><p>优点：<strong>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性</strong>。</p><p>缺点：</p><ul><li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong>。</li><li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命的缺陷，导致在 Java 的垃圾回收器中没有使用这类算法。</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的 Python，它更是同时支持引用计数和垃圾收集机制。</p><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p><p>Java 并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</p><p>Python 如何解决循环引用？</p><ul><li>手动解除：很好理解，就是在合适的时机，解除引用关系。</li><li>使用弱引用 weakref，weakref 是 Python 提供的标准库，旨在解决循环引用。</li></ul><h3 id="方式二：可达性分析算法"><a href="#方式二：可达性分析算法" class="headerlink" title="方式二：可达性分析算法"></a>方式二：可达性分析算法</h3><p>可达性分析算法又叫做根搜索算法，或者是追踪性垃圾收集。</p><p>相对于引用计数法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</p><p>相较于引用计数算法，这里的可达性分析就是 Java、C# 选择的。这种类型的垃圾收集器通常也叫做<strong>追踪性垃圾收集器（Tracing Garbage Collector）</strong>。</p><p>所谓 ”GC Roots“ 根集合就是一组必须活跃的引用。</p><p>基本思路：</p><ul><li>可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达</strong>。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为<strong>引用链（Reference Chain）</strong></li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象</li><li>在可达性分析算法中，只有能够被根对象集合直接或间接连接的对象才是存活对象</li></ul><p>这个算法目前较为常用。</p><h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><p>在 Java 语言中，GC Roots 包括以下几类元素：</p><ul><li>虚拟机栈中引用的对象<ul><li>比如，各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li>本地方法栈内 JNI（通常说的本地方法）引用的对象</li><li>方法区中类静态属性引用的对象<ul><li>比如：Java 类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象<ul><li>比如：字符串常量池里的引用</li></ul></li><li>所有被同步锁 synchronized 持有的对象</li><li>Java 虚拟机内部的引用<ul><li>基本数据类型对应的 Class 对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li></ul></li><li>反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</li></ul><p>除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象 临时性 地加入，共同构成完整 GC Roots 集合。比如，分代收集和局部回收（Partial GC）</p><ul><li>如果只针对 Java 堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入 GC Roots 集合中去考虑，才能保证可达性分析的准确性。</li></ul><p><strong>小技巧：</strong>由于 Root 采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root。</p><p><strong>注意：</strong>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能够保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p><p>这点也是导致 GC 时进行必须 ”Stop The World“ 的一个重要原因。</p><ul><li>即使是号称（几乎）不会发生停顿的 CMS 收集器中，<strong>枚举根节点时也是必须要停顿的</strong>。</li></ul><h4 id="对象的-finalization-机制"><a href="#对象的-finalization-机制" class="headerlink" title="对象的 finalization 机制"></a>对象的 finalization 机制</h4><p>Java 语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 finalize() 方法。</p><p> finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p><p>永远不要主动调用对象的 finalize() 方法，应该交给垃圾回收机制调用。理由包括以下 3 点：</p><ul><li><p>在 finalize() 时可能会导致对象复活。</p></li><li><p>finalize() 方法执行时间是没有保障的，它完全由 GC 线程决定，极端情况下，若不发生 GC，则  finalize() 方法将没有执行机会。</p></li><li><p>一个糟糕的  finalize() 会严重影响 GC 性能</p></li></ul><p>从功能上来说， finalize() 方法与 C++ 中的析构函数比较相似，但是 Java 采用的是基于垃圾回收器的自动内存管理机制，所以  finalize() 方法在本质上不同于 C++ 中的析构函数。</p><p>由于  finalize() 方法的存在，虚拟机中的对象一般处于三种可能的状态。</p><h4 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h4><p>如果所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是 “非死不可” 的，这时候它们暂时处于 “缓刑” 阶段。一个无法触及的对象有可能在某一个条件下 ”复活“，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p><ul><li>可触及的：从根节点开始，可以到达这个对象。</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在  finalize() 中复活。</li><li>不可触及的：对象的 finalize() 方法被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为  finalize() 方法只会被调用一次。</li></ul><p>以上 3 种状态中，是由于 finalize() 方法的存在进行的区分。只有在对象不可触及时才可以被回收。</p><h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><p>判定一个对象 objA 是否可回收，至少要经历两次标记过程：</p><ul><li>如果对象 objA 到 GC Roots 没有引用链，则进行第一次标记</li><li>进行筛选，判断此对象是否有必要执行  finalize() 方法<ul><li>如果对象 objA 没有重写 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，则虚拟机视为 ”没有必要执行“，objA 被判定为不可触及的。</li><li>如果对象 objA 重写了 finalize() 方法，且还未执行过，那么 objA 会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 finalize() 方法执行。</li><li>finalize() 方法是对象逃脱死亡的最后机会，稍后 GC 会对 F-Queue 队列中的对象进行第二次标记。如果 objA 在 finalize() 方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA 会被移出 ”即将回收“ 集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize() 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的 finalize() 方法只会被调用一次。</li></ul></li></ul><h4 id="MAT-与-JProfiler-的-GC-Roots-溯源"><a href="#MAT-与-JProfiler-的-GC-Roots-溯源" class="headerlink" title="MAT 与 JProfiler 的 GC Roots 溯源"></a>MAT 与 JProfiler 的 GC Roots 溯源</h4><p>MAT 是 Memory Analyzer 的简称，它是一款功能强大的 Java 堆内存分析器，用于查找内存泄露以及查看内存消耗情况。</p><p>MAT 是基于 Eclipse 开发的，是一款免费的性能分析工具。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWNsaXBzZS5vcmcvbWF0Lw==">https://www.eclipse.org/mat/<i class="fa fa-external-link-alt"></i></span></p><h4 id="获取-dump-文件"><a href="#获取-dump-文件" class="headerlink" title="获取 dump 文件"></a>获取 dump 文件</h4><ul><li>命令行使用 jmap<ul><li>jps</li><li>jmap -dump:format=b,live,file=test1.bin 14036</li></ul></li><li>使用 JVisualVM 导出<ul><li>捕获的 heap dump 文件是一个临时文件，关闭 JVisualVM 后自动删除，若要保留，需要将其另存为文件。</li><li>可以通过以下方式捕获 heap dump<ul><li>在左侧 Application 子窗口中右击相应的应用程序，选择 Heap Dump</li><li>在 Monitor 子标签页中点击 Heap Dump 按钮</li></ul></li><li>本地应用程序的 Heap Dumps 作为应用程序标签页的一个子标签页打开。同时，Heap Dump 在左侧 Application 栏中对应一个含有时间戳的节点，右击这个节点选择 Save As 即可将 Heap Dump 文件保存到本地。</li></ul></li></ul><h2 id="垃圾清除阶段"><a href="#垃圾清除阶段" class="headerlink" title="垃圾清除阶段"></a>垃圾清除阶段</h2><p>当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p><p>目前在 JVM 比较常见的三种垃圾收集算法是 标记-清除算法（Mark-Sweep）、复制算法（Copying）、标记-压缩算法（Mark-Compact）</p><h3 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被 J.McCarthy 等人在 1960 年提出并应用于 List 语言。</p><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为 Stop The World），然后进行两项工作，第一项是标记，第二项则是清除。</p><ul><li>标记：Collector 从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的 Header 中记录为可达对象。</li><li>清除：Collector 对对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收。</li></ul><p>缺点：</p><ul><li>效率不算高</li><li>在进行 GC 的时候，需要停止整个应用程序，导致用户体验差</li><li>这种方式清理出来的空闲内存空间是不连续的，产生内存碎片。需要维护一个空闲列表</li></ul><p>注意：何为清除？</p><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。</p><h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky 于1963 年发表了著名的论文，”使用双存储区的 Lisp 语言垃圾收集器 （A Lisp Garbage Collector Algorithm Using Serial Secondary Storage）“。M.L.Minsky 本人成功地引入到了 Lisp 语言的一个实现版本中。</p><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>将活着的内存空间分为两块，每次只是用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p><p>优点</p><ul><li><p>没有标记和清除过程，实现简单，运行高效</p></li><li><p>复制过去以后保证空间的连续性，不会出现”碎片问题“</p></li></ul><p>缺点</p><ul><li><p>此算法的缺点也是很明显的，就是需要两倍的内存空间。</p></li><li><p>对于 G1 这种分拆成为大量 region 的GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销也不小</p></li></ul><p>特别的：</p><ul><li>如果系统中的垃圾对象很多，复制短发需要复制的存活对象数量并不会太大，或者说非常低。</li></ul><p>应用场景：</p><p>在新生代，对应常规应用的垃圾回收，一次通常可以回收 70% - 99% 的内存空间，回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p><h3 id="标记-压缩算法（Mark-Compact）"><a href="#标记-压缩算法（Mark-Compact）" class="headerlink" title="标记-压缩算法（Mark-Compact）"></a>标记-压缩算法（Mark-Compact）</h3><h4 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h4><p>复制算法的高效性，是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p><p>标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以 JVM 的设计者需要在此基础上进行改进。标记-压缩（Mark-Compact）算法也由此诞生。</p><p>1970 年前后，G.L.Steele、C.J.Chene 和 D.S.Wise 等研究者发布标记-压缩算法。在许多现代的垃圾回收器中，人们都是用了标记-压缩算法或其改进版本。</p><h4 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h4><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象。</p><p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</p><p>之后清理边界外所有的空间。</p><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为 标记-清除-压缩（Mark-Sweep-Compact） 算法。</p><p>二者本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。</p><p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p><p><strong>指针碰撞（Bump the Pointer）</strong></p><p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞。</p><p><strong>优点</strong></p><p>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可。</p><p>消除了复制算法当中，内存减半的高额代价</p><p><strong>缺点</strong></p><p>从效率上来说，标记-整理算法要低于复制算法。</p><p>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。</p><p>移动的过程中，需要全程暂停用户应用程序。即：STW</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><table><thead><tr><th></th><th>Mark-Sweep</th><th>Mark-Compact</th><th>Copying</th></tr></thead><tbody><tr><td>速度</td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td>空间开销</td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的 2 倍大小（不堆积碎片）</td></tr><tr><td>移动对象</td><td>否</td><td>是</td><td>是</td></tr></tbody></table><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记阶段，比标记-清除算法多了一个整理内存的阶段。</p><p><strong>难道就没有一种最优算法吗？</strong></p><p>没有最好的算法，只有最合适的算法。</p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和缺点。分代收集算法应运而生。</p><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，<strong>不同生命周期的对象可以采取不同的收集方式，以便提高回收效率</strong>。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年龄代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在 Java 程序运行过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如 HTTP 请求中的 Session 对象、线程、Socket 连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String 对象，由于其不变性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p>目前几乎所有的 GC 都是采用分代收集（Generational Collecting）算法执行垃圾回收的。</p><p>在 HotSpot 中，基于分代的概念，GC 所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><ul><li>年轻代（Young Gen）<ul><li>年轻代的特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li><li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过 HotSpot 中的两个 Survivor 的设计得到缓解</li></ul></li><li>老年代（Tenured Gen）<ul><li>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</li><li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或是标记-清除与标记-整理的混合实现。<ul><li>Mark 阶段的开销与存活对象的数量成正比。</li><li>Sweep 阶段的开销与所管理区域大小成正比。</li><li>Compact 阶段的开销与存活对象的数据成正比。</li></ul></li></ul></li></ul><p><strong>以 HotSpot 中的 CMS 回收器为例，CMS 是基于 Mark-Sweep 实现的，对于对象的回收率很高。而对于碎片问题，CMS 采用基于 Mark-Compact 算法的 Serial Old 回收器作为补偿：当内存回收不佳（碎片导致的 Concurrent Mode Failure 时），将采用 Serial Old 执行 Full GC 以达到对老年代内存的整理。</strong></p><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。</p><h2 id="增量收集算法、分区算法"><a href="#增量收集算法、分区算法" class="headerlink" title="增量收集算法、分区算法"></a>增量收集算法、分区算法</h2><h3 id="增量收集算法（Incremental-Collecting）"><a href="#增量收集算法（Incremental-Collecting）" class="headerlink" title="增量收集算法（Incremental Collecting）"></a>增量收集算法（Incremental Collecting）</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种 STW 的状态。在 STW 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，<strong>将严重影响用户体验或者系统的稳定性</strong>。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><p>基本思想：如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，<strong>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</strong>。</p><p>总的来说，增量收集算法的基础仍然是传统的标记-清除和复制算法。<strong>增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段方式完成标记、清理或复制工作。</strong></p><p>缺点：使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为<strong>线程切换和上下文转换</strong>的消耗，会使得垃圾回收的总体成本上升，<strong>造成系统吞吐量的下降</strong>。</p><h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><p>一般来说，在相同条件下，堆空间越大，一次 GC 时所需要的时间就越长，有关 GC 产生的停顿也越长。为了更好的控制 GC 产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次 GC 所产生的停顿。</p><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间 region。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p><p>总结：注意，这些只是基本的算法思路，实际 GC 实现过程要复杂的多，目前还在发展中的前沿 GC 都是复合算法，并且并行和并发兼备。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;为什么会有-GC&quot;&gt;&lt;a href=&quot;#为什么会有-GC&quot; class=&quot;headerlink&quot; title=&quot;为什么会有 GC&quot;&gt;&lt;/a&gt;为什么会有 GC&lt;/h1&gt;&lt;p&gt;本质上是内存资源的有限性，因此需要大家共享使用，手工申请，手动释放。&lt;/p&gt;
&lt;p&gt;垃圾收集，不是 Java 语言的伴生产物。早在 1960 年，第一门开始使用内存动态分配和垃圾收集技术的 Lisp 语言诞生。&lt;/p&gt;
&lt;p&gt;关于垃圾收集有三个经典问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哪些内存需要回收？&lt;/li&gt;
&lt;li&gt;什么时候回收？&lt;/li&gt;
&lt;li&gt;如何回收？&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 05 —— JVM 相关工具</title>
    <link href="http://yonghong.tech/java-advance/05-jvm-args-tools/"/>
    <id>http://yonghong.tech/java-advance/05-jvm-args-tools/</id>
    <published>2021-06-11T13:00:00.000Z</published>
    <updated>2021-06-11T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM-命令行工具"><a href="#JVM-命令行工具" class="headerlink" title="JVM 命令行工具"></a>JVM 命令行工具</h2><table><thead><tr><th align="center">工具</th><th>简介</th></tr></thead><tbody><tr><td align="center">java</td><td>Java 应用的启动程序</td></tr><tr><td align="center">javac</td><td>JDK 内置的编译工具</td></tr><tr><td align="center">javap</td><td>反编译 class 文件的工具</td></tr><tr><td align="center">javadoc</td><td>根据 Java 代码和标准注释,自动生成相关的API说明文档</td></tr><tr><td align="center">javah</td><td>JNI 开发时, 根据 java 代码生成需要的 .h文件。</td></tr><tr><td align="center">extcheck</td><td>检查某个 jar 文件和运行时扩展 jar 有没有版本冲突，很少使用</td></tr><tr><td align="center">jdb</td><td>Java Debugger ; 可以调试本地和远端程序, 属于 JPDA 中的一个 demo 实现, 供其他调试器参考。开发时很使用</td></tr><tr><td align="center">jdeps</td><td>探测 class 或 jar 包需要的依赖</td></tr><tr><td align="center">jar</td><td>打包工具，可以将文件和目录打包成为 .jar 文件；.jar 文件本质上就是 zip 文件, 只是后缀不同。使用时按顺序对应好选项和参数即可。</td></tr><tr><td align="center">keytool</td><td>安全证书和密钥的管理工具; （支持生成、导入、导出等操作）</td></tr><tr><td align="center">jarsigner</td><td>JAR 文件签名和验证工具</td></tr><tr><td align="center">policytool</td><td>实际上这是一款图形界面工具, 管理本机的 Java 安全策略</td></tr><tr><td align="center">jps/jinfo</td><td>查看 java 进程</td></tr><tr><td align="center"><strong>jstat</strong></td><td>查看 JVM 内部 gc 相关信息</td></tr><tr><td align="center"><strong>jmap</strong></td><td>查看 heap 或类占用空间统计</td></tr><tr><td align="center"><strong>jstack</strong></td><td>查看线程信息</td></tr><tr><td align="center">jcmd</td><td>执行 JVM 相关分析命令（整合命令）</td></tr><tr><td align="center">jrunscript/jjs</td><td>执行 js 命令</td></tr></tbody></table><span id="more"></span><h3 id="常用命令实例"><a href="#常用命令实例" class="headerlink" title="常用命令实例"></a>常用命令实例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br><span class="line">jps -mlv </span><br><span class="line"><span class="meta">#</span><span class="bash"> -l 列出 Java 进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -m 列出传递给 main 方法的参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v 列出传递给 JVM 的参数</span></span><br><span class="line"></span><br><span class="line">jinfo pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参考：https://blog.csdn.net/maosijunzi/article/details/46049117</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> jstat   内存信息</span></span><br><span class="line">jstat -gc pid 1000 1000 # 每1000ms打印1次，打印1000次</span><br><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">4352.0 4352.0 4352.0  0.0   34944.0  10175.9   198132.0   152461.3  142132.0 134139.5 19624.0 16988.2     26    0.201   0      0.000    0.201</span><br><span class="line">4352.0 4352.0 4352.0  0.0   34944.0  10175.9   198132.0   152461.3  142132.0 134139.5 19624.0 16988.2     26    0.201   0      0.000    0.201</span><br><span class="line">4352.0 4352.0 4352.0  0.0   34944.0  10175.9   198132.0   152461.3  142132.0 134139.5 19624.0 16988.2     26    0.201   0      0.000    0.201</span><br><span class="line"><span class="meta">#</span><span class="bash"> S0C：第一个幸存区的大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> S1C：第二个幸存区的大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> S0U：第一个幸存区的使用大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> S1U：第二个幸存区的使用大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> EC：伊甸园区的大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> EU：伊甸园区的使用大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> OC：老年代大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> OU：老年代使用大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MC：方法区大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MU：方法区使用大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CCSC：压缩类空间大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CCSU：压缩类空间使用大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> YGC：年轻代垃圾回收次数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> YGCT：年轻代垃圾回收消耗时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> FGC：老年代垃圾回收次数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> FGCT：老年代垃圾回收消耗时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> GCT：垃圾回收消耗总时间</span></span><br><span class="line"></span><br><span class="line">jstat -gcutil pid 1000 1000</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">  0.00  79.37  72.86  78.50  94.45  86.65     27    0.207     0    0.000    0.207</span><br><span class="line">  0.00  79.37  72.86  78.50  94.45  86.65     27    0.207     0    0.000    0.207</span><br><span class="line">  0.00  79.37  72.86  78.50  94.45  86.65     27    0.207     0    0.000    0.207</span><br><span class="line"><span class="meta">#</span><span class="bash"> S0：幸存1区当前使用比例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> S1：幸存2区当前使用比例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> E：伊甸园区使用比例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> O：老年代使用比例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> M：元数据区使用比例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CCS：压缩使用比例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> YGC：年轻代垃圾回收次数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> FGC：老年代垃圾回收次数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> FGCT：老年代垃圾回收消耗时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> GCT：垃圾回收消耗总时间</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只看 Young 或 Old 区</span></span><br><span class="line">jstat -gcnew pid</span><br><span class="line">jstat -gcold pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> jmap    对象信息</span></span><br><span class="line">jmap -heap pid      # 堆内存</span><br><span class="line">jmap -histo pid     # 直方图</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> jstack  线程信息</span></span><br><span class="line">jstack -l pid       # 将线程相关的 locks 信息一起输 出，比如持有的锁，等待的锁。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> jcmd 综合了前面的几个命令</span></span><br><span class="line">jcmd pid VM.version</span><br><span class="line">jcmd pid VM.flags</span><br><span class="line">jcmd pid VM.command_line</span><br><span class="line">jcmd pid VM.system_properties</span><br><span class="line">jcmd pid Thread.print</span><br><span class="line">jcmd pid GC.class_histogram</span><br><span class="line">jcmd pid GC.heap_info</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当curl命令用</span></span><br><span class="line">jrunscript -e &quot;cat(&#x27;http://www.baidu.com&#x27;)&quot; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行js脚本片段</span></span><br><span class="line">jrunscript -e &quot;print(&#x27;hello,kk.jvm&#x27;+1)&quot; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行js文件</span> </span><br><span class="line">jrunscript -l js -f /XXX/XXX/test.js</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JVM-图形化工具"><a href="#JVM-图形化工具" class="headerlink" title="JVM 图形化工具"></a>JVM 图形化工具</h2><h3 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h3><p>JDK 自带工具</p><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-11-jconsole-mem-MJI7ul.png" alt="jconsole-内存"><br><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-12-jconsole-thread-b0RSWW.png" alt="jconsole-线程"><br><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-12-jconsole-guide-KgMCzE.png" alt="jconsole-概览"></p><h3 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h3><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-15-jvisualvm-guide-JU8yC7.png" alt="jvisualvm"></p><h3 id="VisualGC"><a href="#VisualGC" class="headerlink" title="VisualGC"></a>VisualGC</h3><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-16-VisualGC-poZ5Sm.png" alt="VisualGC"></p><h3 id="jmc"><a href="#jmc" class="headerlink" title="jmc"></a>jmc</h3><p>需要安装 Oracle JDK。</p><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-16-jmc-yNni2V.png" alt="jmc"><br><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-16-jmc-1-5ultLq.png" alt="jmc-1"><br><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-16-jmc-2-gKxxpd.png" alt="jmc-2"><br><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-16-jmc-3-GleUio.png" alt="jmc-3"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;JVM-命令行工具&quot;&gt;&lt;a href=&quot;#JVM-命令行工具&quot; class=&quot;headerlink&quot; title=&quot;JVM 命令行工具&quot;&gt;&lt;/a&gt;JVM 命令行工具&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;工具&lt;/th&gt;
&lt;th&gt;简介&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;java&lt;/td&gt;
&lt;td&gt;Java 应用的启动程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;javac&lt;/td&gt;
&lt;td&gt;JDK 内置的编译工具&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;javap&lt;/td&gt;
&lt;td&gt;反编译 class 文件的工具&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;javadoc&lt;/td&gt;
&lt;td&gt;根据 Java 代码和标准注释,自动生成相关的API说明文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;javah&lt;/td&gt;
&lt;td&gt;JNI 开发时, 根据 java 代码生成需要的 .h文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;extcheck&lt;/td&gt;
&lt;td&gt;检查某个 jar 文件和运行时扩展 jar 有没有版本冲突，很少使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jdb&lt;/td&gt;
&lt;td&gt;Java Debugger ; 可以调试本地和远端程序, 属于 JPDA 中的一个 demo 实现, 供其他调试器参考。开发时很使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jdeps&lt;/td&gt;
&lt;td&gt;探测 class 或 jar 包需要的依赖&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jar&lt;/td&gt;
&lt;td&gt;打包工具，可以将文件和目录打包成为 .jar 文件；.jar 文件本质上就是 zip 文件, 只是后缀不同。使用时按顺序对应好选项和参数即可。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;keytool&lt;/td&gt;
&lt;td&gt;安全证书和密钥的管理工具; （支持生成、导入、导出等操作）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jarsigner&lt;/td&gt;
&lt;td&gt;JAR 文件签名和验证工具&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;policytool&lt;/td&gt;
&lt;td&gt;实际上这是一款图形界面工具, 管理本机的 Java 安全策略&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jps/jinfo&lt;/td&gt;
&lt;td&gt;查看 java 进程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;jstat&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;查看 JVM 内部 gc 相关信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;jmap&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;查看 heap 或类占用空间统计&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;jstack&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;查看线程信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jcmd&lt;/td&gt;
&lt;td&gt;执行 JVM 相关分析命令（整合命令）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jrunscript/jjs&lt;/td&gt;
&lt;td&gt;执行 js 命令&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记（一）</title>
    <link href="http://yonghong.tech/reading-notes/001/"/>
    <id>http://yonghong.tech/reading-notes/001/</id>
    <published>2021-05-31T13:00:00.000Z</published>
    <updated>2021-05-31T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="《秒赞》林桂枝"><a href="#《秒赞》林桂枝" class="headerlink" title="《秒赞》林桂枝"></a>《秒赞》林桂枝</h2><p>1.你的样子里，有你走过的路，读过的书，看过的风景。</p><p>2.想当垃圾吃垃圾，想当辣椒吃辣椒，想当什么自己要想好吃什么。</p><ul><li>创建“好东西”文件夹，在里面放好的设计与照片、出色的演讲、有见地的文章、有趣的事物。</li><li>准备一个“好东西”本子，随时记录有趣的对话和文字，补充新词汇，不断丰富自己的储备。</li><li>将自己认为“有感觉”的词汇记下来，接着将这些词汇分给不同的人和不同的事物，想想这些词该给谁，与什么东西结合最有意思。</li><li>读完一本书，写个简短的读书心得；看完一部电影，记录自己的感受。有时间多写，忙的话写几行字也可以。</li><li>你记录的点点滴滴将会成为你个人的宝贵资产，你的缪斯女神，更是让你工作顺利、表现优秀的利器。</li></ul><p>3.人能想象到的一切都是真实的。——毕加索</p><span id="more"></span><hr><h2 id="《财务自由之路-I》博多·舍费尔"><a href="#《财务自由之路-I》博多·舍费尔" class="headerlink" title="《财务自由之路 I》博多·舍费尔"></a>《财务自由之路 I》博多·舍费尔</h2><p>1.我将生活简化为5个领域：健康、财务、关系、情感和人生意义。5个领域都同等重要。</p><p>2.为什么人们想在短期内变得富有？因为他们想获得足够的能为他们服务的金钱。因为他们想拥有一台赚钱机器，而非穷其一生当一台赚钱机器。因为他们想拥有足够的资金，以过上一种收支平衡的生活。</p><p>3.你的事业建立在你最大的爱好之上。用你的爱好来赚钱。花点时间分析一下，你真正感兴趣的是什么、你的才能在哪方面，之后你才有可能从事一份自己既感兴趣又能赚钱的工作。</p><p>4.责任这个单词在英语中叫作“responsibility”，在这个单词中隐藏着另外两个单词“response”（回应）和“ability”（技巧）。因此，责任这一词用英语来解释就是：有技巧地进行回应。以争吵应对争执，以冲突应对挑衅，绝非最佳的问题解决方式。</p><p>5.如果提的问题是“谁来负责任”，那我们就是在寻找借口。当我们说“你负有责任”时，将事情引向积极方向的机会就消失了。而且，这个关于责任的问题还会将我们一直引向过去。正确的提问应该是：“在当时谁应该对此负责？”但你现在不能拓宽你当时的可控领域，所以需要将精力运用在当下。我们提出的问题也应该以当下为中心：我们现在能做些什么？</p><p>6.日记本是空白的书籍，是你可以自己写作的书籍，专属于你个人。每个人都应该每天写自己的成功日记，记录下当天所有的成功事件：你获得的每一次夸奖和每一次认可，无论是你遵守纪律，完成一项任务，还是你使某人快乐。…… 随着时间的推移，你还需要一本思想日记本（记录你的所有创意）、一本关系日记本（记录所有使你快乐的关系）、一本知识日记本（记录你从自己犯过的错误中学到的所有东西，使你以后不会再重蹈覆辙），以及其他内容的日记本……</p><p>7.去为你的劣势找到解决方案，去为你的优势找一个教练吧！</p><p>8.你在未来5年当中可以休息一整年。在一整年的时间里，你可以做想做的任何事，并有能力支付这一年的所有账单。你可以去旅行，做使你快乐但平时又没有足够时间来做的事情。</p><p>9.一致性不是绝对的美德。如果我今天的观点与昨天不同，是不是就因为改变自身方向而没有一致性了呢？我的确与自己的过去不相一致了，但于真理而言，我是保持一致了……一致性在于按照认知去追随真理。</p><p>10.借口是我们讲给自己听的谎言。我们应该自己对自己越来越诚实，承担越来越多的责任。</p><p>11.全世界最富有的投资者沃伦·巴菲特说过：“毕竟，只有当潮水退去时，你才知道谁在裸泳。”</p><p>12.恐惧永远不应该左右你的决定。因为世界上不存在失败。是的，你没有看错：世界上不存在失败。美国脱口秀大师奥普拉·温弗瑞曾经说过：“我不相信失败。因为如果你享受了过程中的乐趣，那这就不是失败。”</p><p>13.“如果你不经常犯错，表明你冒的风险不够，没有付出最大的努力。”</p><hr><h2 id="《财务自由之路-II》博多·舍费尔"><a href="#《财务自由之路-II》博多·舍费尔" class="headerlink" title="《财务自由之路 II》博多·舍费尔"></a>《财务自由之路 II》博多·舍费尔</h2><p>1.正如爱因斯坦（Einstein）所言，我相信“每个孩子都可能是天才”。我们中的每个人，您和我至少在某方面有着特殊的天赋，而我们应该把这些天赋发挥到极致。</p><p>2.对于大多数人来说，薪水其实是给自己的赔偿费。</p><p>3.当您成功时，生活的大门为您敞开。虽然在通向胜利的道路上，您将会常常看到地狱，然而生活就是如此。但是，如果您坚持梦想，就不会被打倒。您将得到想得到的一切，还有很多很多其他的东西。<br>——弗莱明思（J.Flemmings）</p><p>4.一幢房子是一种负债，而非投资。并且，他希望我首先进行投资。他的原则是：“当您攒够一定数量的资金之后，再购置房产。而且，房子的价值不应超出年净收入的4倍，并且您每月分期付款不应超过月收入的25%。”</p><p>5.许多人仅仅从经济角度来考虑他们的主要事业。他们遵循这样的信条：“什么能赚钱，什么就是我的主要事业。”依我看，这是个完全错误的开端。</p><hr><h2 id="《权力》杰弗瑞·菲佛"><a href="#《权力》杰弗瑞·菲佛" class="headerlink" title="《权力》杰弗瑞·菲佛"></a>《权力》杰弗瑞·菲佛</h2><p>1.处在一个权力小、地位低的职位上可能会危害你的健康，相反，拥有权力及相应的控制权则会延长你的寿命。</p><p>2.你要克服自己这个障碍，克服对自我形象的过分关注，或者是特别在意别人对你的看法。无论如何，其他人不会特别关心或惦记你，他们关注的主要是他们自己。如果你不去尝试获得影响力，你也许能够维护良好的形象，但却无法登上权力的顶峰。</p><p>3.雇员的薪酬与他们的年龄和在组织中任期长短的关系，强于薪酬与工作绩效的关系。</p><p>4.掌权者自我感觉良好，最好的方法之一就是恭维他们。</p><p>5.为你的成功负责的人，是你的上司，是有权力提升你或者阻止你在组织中晋升的人。而且不管你的位置在哪里，总会有人在你上面。所以你的工作就是，确保那些有影响力的人有强烈的愿望让你获得成功。这可能需要你做好工作，但也可能需要确保掌权者知道你的工作做得很好，确保他们记得你，对你的评价很高，因为你能让他们自我感觉良好。业绩和职场政治技巧结合在一起，才能帮助你获得晋升。只靠业绩本身是不够的，在某些情况下，业绩甚至可能是无关痛痒的。</p><p>6.一些人晋升到很高的位置并成就了惊人的事业，他们与其他人的不同之处有两点：意愿和技能。意愿是使人愿意承担巨大挑战的驱动力，技能则是把雄心转换为成就的能力。意愿体现在个人素质中，就是雄心、精力和专注。而有助于获得权力的4项技能，则分别是自知之明和反省心态、散发自信的信心和能力、理解他人并懂得换位思考以及化解冲突的能力。在对以上每个特质进行说明之后，我将讨论另一个特质：智力。智力和权力有些关系，但我认为它被严重高估了。</p><p>7.如果你对你的工作值多少回报没有自信，对你想要的东西也不自信，你就不愿意要求或者推动别人，因此，相较于那些比你活跃的人而言，你获得的金钱或影响力就比较少。</p><p>8.引人注意可以帮助你获得你需要的位置和权力。你应该为你想要的东西提出请求，并且在为自己构建权力之路时，不要太在乎别人怎么看你。但是，要获得和行使权力，就需要资源来奖励你的朋友和惩罚你的敌人，需要信息和门路来促进你在组织中的升迁。</p><p>9.事实上人们常犯的一个严重错误是，他们以为在目前的职位上无法建立权力基础和掌握资源，以为需要在更高的职位上才能这样做。其实，如果你把权力基础打好，那么攀升到更高的职位就会变得更简单容易一些，而且你在任何时候都可以这样做，永远都不会太早或太迟。</p><p>10.领导的实质就是：让拥有不同能力和视角的人或部门协作，共同完成一项任务或达成一桩交易。</p><p>11.领导力的秘诀就是要扮演角色，要装模作样，要在这门舞台艺术上富于技巧。</p><p>12.与表达悲伤、内疚或自责的人相比，表达愤怒的人通常被视为更加强大。</p><p>13.领导力的秘诀就是要扮演角色，要装模作样，要在这门舞台艺术上富于技巧。</p><p>14.我们选择了我们行事和说话的方式，这些决定对于获取和保持权力而言非常重要。</p><p>15.“权力之中有20%是被赋予的，有80%是自己获取的。”</p><p>16.一旦人们对某个人形成了印象，他们就不会承认任何与他们最初想法不一致的信息。</p><p>17.行为动力机制倾向于巩固人们的初步印象和声望，并倾向于让这些印象成真，即使它们一开始并不是真的。</p><p>18.这里的建议不是让你在任何一个单一的地方留下良好的印象，而是建议你找到一个可以让你树立辉煌声望的环境，也就是建议你不断尝试不同的环境，直到你成功地发现了这样一个环境为止。</p><p>19.由于人们来自不同的背景，面临的激励机制不同，获得的信息不同，所以他们所看到的世界也各不相同。因此在组织中，分歧是不可避免的。令人遗憾的是，许多人都会尝试避免冲突，他们认为分歧令人不快，因此他们避免让不同的意见浮出水面，也避免与对手进行艰难的交谈。</p><p>20.如果你处在一个权力相当大的位置上，而你觉得自己变得越来越疲倦时，那你还不如离开这个位置。</p><p>21.人们包括公司都容易落入能力陷阱。他们曾以某种方式做某些事，并获得了成功。</p><p>22.有些人以为自己不喜欢或者不可能喜欢玩权力游戏。但他们根本就没有尝试过，又如何知道自己会不喜欢呢？</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;《秒赞》林桂枝&quot;&gt;&lt;a href=&quot;#《秒赞》林桂枝&quot; class=&quot;headerlink&quot; title=&quot;《秒赞》林桂枝&quot;&gt;&lt;/a&gt;《秒赞》林桂枝&lt;/h2&gt;&lt;p&gt;1.你的样子里，有你走过的路，读过的书，看过的风景。&lt;/p&gt;
&lt;p&gt;2.想当垃圾吃垃圾，想当辣椒吃辣椒，想当什么自己要想好吃什么。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建“好东西”文件夹，在里面放好的设计与照片、出色的演讲、有见地的文章、有趣的事物。&lt;/li&gt;
&lt;li&gt;准备一个“好东西”本子，随时记录有趣的对话和文字，补充新词汇，不断丰富自己的储备。&lt;/li&gt;
&lt;li&gt;将自己认为“有感觉”的词汇记下来，接着将这些词汇分给不同的人和不同的事物，想想这些词该给谁，与什么东西结合最有意思。&lt;/li&gt;
&lt;li&gt;读完一本书，写个简短的读书心得；看完一部电影，记录自己的感受。有时间多写，忙的话写几行字也可以。&lt;/li&gt;
&lt;li&gt;你记录的点点滴滴将会成为你个人的宝贵资产，你的缪斯女神，更是让你工作顺利、表现优秀的利器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.人能想象到的一切都是真实的。——毕加索&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://yonghong.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://yonghong.tech/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 04 —— JVM 内存模型：堆和栈是什么？</title>
    <link href="http://yonghong.tech/java-advance/04-jvm-mem/"/>
    <id>http://yonghong.tech/java-advance/04-jvm-mem/</id>
    <published>2021-05-16T13:00:00.000Z</published>
    <updated>2021-05-16T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM-运行时数据区概述"><a href="#JVM-运行时数据区概述" class="headerlink" title="JVM 运行时数据区概述"></a>JVM 运行时数据区概述</h2><p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。结合 JVM 虚拟机规范，来讨论一下经典的 JVM 内存布局。</p><p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。而另外一些则是与线程一一对应的，这些与线对应的数据区域会随着线程开始和结束而创建和销毁。</p><span id="more"></span><h3 id="JVM-整体架构"><a href="#JVM-整体架构" class="headerlink" title="JVM 整体架构"></a>JVM 整体架构</h3><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-19-47-VusNfO-S1kg66.png" alt="JVM 整体架构 - 英文"></p><hr><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-19-46-8oddUR-oMwPkk.png" alt="JVM 整体架构 - 中文"></p><h3 id="JVM-系统线程"><a href="#JVM-系统线程" class="headerlink" title="JVM 系统线程"></a>JVM 系统线程</h3><p>线程是一个程序里的运行单元。JVM 允许一个应用有多个线程并行的执行</p><p>在 HotSpot 虚拟机里，每个线程都与操作系统的本地线程直接映射。当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java 线程执行终止后，本地线程也会回收</p><p>操作系统负责所有的线程的安排调度到任何一个可用的 CPU 上。一旦本地线程初始化成功，它就会调用 Java 线程中的人run() 方法</p><p>如果你使用 jconsole 或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用 public static void main(String[] args) 的 main 线程以及所有这个 main 线程自己创建的线程。</p><p>这些主要的后台系统线程在 HotSpot 虚拟机里主要是以下几个</p><ul><li>虚拟机线程：这种线程的操作是需要 JVM 达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要 JVM 达到安全点，这样堆才不会变化。这种线程的执行类型包括“stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</li><li>GC 线程：这种线程对在 JVM 里不同种类的垃圾收集行为提供了支持</li><li>编译线程：这种线程在运行时会将字节码编译成本地代码</li><li>信号调度线程：这种线程接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理</li></ul><h2 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-39-01-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-OjY1mD.png" alt="JVM内存结构"></p><ul><li>每个线程只能访问自己的线程栈。</li><li>每个线程都不能访问（看不见）其他线程的局部变量。</li><li>所有原生类型的局部变量都存储在线程栈中，因此对其他线程是不可见的。</li><li>线程可以将一个原生变量值的副本传给另一个线程，但不能共享原生局部变量本身。</li><li>堆内存中包含了 Java 代码中创建的所有对象，不管是哪个线程创建的。其中也涵盖了包装类型（例如，Byte，Integer，Long等）。</li><li>不管是创建一个对象并将其值赋值给局部变量，还是赋值给另一个对象的成员变量，创建的对象都会被保存到堆内存中。</li></ul><hr><ul><li>如果是原生数据类型的局部变量，那么它的内容就全部保留在线程栈上。 </li><li>如果是对象引用，则栈中的局部变量槽位中保存着对象的引用地址，而实际的对象内容保存在堆中。</li><li>对象的成员变量与对象本身一起存储在堆上，不管成员变量的类型是原生数据类型，还是对象引用。</li><li>类的静态变量则和类定义一样都保存在堆中。</li></ul><hr><ul><li>总结一下：方法中使用的原生数据类型和对象引用地址在栈上存储；对象、对象成员与类定义、静态变量在堆上。</li><li>堆内存又称为“共享堆”，堆中的所有对象，可以被所有线程访问，只要他们能拿到对象的引用地址。</li><li>如果一个线程可以访问某个对象时，也就可以访问该对象的成员变量。</li><li>如果两个线程同时调用某个对象的同一方法，则它们都可以访问到这个对象的成员变量，但每个线程的局部变量副本是独立的。</li></ul><h2 id="JVM-内存整体结构"><a href="#JVM-内存整体结构" class="headerlink" title="JVM 内存整体结构"></a>JVM 内存整体结构</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-41-01-JVM%E5%86%85%E5%AD%98%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84-eSeqP8.png" alt="JVM内存整体结构"></p><ul><li>每启动一个线程，JVM就会在栈空间栈分配对应的线程栈，比如 1MB 空间（-Xss1m） </li><li>线程栈也叫做 Java 方法栈。如果使用了 JNI 方法，则会分配一个单独的本地方法栈（Native Stack） </li><li>线程执行过程中，一般会有多个方法组成调用栈（Stack Trace），比如 A 调用 B，B 调用 C 。每执行到一个方法，就会创建对应的栈帧（Frame）。</li></ul><h2 id="JVM-栈内存机构"><a href="#JVM-栈内存机构" class="headerlink" title="JVM 栈内存机构"></a>JVM 栈内存机构</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-44-01-JVM%E6%A0%88%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-Z8QlQS.png" alt="JVM栈内存结构"></p><ul><li>栈帧是一个逻辑上的概念，具体的大小在一个方法编写完成后基本上就能确定。 </li><li>比如返回值，需要有一个空间存放吧，每个局部变量都需要对应的地址空间，此外还有给指令使用的操作数栈，以及 Class 指针（标识这个栈帧对应的是哪个类的方法，指向非堆里面的 Class 对象）。</li></ul><h2 id="JVM-堆内存结构"><a href="#JVM-堆内存结构" class="headerlink" title="JVM 堆内存结构"></a>JVM 堆内存结构</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-45-01-JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-0TRoeN.png" alt="JVM堆内存结构"></p><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-46-01-jconsole%E5%86%85%E5%AD%98-KNrKkU.png" alt="jconsole内存"></p><ul><li>堆内存是所有线程共用的内存空间，JVM 将 Heap 内存分为年轻代（Young generation）和老年代（Old generation，也叫 Tenured）两部分。</li><li>年轻代还划分为3个内存池，伊甸园区（Eden space）和存活区（Survivor space），在大部分GC算法中有两个存活区（S0，S1），在我们可以观察到的任何时刻，S0和S1总有一个是空的，但一般很小，也浪费不了多少空间。</li><li>Non-Heap本质上还是Heap，只是一般不归GC管理，里面划分为3个内存区池。</li><li>Metaspace 以前叫持久代（永久代，Permanent generation），Java 换了个名字叫 Metaspace</li><li>CCS Compressed Class Space，存放 class 信息的，和 Metaspace 有交叉</li><li>Code Cache，存放 JIT 编译器编译后的本地机器代码。</li></ul><h2 id="CPU-与内存行为"><a href="#CPU-与内存行为" class="headerlink" title="CPU 与内存行为"></a>CPU 与内存行为</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-47-01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84-3aWMrH.png" alt="计算机硬件架构"></p><ul><li>CPU 乱序执行</li><li>volatile 关键字</li><li>原子性操作</li><li>内存屏障</li></ul><h2 id="Java对象模型"><a href="#Java对象模型" class="headerlink" title="Java对象模型"></a>Java对象模型</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-47-01-Java%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-K1uNvD.png" alt="Java对象模型"></p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-47-01-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-G12dzM.jpg" alt="Java内存模型"></p><p>JMM 规范对应的是 JSR-133 Java Memory Model and Thread Specification 《Java 语言规范》 $17.4 Memory Model 章节</p><p>JMM 规范明确定义了不同的线程之间通过哪些方式，在什么时候可以看见其他线程保存到共享变量中的值；以及在必要时，如何对共享变量的访问进行同步。这样的好处是屏蔽各种硬件平台的操作系统之间的内存访问差异，实现了Java并发程序真正的跨平台。</p><ul><li>所有的对象（包括内部的实例成员变量），static 变量，以及数组，都必须存放到堆内存中。</li><li>局部变量，方法的形参/入参，异常处理语句的入参不允许在线程之间共享，所以不受内存模型的影响。</li><li>多个线程同时对一个变量访问时【读取/写入】，这时候只要有某个线程执行的是写操作，那么这种现象称之为“冲突”。</li><li>可以被其他线程影响或感知的操作，称为线程间的交互行为，可分为：读取、写入、同步操作、外部操作等等。其中同步操作包括：对 volatile 变量的读写，对管程（monitor）的锁定与解锁，线程的起始操作与结尾操作，线程启动和结束等等。外部操作则是指对线程执行环境之外的操作，比如停止其他线程等等。</li><li>JMM 规范的是线程间的交互操作，而不管线程内部对局部变量进行的操作。</li></ul><hr><h2 id="JVM-启动参数"><a href="#JVM-启动参数" class="headerlink" title="JVM 启动参数"></a>JVM 启动参数</h2><ul><li>以 - 开头为标准参数，所有的 JVM 都要实现这些参数，并且向后兼容。例，<code>-server</code></li><li>-D 设置系统属性。例，<code>-Dfile.encoding=UTF-8</code></li><li>以 -X 开头为非标准参数，基本都是传给 JVM 的，默认 JVM 实现这些参数的功能，但是并不保证所有 JVM 实现都满足，且不保证向后兼容。可以使用 <code>java -X</code> 命令来查看当前 JVM 支持的非标准参数。例，<code>-Xmx8g</code></li><li>以 -XX: 开头为非稳定参数，专门用于控制 JVM 的行为，跟具体的 JVM 实现有关，随时可能会在下个版本取消。<ul><li>-XX: +-Flags 形式，+-是对布尔值进行开关。例，<code>-XX:+UseG1GC</code></li><li>-XX: key=value 形式，指定某个选项的值。例，<code>-XX:MaxPermSize=256m</code></li></ul></li></ul><p>1.系统属性参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-Dfile.encoding=UTF-<span class="number">8</span></span><br><span class="line">-Duser.timezone=GMT+08</span><br><span class="line">-Dmaven.test.skip=<span class="keyword">true</span></span><br><span class="line">-Dio.netty.eventLoopThreads=<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以这样</span></span><br><span class="line">System.setProperty(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;A100&quot;</span>);</span><br><span class="line">String a = System.getProperty(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure><p>2.运行模式参数</p><ul><li>-server: 设置 JVM 使用 server 模式，特点是启动速度比较慢，但运行时性能和内存管理效率很高，适用于生产环境。在具有 64 位能力的 JDK 环境下将默认启用该模式，而忽略 -client 参数。</li><li>-client: JDK1.7 之前在32位的 x86 机器上的默认值是 -client 选项。设置 JVM 使用 client 模式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或者 PC 应用开发和调试。此外，我们知道 JVM 加载字节码后，可以解释执行，也可以编译成本地代码再执行，所以可以配置 JVM 对字节码的处理模式。</li><li>-Xint: 在解释模式(interpreted mode)下运行，-Xint 标记会强制 JVM 解释执行所有的字节码，这当然会降低运行速度，通常低10倍或更多。</li><li>-Xcomp: -Xcomp 参数与 -Xint 正好相反，JVM 在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化。【注意预热】</li><li>-Xmixed: -Xmixed 是混合模式，将解释模式和编译模式进行混合使用，有 JVM 自己决定，这是 JVM 的默认模式，也是推荐模式。 我们使用 java -version 可以看到 mixed mode 等信息。</li></ul><p>3.堆内存设置参数</p><ul><li>-Xmx, 指定最大堆内存。 如 -Xmx4g. 这只是限制了 Heap 部分的最大值为4g。这个内存不包括栈内存，也不包括堆外使用的内存。</li><li>-Xms, 指定堆内存空间的初始大小。 如 -Xms4g。 而且指定的内存大小，并不是操作系统实际分配的初始值，而是GC先规划好，用到才分配。专用服务器上需要保持 –Xms 和 –Xmx 一致，否则应用刚启动可能就有好几个 FullGC。 当两者配置不一致时，堆内存扩容可能会导致性能抖动。</li><li>-Xmn, 等价于 -XX:NewSize，使用 G1 垃圾收集器 不应该 设置该选项，在其他的某些业务场景下可以设置。官方建议设置为 -Xmx 的 1/2 ~ 1/4.</li><li>-XX:MaxPermSize=size, 这是 JDK1.7 之前使用的。Java8 默认允许的 Meta空间无限大，此参数无效。</li><li>-XX:MaxMetaspaceSize=size, Java8 默认不限制 Meta 空间, 一般不允许设置该选项。</li><li>-XX:MaxDirectMemorySize=size，系统可以使用的最大堆外内存，这个参数跟 -Dsun.nio.MaxDirectMemorySize 效果相同。</li><li>-Xss, 设置每个线程栈的字节数，影响栈的深度。 例如 -Xss1m 指定线程栈为 1MB，与-XX:ThreadStackSize=1m 等价</li></ul><ol><li>如果什么都不配置会如何?</li><li>Xmx 是否与 Xms 设置相等?</li><li>Xmx 设置为机器内存的什么比例合适?</li><li>作业: 画一下 Xmx、Xms、Xmn、Meta、DirectMemory、Xss 这些内存参数的关系</li></ol><p>4.GC设置参数</p><ul><li>-XX:+UseG1GC:使用 G1 垃圾回收器 </li><li>-XX:+UseConcMarkSweepGC:使用 CMS 垃圾回收器 </li><li>-XX:+UseSerialGC:使用串行垃圾回收器 </li><li>-XX:+UseParallelGC:使用并行垃圾回收器</li><li>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC // Java 11+</li><li>-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC // Java 12+</li></ul><p>各个 JVM 版本的默认 GC 是什么?</p><p>5.分析诊断参数</p><ul><li>-XX:+-HeapDumpOnOutOfMemoryError 选项, 当 OutOfMemoryError 产生，即内存溢出(堆内存或持久代)时，自动 Dump 堆内存。<ul><li>示例用法: java -XX:+HeapDumpOnOutOfMemoryError -Xmx256m ConsumeHeap</li></ul></li><li>-XX:HeapDumpPath 选项, 与 HeapDumpOnOutOfMemoryError 搭配使用, 指定内存溢出时 Dump 文件的目 录。如果没有指定则默认为启动 Java 程序的工作目录。<ul><li>示例用法: java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/ ConsumeHeap </li><li>自动 Dump 的 hprof 文件会存储到 /usr/local/ 目录下</li></ul></li><li>-XX:OnError 选项, 发生致命错误时(fatal error)执行的脚本。<ul><li>例如, 写一个脚本来记录出错时间, 执行一些命令, 或者 curl 一下某个在线报警的 url. 示例用法:java -XX:OnError=”gdb - %p” MyApp</li><li>可以发现有一个 %p 的格式化字符串，表示进程 PID。</li></ul></li><li>-XX:OnOutOfMemoryError 选项, 抛出 OutOfMemoryError 错误时执行的脚本。 </li><li>-XX:ErrorFile=filename 选项, 致命错误的日志文件名,绝对路径或者相对路径。</li><li>-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1506，远程调试</li></ul><p>6.JavaAgent参数</p><p>Agent 是 JVM 中的一项黑科技, 可以通过无侵入方式来做很多事情，比如注入 AOP 代码，执行统计等等，权限非常大。这里简单介绍一下配置选项，详细功能需要专门来讲。</p><p>设置 agent 的语法如下:</p><ul><li>-agentlib:libname[=options] 启用 native 方式的 agent, 参考 LD_LIBRARY_PATH 路径。</li><li>-agentpath:pathname[=options] 启用 native 方式的 agent。</li><li>-javaagent:jarpath[=options] 启用外部的 agent 库, 比如 pinpoint.jar 等等。</li><li>-Xnoagent 则是禁用所有 agent。 以下示例开启 CPU 使用时间抽样分析:<ul><li>JAVA_OPTS=”-agentlib:hprof=cpu=samples,file=cpu.samples.log”</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;JVM-运行时数据区概述&quot;&gt;&lt;a href=&quot;#JVM-运行时数据区概述&quot; class=&quot;headerlink&quot; title=&quot;JVM 运行时数据区概述&quot;&gt;&lt;/a&gt;JVM 运行时数据区概述&lt;/h2&gt;&lt;p&gt;内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。结合 JVM 虚拟机规范，来讨论一下经典的 JVM 内存布局。&lt;/p&gt;
&lt;p&gt;Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。而另外一些则是与线程一一对应的，这些与线对应的数据区域会随着线程开始和结束而创建和销毁。&lt;/p&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 03 —— 类加载器和双亲委派到底是什么？</title>
    <link href="http://yonghong.tech/java-advance/03-jvm-classloader/"/>
    <id>http://yonghong.tech/java-advance/03-jvm-classloader/</id>
    <published>2021-05-15T13:00:00.000Z</published>
    <updated>2021-05-15T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类加载子系统作用"><a href="#类加载子系统作用" class="headerlink" title="类加载子系统作用"></a>类加载子系统作用</h2><ul><li>类加载子系统负责从文件系统或者网络中加载 Class 文件，Class 文件在文件开头有特定的文件标识（cafebabe）</li><li>ClassLoader 只负责 Class 文件的加载，至于它是否能够运行，则由 Execution Engine 决定</li><li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区还存放运行时常量池信息，可能还包含字符串字面值和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）</li></ul><span id="more"></span><h2 id="类加载器的角色"><a href="#类加载器的角色" class="headerlink" title="类加载器的角色"></a>类加载器的角色</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-20-16-U6ND22-TgTnLm.png" alt="类加载器的角色"></p><ul><li>class file 存放于本地硬盘上，可以理解成设计师画在纸上的模板，最终这个模板在执行的时候要加载到 JVM 中来，根据这个文件实例化出 n 个一模一样的实例</li><li>class file 加载到 JVM 中，被称为 DNA 原数据模板，放在方法区</li><li>在 class 文件 -&gt; JVM -&gt; 最终成为原数据模板，此过程需要一个运输工具，即类加载器 Class Loader，扮演一个快递员的角色</li></ul><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-18-01-%E7%B1%BB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%847%E4%B8%AA%E6%AD%A5%E9%AA%A4-r3r8RQ.png" alt="类生命周期的7个步骤"></p><ol><li>加载（Loading）：找Class文件</li><li>验证（Verification）：验证格式、依赖</li><li>准备（Preparation）：静态字段、方法表</li><li>解析（Resolution）：符号解析为引用</li><li>初始化（Initialization）：构造器、静态变量赋值、静态代码块</li><li>使用（Using）</li><li>卸载（Unloading）</li></ol><h3 id="Loading-阶段"><a href="#Loading-阶段" class="headerlink" title="Loading 阶段"></a>Loading 阶段</h3><ol><li><p>通过一个类的全限定名获取定义此类的二进制字节流</p></li><li><p>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据区</p></li><li><p><strong>在内存中生成一个代表这个类的 java.lang.Class 对象</strong>，作为方法区这个类的各种数据的访问入口</p></li></ol><p>补充：加载 class 文件的方式</p><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从 zip 压缩包中读取，成为日后 jar、war 格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP 应用</li><li>从专有数据库中提取 class 文件，比较少见</li><li>从加密文件中获取，典型的防 class 文件被反编译的保护措施</li></ul><h3 id="Linking-阶段"><a href="#Linking-阶段" class="headerlink" title="Linking 阶段"></a>Linking 阶段</h3><p>1.验证（Verify）：</p><ul><li>目的在于确保 class 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机的自身安全</li><li>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证</li></ul><p>2.准备（Prepare）：</p><ul><li>为类变量分配内存并且设置该类变量的默认初始值，即零值</li><li>这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，准备阶段会显示初始化</li><li>这里不会为实例变量分配初始值，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中</li></ul><p>3.解析（Resolve）：</p><ul><li>将常量池内的符号引用转换为直接引用的过程</li><li>事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java 虚拟机规范》的 class 文件格式中。直接引用就是直接指向目标的指针、相对偏移量或者一个间接定位到目标的句柄</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等。</li></ul><h3 id="Initialization-阶段"><a href="#Initialization-阶段" class="headerlink" title="Initialization 阶段"></a>Initialization 阶段</h3><ul><li>初始化阶段就是执行类构造器方法 <code>&lt;clinit&gt;()</code> 的过程</li><li>此方法不需要定义，是 javac 编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来</li><li>构造器方法中指令按语句在源文件中出现的顺序执行</li><li><code>&lt;clinit&gt;()</code> 不同于类的构造器。（关联：构造器是虚拟机视角下的 <code>&lt;init&gt;()</code>）</li><li>若该类具有父类，JVM 会保证子类的 <code>&lt;clinit&gt;()</code> 执行前，父类的 <code>clinit()</code> 已经执行完毕</li><li>虚拟机必须保证一个类的 <code>clinit()</code> 方法在多线程下被同步加载</li></ul><h2 id="类的加载时机"><a href="#类的加载时机" class="headerlink" title="类的加载时机"></a>类的加载时机</h2><ol><li>当虚拟机启动时，初始化用户指定的主类，就是启动执行的main方法所在的类；</li><li>当遇到用一新建目标类实例的new指令时，初始化new指令的目标类，就是new一个类的时候要初始化；</li><li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li><li>当遇到访问静态字段的指令时，初始化该静态字段所在的类；</li><li>子类的初始化会触发父类的初始化；</li><li>如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类初始化，会触发该接口的初始化；</li><li>使用反射API对某个类型进行反射调用时，初始化这个类，其实跟前面一样，反射调用要么是已经有实例了，要么是静态方法，都需要初始化；</li><li>当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类；</li></ol><h3 id="不会初始化（可能会加载）"><a href="#不会初始化（可能会加载）" class="headerlink" title="不会初始化（可能会加载）"></a>不会初始化（可能会加载）</h3><ol><li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化；</li><li>定义对象数组，不会触发该类的初始化；</li><li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类；</li><li>通过类名获取Class对象，不会触发类的初始化，Hello.class不会让Hello类初始化；</li><li>通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化，Class.forName(“jvm.Hello”) 默认会加载Hello类；</li><li>通过ClassLoader默认的loadClass方法，也不会触发初始化动作（加载了，但是不会初始化）；</li></ol><h2 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-23-01-3%E4%B8%AA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-pnd3RO.png" alt="3个类加载器"></p><ul><li>启动类加载器（引导类加载器，Bootstrap ClassLoader）<ul><li>这个类加载器使用 C/C++ 语言实现的，嵌套在 JVM 内部</li><li>它用来加载 Java 的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类</li><li>并不继承自 java.lang.ClassLoader，没有父加载器。</li><li>加载拓展类和应用程序类加载器，并指定为他们的父类加载器</li><li>出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类</li></ul></li><li>拓展类加载器（Extension ClassLoader）<ul><li>Java 语言编写，由 sun.misc.Launcher$ExtClassLoader 实现</li><li>派生于 ClassLoader 类</li><li>父类加载器为启动类加载器</li><li>从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/lib/ext 子目录（拓展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由拓展类加载器加载</li></ul></li><li>应用程序类加载器（系统类加载器，AppClassLoader）<ul><li>java 语言编写，由 sun.misc.Launcher$AppClassLoader 实现</li><li>派生于 ClassLoader 类</li><li>父类加载器为拓展类加载器</li><li>他负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java 应用的类都是由它来完成加载</li><li>通过 ClassLoader$getSystemClassLoader() 方法可以获取到该类加载器</li></ul></li></ul><p>类加载器可以通过getParent获取父加载器，这并不是继承关系，如果直接继承ClassLoader自己实现一个类加载器，且不指定父加载器，他的父加载器就是AppClassLoader</p><p>任何parent为null的加载器，其父加载器为 BootstrapClassLoader</p><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-26-01-%E6%8B%93%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%BA%94%E7%94%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-PRIfeU.png" alt="拓展类加载器和应用类加载器"></p><h2 id="加载器特点"><a href="#加载器特点" class="headerlink" title="加载器特点"></a>加载器特点</h2><h3 id="双亲委托"><a href="#双亲委托" class="headerlink" title="双亲委托"></a>双亲委托</h3><p>Java 虚拟机对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p><ul><li>如果一个类加载器收到了类加载的请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li><li>如果父类加载器还存在其他父类加载器，则进一步向上委托，依次递归请求最终将到达顶层的启动类加载器</li><li>如果父类加载器可以完成类的加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制</li></ul><p><strong>优势</strong></p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心 API 被随意篡改</li></ul><p><strong>沙箱安全机制</strong></p><p>自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载过程中会率先加载 JDK 自带的文件（rt.jar 包中 java/lang/String.class），报错信息说没有 main 方法，就是因为加载的是rt.jar 包中的 String 类。这样可以保证对 Java 核心源代码的保护，这就是沙箱安全机制。</p><p>在 JVM 中表示两个 class 对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名</li><li>加载这个类的 ClassLoader （指 ClassLoader 实例对象）必须相同</li></ul><p>换句话说，在 JVM 中，即使这两个类对象（class 对象）来源于同一个 Class 文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的。</p><p>JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么 JVM 会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。</p><h3 id="负责依赖"><a href="#负责依赖" class="headerlink" title="负责依赖"></a>负责依赖</h3><p>如果一个类依赖了其他的类，那么就需要先加载依赖的类。</p><h3 id="缓存加载"><a href="#缓存加载" class="headerlink" title="缓存加载"></a>缓存加载</h3><p>类加载之后，就把它缓存起来，后续从缓存中获取</p><h2 id="关于-ClassLoader"><a href="#关于-ClassLoader" class="headerlink" title="关于 ClassLoader"></a>关于 ClassLoader</h2><p>ClassLoader 类，它是一个抽象类，其后所有的类加载器都继承自 ClassLoader （不包括启动类加载器）</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>getParent()</td><td>返回该类加载器的超类加载器</td></tr><tr><td>loadClass(String name)</td><td>加载名称为 name 的类，返回结果为 java.lang.Class 类的实例</td></tr><tr><td>findClass(String name)</td><td>查找名称为 name 的类，返回结果为 java.lang.Class 类的实例</td></tr><tr><td>findLoadedClass(String name)</td><td>查找名称为 name 的已经被加载过的类，返回结果为 java.lang.Class 类的实例</td></tr><tr><td>defineClass(String name, byte[] b, int off, int len)</td><td>把字节数组 b 中的内存转换成为一个 Java 类，返回结果为 java.lang.Class 类的实例</td></tr><tr><td>resolveClass(Class&lt;?&gt; c)</td><td>连接指定的一个 Java 类</td></tr></tbody></table><h2 id="获取-ClassLoader-的途径"><a href="#获取-ClassLoader-的途径" class="headerlink" title="获取 ClassLoader 的途径"></a>获取 ClassLoader 的途径</h2><p>方式一：获取当前类的 ClassLoader</p><p>clazz.getClassLoader()</p><p>方式二：获取当前线程上下文的 ClassLoader</p><p>Thread.currentThread().getContextClassLoader()</p><p>方式三：获取系统的ClassLoader</p><p>ClassLoader.getSystemClassLoader()</p><p>方式四：获取调用者的 CLassLoader</p><p>DriverManager.getCallerClassLoader()</p><h2 id="显示当前-ClassLoader-加载了哪些-Jar-？"><a href="#显示当前-ClassLoader-加载了哪些-Jar-？" class="headerlink" title="显示当前 ClassLoader 加载了哪些 Jar ？"></a>显示当前 ClassLoader 加载了哪些 Jar ？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmClassLoaderPrintPath</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动类加载器</span></span><br><span class="line">        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        System.out.println(<span class="string">&quot;启动类加载器&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; ===&gt; &quot;</span> + url.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓展类加载器</span></span><br><span class="line">        printClassLoader(<span class="string">&quot;拓展类加载器&quot;</span>, JvmClassLoaderPrintPath.class.getClassLoader().getParent());</span><br><span class="line">        <span class="comment">// 应用类加载器</span></span><br><span class="line">        printClassLoader(<span class="string">&quot;应用类加载器&quot;</span>, JvmClassLoaderPrintPath.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassLoader</span><span class="params">(String name, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot; ClassLoader -&gt; &quot;</span> + classLoader.toString());</span><br><span class="line">            printUrlForClassLoader(classLoader);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot; ClassLoader -&gt; null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUrlForClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        Object ucp = insightField(classLoader, <span class="string">&quot;ucp&quot;</span>);</span><br><span class="line">        Object path = insightField(ucp, <span class="string">&quot;path&quot;</span>);</span><br><span class="line">        ArrayList ps = (ArrayList) path;</span><br><span class="line">        <span class="keyword">for</span> (Object p : ps) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; ===&gt; &quot;</span> + p.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">insightField</span><span class="params">(Object obj, String fName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> URLClassLoader) &#123;</span><br><span class="line">                f = URLClassLoader.class.getDeclaredField(fName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f = obj.getClass().getDeclaredField(fName);</span><br><span class="line">            &#125;</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> f.get(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">启动类加载器</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/resources.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/rt.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/sunrsasign.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/jsse.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/jce.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/charsets.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/jfr.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/classes</span><br><span class="line">拓展类加载器 ClassLoader -&gt; sun.misc.Launcher$ExtClassLoader@6d06d69c</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/sunec.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/nashorn.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/cldrdata.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/dnsns.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/localedata.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/sunjce_provider.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/sunpkcs11.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/jaccess.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/zipfs.jar</span><br><span class="line"> ===&gt; file:/System/Library/Java/Extensions/MRJToolkit.jar</span><br><span class="line">应用类加载器 ClassLoader -&gt; sun.misc.Launcher$AppClassLoader@659e0bfd</span><br><span class="line"> ===&gt; file:/Users/yq/code/wangyonghong/code-lab/gtu-java/out/production/gtu-java/</span><br></pre></td></tr></table></figure><h2 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h2><ul><li><p>在 Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式</p></li><li><p>为什么要自定义类加载器</p><ul><li>隔离加载类</li><li>修改类加载方式</li><li>拓展加载源</li><li>防止源码泄露</li></ul></li><li><p>开发人员可以通过继承抽象类 java.lang.ClassLoader 类的方式，实现自己的类加载器，以满足一些特殊需求</p></li><li><p>在 JDK 1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载器类，但是在 JDK 1.2 之后已不再建议用户去覆盖 loadClass() 方法，而是建议把自定义的类加载逻辑写在 findClass() 方法中</p></li><li><p>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findClass() 方法以及获取字节码流的方式，使自定义类加载器编写更加简单</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, classLoader!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以下方法拿到 base64</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac Hello.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> base64 Hello.class</span> </span><br><span class="line">yv66vgAAADQAHAoABgAOCQAPABAIABEKABIAEwcAFAcAFQEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAAVoZWxsbwEAClNvdXJjZUZpbGUBAApIZWxsby5qYXZhDAAHAAgHABYMABcAGAEAE0hlbGxvLCBjbGFzc0xvYWRlciEHABkMABoAGwEABUhlbGxvAQAQamF2YS9sYW5nL09iamVjdAEAEGphdmEvbGFuZy9TeXN0ZW0BAANvdXQBABVMamF2YS9pby9QcmludFN0cmVhbTsBABNqYXZhL2lvL1ByaW50U3RyZWFtAQAHcHJpbnRsbgEAFShMamF2YS9sYW5nL1N0cmluZzspVgAhAAUABgAAAAAAAgABAAcACAABAAkAAAAdAAEAAQAAAAUqtwABsQAAAAEACgAAAAYAAQAAAAQAAQALAAgAAQAJAAAAJQACAAEAAAAJsgACEgO2AASxAAAAAQAKAAAACgACAAAABgAIAAcAAQAMAAAAAgAN</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过以下方法可以自定义ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yonghongwang#163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/4/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> HelloClassLoader().findClass(<span class="string">&quot;Hello&quot;</span>).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String helloBase64 = <span class="string">&quot;yv66vgAAADQAHAoABgAOCQAPABAIABEKABIAEwcAFAcAFQEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAAVoZWxsbwEAClNvdXJjZUZpbGUBAApIZWxsby5qYXZhDAAHAAgHABYMABcAGAEAE0hlbGxvLCBjbGFzc0xvYWRlciEHABkMABoAGwEABUhlbGxvAQAQamF2YS9sYW5nL09iamVjdAEAEGphdmEvbGFuZy9TeXN0ZW0BAANvdXQBABVMamF2YS9pby9QcmludFN0cmVhbTsBABNqYXZhL2lvL1ByaW50U3RyZWFtAQAHcHJpbnRsbgEAFShMamF2YS9sYW5nL1N0cmluZzspVgAhAAUABgAAAAAAAgABAAcACAABAAkAAAAdAAEAAQAAAAUqtwABsQAAAAEACgAAAAYAAQAAAAQAAQALAAgAAQAJAAAAJQACAAEAAAAJsgACEgO2AASxAAAAAQAKAAAACgACAAAABgAIAAcAAQAMAAAAAgAN&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = decode(helloBase64);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] decode(String base64) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getDecoder().decode(base64);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加类的几种方式？"><a href="#添加类的几种方式？" class="headerlink" title="添加类的几种方式？"></a>添加类的几种方式？</h2><ol><li>放到 JDK 的 lib/ext 下，或者 -Djava.ext.dirs=path</li><li>java -cp/classpath 或者 class 文件放到当前路径</li><li>自定义 ClassLoader 加载</li><li>拿到当前执行类的 ClassLoader，反射调用 addUrl 方法添加 Jar 或路径（JDK 9 之后平级了，可以使用 <code>Class.forName(&quot;xxx&quot;, new URLClassLoader(&quot;path&quot;));</code>）</li></ol><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>自定义一个 Classloader，加载一个 Hello.xlass 文件，执行 hello 方法， 此文件内容是一个 Hello.class 文件所有字节(x=255-x)处理后的文件。</p><p>题解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yonghongwang#163.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassloader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; helloClass = <span class="keyword">new</span> MyClassloader().findClass(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        Method helloMethod = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            helloMethod = helloClass.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            helloMethod.invoke(helloClass.newInstance());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) &#123;</span><br><span class="line">        String path = <span class="keyword">this</span>.getClass().getResource(<span class="string">&quot;Hello.xlass&quot;</span>).getPath();</span><br><span class="line">        File file;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file = <span class="keyword">new</span> File(URLDecoder.decode(path, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;failed to find path: &quot;</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile() &amp;&amp; file.exists()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (FileChannel channel = <span class="keyword">new</span> FileInputStream(file).getChannel()) &#123;</span><br><span class="line">                ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="keyword">int</span>) channel.size());</span><br><span class="line">                channel.read(byteBuffer);</span><br><span class="line">                bytes = byteBuffer.array();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;failed to find path: &quot;</span> + path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;failed to find path: &quot;</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, decode(bytes), <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * replace each byte with x-&gt;255-x</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] decode(<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line"><span class="comment">//            bytes[i] = (byte) (255 - bytes[i]);</span></span><br><span class="line">            bytes[i] = (<span class="keyword">byte</span>) ~bytes[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;类加载子系统作用&quot;&gt;&lt;a href=&quot;#类加载子系统作用&quot; class=&quot;headerlink&quot; title=&quot;类加载子系统作用&quot;&gt;&lt;/a&gt;类加载子系统作用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;类加载子系统负责从文件系统或者网络中加载 Class 文件，Class 文件在文件开头有特定的文件标识（cafebabe）&lt;/li&gt;
&lt;li&gt;ClassLoader 只负责 Class 文件的加载，至于它是否能够运行，则由 Execution Engine 决定&lt;/li&gt;
&lt;li&gt;加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区还存放运行时常量池信息，可能还包含字符串字面值和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 02 —— 是时候了解一下 Java 字节码了</title>
    <link href="http://yonghong.tech/java-advance/02-jvm-bytecode/"/>
    <id>http://yonghong.tech/java-advance/02-jvm-bytecode/</id>
    <published>2021-05-14T14:00:00.000Z</published>
    <updated>2021-05-14T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是字节码？"><a href="#什么是字节码？" class="headerlink" title="什么是字节码？"></a>什么是字节码？</h2><ul><li><p>我们平时所说的 Java 字节码，指的是用 Java 语言编译成的字节码。准确的说能在 JVM 平台上执行的字节码格式都是一样的。所以应该统称为 JVM 字节码。</p></li><li><p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的 JVM 上运行。</p></li><li><p>Java 虚拟机与 Java 语言并没有必然的联系，它只与特定的二进制文件格式 .class 文件格式所关联，.class 文件中包含了 Java 虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他的辅助信息。</p></li><li><p>Java bytecode 由单字节（byte）的指令组成，理论上最多支持 256 个操作码（opcode）。 实际上 Java 只使用了200左右的操作码，还有一些操作码则保留给调试操作。详情见：</p></li><li><p><a href="https://yonghong.tech/2021/01/jvm-instruction-set/">JVM 指令集对照表</a></p></li></ul><span id="more"></span><p>根据指令的性质，主要分为四个大类：</p><ol><li>栈操作指令，包括与局部变量交互的指令</li><li>程序流程控制指令</li><li>对象操作指令，包括方法调用指令</li><li>算术运算以及类型转换指令</li></ol><p>举个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloByteCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloByteCode obj = <span class="keyword">new</span> HelloByteCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac -g HelloByteCode.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> javap -c -v HelloByteCode</span></span><br><span class="line">Classfile /Users/yonghong/Coding/code-lab/gtu-java/week01/HelloByteCode.class</span><br><span class="line">  Last modified 2021-1-7; size 415 bytes</span><br><span class="line">  MD5 checksum 44dd68d97fffda0bd16a524fb32b983a</span><br><span class="line">  Compiled from &quot;HelloByteCode.java&quot;</span><br><span class="line">public class HelloByteCode</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52   // 52 对应 Java 8</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:        // 常量池</span><br><span class="line"><span class="meta">   #</span><span class="bash">1 = Methodref          <span class="comment">#4.#19         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">2 = Class              <span class="comment">#20            // HelloByteCode</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">3 = Methodref          <span class="comment">#2.#19         // HelloByteCode.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">4 = Class              <span class="comment">#21            // java/lang/Object</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">5 = Utf8               &lt;init&gt;</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">6 = Utf8               ()V</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">7 = Utf8               Code</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">8 = Utf8               LineNumberTable</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">9 = Utf8               LocalVariableTable</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">10 = Utf8               this</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">11 = Utf8               LHelloByteCode;</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">12 = Utf8               main</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">13 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">14 = Utf8               args</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">15 = Utf8               [Ljava/lang/String;</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">16 = Utf8               obj</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">17 = Utf8               SourceFile</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">18 = Utf8               HelloByteCode.java</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">19 = NameAndType        <span class="comment">#5:#6          // &quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash">20 = Utf8               HelloByteCode</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">21 = Utf8               java/lang/Object</span></span><br><span class="line">&#123;</span><br><span class="line">  public HelloByteCode();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   LHelloByteCode;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=1</span><br><span class="line">         0: new           #2                  // class HelloByteCode</span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0   // new 指令在源码的第 3 行</span><br><span class="line">        line 4: 8   // return 指令在源码的第 4 行</span><br><span class="line">      LocalVariableTable:   // 本地变量表</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">      // 起作用的行  生效范围  槽数  变量名称  变量类型签名</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">            8       1     1   obj   LHelloByteCode;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;HelloByteCode.java&quot;</span><br></pre></td></tr></table></figure><h3 id="javac-与-javap"><a href="#javac-与-javap" class="headerlink" title="javac 与 javap"></a>javac 与 javap</h3><p>javac 的用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac -<span class="built_in">help</span></span></span><br><span class="line">用法: javac &lt;options&gt; &lt;source files&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -g                         生成所有调试信息</span><br><span class="line">  -g:none                    不生成任何调试信息</span><br><span class="line">  -g:&#123;lines,vars,source&#125;     只生成某些调试信息</span><br><span class="line">  -nowarn                    不生成任何警告</span><br><span class="line">  -verbose                   输出有关编译器正在执行的操作的消息</span><br><span class="line">  -deprecation               输出使用已过时的 API 的源位置</span><br><span class="line">  -classpath &lt;路径&gt;            指定查找用户类文件和注释处理程序的位置</span><br><span class="line">  -cp &lt;路径&gt;                   指定查找用户类文件和注释处理程序的位置</span><br><span class="line">  -sourcepath &lt;路径&gt;           指定查找输入源文件的位置</span><br><span class="line">  -bootclasspath &lt;路径&gt;        覆盖引导类文件的位置</span><br><span class="line">  -extdirs &lt;目录&gt;              覆盖所安装扩展的位置</span><br><span class="line">  -endorseddirs &lt;目录&gt;         覆盖签名的标准路径的位置</span><br><span class="line">  -proc:&#123;none,only&#125;          控制是否执行注释处理和/或编译。</span><br><span class="line">  -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程</span><br><span class="line">  -processorpath &lt;路径&gt;        指定查找注释处理程序的位置</span><br><span class="line">  -parameters                生成元数据以用于方法参数的反射</span><br><span class="line">  -d &lt;目录&gt;                    指定放置生成的类文件的位置</span><br><span class="line">  -s &lt;目录&gt;                    指定放置生成的源文件的位置</span><br><span class="line">  -h &lt;目录&gt;                    指定放置生成的本机标头文件的位置</span><br><span class="line">  -implicit:&#123;none,class&#125;     指定是否为隐式引用文件生成类文件</span><br><span class="line">  -encoding &lt;编码&gt;             指定源文件使用的字符编码</span><br><span class="line">  -source &lt;发行版&gt;              提供与指定发行版的源兼容性</span><br><span class="line">  -target &lt;发行版&gt;              生成特定 VM 版本的类文件</span><br><span class="line">  -profile &lt;配置文件&gt;            请确保使用的 API 在指定的配置文件中可用</span><br><span class="line">  -version                   版本信息</span><br><span class="line">  -help                      输出标准选项的提要</span><br><span class="line">  -A关键字[=值]                  传递给注释处理程序的选项</span><br><span class="line">  -X                         输出非标准选项的提要</span><br><span class="line">  -J&lt;标记&gt;                     直接将 &lt;标记&gt; 传递给运行时系统</span><br><span class="line">  -Werror                    出现警告时终止编译</span><br><span class="line">  @&lt;文件名&gt;                     从文件读取选项和文件名</span><br></pre></td></tr></table></figure><p>javap 的用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javap -<span class="built_in">help</span></span></span><br><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -help  --help  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -public                  仅显示公共类和成员</span><br><span class="line">  -protected               显示受保护的/公共类和成员</span><br><span class="line">  -package                 显示程序包/受保护的/公共类</span><br><span class="line">                           和成员 (默认)</span><br><span class="line">  -p  -private             显示所有类和成员</span><br><span class="line">  -c                       对代码进行反汇编</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的</span><br><span class="line">                           系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">  -cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure><h2 id="字节码的运行时结构"><a href="#字节码的运行时结构" class="headerlink" title="字节码的运行时结构"></a>字节码的运行时结构</h2><p>JVM 是一台基于栈的计算机器。</p><p>每个线程都有一个独属于自己的线程栈（JVM Stack），用于存储 栈帧（Frame）。 每一次方法调用，JVM 都会自动创建一个栈帧。栈帧由操作数栈，局部变量数组以及一个 Class 引用组成。Class 引用指向当前方法在运行时常量池中对应的 Class。</p><h2 id="从助记符到二进制"><a href="#从助记符到二进制" class="headerlink" title="从助记符到二进制"></a>从助记符到二进制</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-05-%E4%BB%8E%E5%8A%A9%E8%AE%B0%E7%AC%A6%E5%88%B0%E4%BA%8C%E8%BF%9B%E5%88%B6-1rl8Dp.png" alt="从助记符到二进制"></p><h2 id="四则运行的例子"><a href="#四则运行的例子" class="headerlink" title="四则运行的例子"></a>四则运行的例子</h2><p>MovingAverage.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> sum = <span class="number">0.0D</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(<span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">        <span class="keyword">this</span>.sum += value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAvg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="keyword">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sum / <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LocalVaribleTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVaribleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MovingAverage ma = <span class="keyword">new</span> MovingAverage();</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line">        ma.submit(num1);</span><br><span class="line">        ma.submit(num2);</span><br><span class="line">        <span class="keyword">double</span> avg = ma.getAvg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javap -c MovingAverage</span></span><br><span class="line">Compiled from &quot;MovingAverage.java&quot;</span><br><span class="line">public class MovingAverage &#123;</span><br><span class="line">  public MovingAverage();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: aload_0</span><br><span class="line">       5: iconst_0</span><br><span class="line">       6: putfield      #2                  // Field count:I</span><br><span class="line">       9: aload_0</span><br><span class="line">      10: dconst_0</span><br><span class="line">      11: putfield      #3                  // Field sum:D</span><br><span class="line">      14: return</span><br><span class="line"></span><br><span class="line">  public void submit(double);</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: dup</span><br><span class="line">       2: getfield      #2                  // Field count:I</span><br><span class="line">       5: iconst_1</span><br><span class="line">       6: iadd</span><br><span class="line">       7: putfield      #2                  // Field count:I</span><br><span class="line">      10: aload_0</span><br><span class="line">      11: dup</span><br><span class="line">      12: getfield      #3                  // Field sum:D</span><br><span class="line">      15: dload_1</span><br><span class="line">      16: dadd</span><br><span class="line">      17: putfield      #3                  // Field sum:D</span><br><span class="line">      20: return</span><br><span class="line"></span><br><span class="line">  public double getAvg();</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_0</span><br><span class="line">       1: aload_0</span><br><span class="line">       2: getfield      #2                  // Field count:I</span><br><span class="line">       5: if_icmpne     13</span><br><span class="line">       8: aload_0</span><br><span class="line">       9: getfield      #3                  // Field sum:D</span><br><span class="line">      12: dreturn</span><br><span class="line">      13: aload_0</span><br><span class="line">      14: getfield      #3                  // Field sum:D</span><br><span class="line">      17: aload_0</span><br><span class="line">      18: getfield      #2                  // Field count:I</span><br><span class="line">      21: i2d</span><br><span class="line">      22: ddiv</span><br><span class="line">      23: dreturn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> javap -c LocalVaribleTest</span></span><br><span class="line">Compiled from &quot;LocalVaribleTest.java&quot;</span><br><span class="line">public class LocalVaribleTest &#123;</span><br><span class="line">  public LocalVaribleTest();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class MovingAverage</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #3                  // Method MovingAverage.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: iconst_1</span><br><span class="line">       9: istore_2</span><br><span class="line">      10: iconst_2</span><br><span class="line">      11: istore_3</span><br><span class="line">      12: aload_1</span><br><span class="line">      13: iload_2</span><br><span class="line">      14: i2d   // int 转成 double 隐式转换</span><br><span class="line">      15: invokevirtual #4                  // Method MovingAverage.submit:(D)V</span><br><span class="line">      18: aload_1</span><br><span class="line">      19: iload_3</span><br><span class="line">      20: i2d</span><br><span class="line">      21: invokevirtual #4                  // Method MovingAverage.submit:(D)V</span><br><span class="line">      24: aload_1</span><br><span class="line">      25: invokevirtual #5                  // Method MovingAverage.getAvg:()D</span><br><span class="line">      28: dstore        4</span><br><span class="line">      30: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算数操作与类型转换"><a href="#算数操作与类型转换" class="headerlink" title="算数操作与类型转换"></a>算数操作与类型转换</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-09-01-%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-D45qpJ.png" alt="算数操作与类型转换"></p><h2 id="一个完整的循环控制"><a href="#一个完整的循环控制" class="headerlink" title="一个完整的循环控制"></a>一个完整的循环控制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForLoopTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MovingAverage ma = <span class="keyword">new</span> MovingAverage();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            ma.submit(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> avg = ma.getAvg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javap -c ForLoopTest</span></span><br><span class="line">Compiled from &quot;ForLoopTest.java&quot;</span><br><span class="line">public class ForLoopTest &#123;</span><br><span class="line">  public ForLoopTest();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class MovingAverage</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #3                  // Method MovingAverage.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: getstatic     #4                  // Field nums:[I</span><br><span class="line">      11: astore_2</span><br><span class="line">      12: aload_2</span><br><span class="line">      13: arraylength</span><br><span class="line">      14: istore_3</span><br><span class="line">      15: iconst_0                // 初始化变量 0</span><br><span class="line">      16: istore        4         // 存储到本地变量表 4 槽位</span><br><span class="line">      18: iload         4         // 加载 4 槽位 到操作数栈</span><br><span class="line">      20: iload_3                 // 加载 int 3 到操作数栈</span><br><span class="line">      21: if_icmpge     43        // 比较，如果大于等于跳转到 43 行指令</span><br><span class="line">      24: aload_2</span><br><span class="line">      25: iload         4</span><br><span class="line">      27: iaload</span><br><span class="line">      28: istore        5</span><br><span class="line">      30: aload_1</span><br><span class="line">      31: iload         5</span><br><span class="line">      33: i2d</span><br><span class="line">      34: invokevirtual #5                  // Method MovingAverage.submit:(D)V</span><br><span class="line">      37: iinc          4, 1      // 4 槽位上加 1</span><br><span class="line">      40: goto          18        // goto 18 行指令</span><br><span class="line">      43: aload_1</span><br><span class="line">      44: invokevirtual #6                  // Method MovingAverage.getAvg:()D</span><br><span class="line">      47: dstore_2</span><br><span class="line">      48: return</span><br><span class="line"></span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_3</span><br><span class="line">       1: newarray       int</span><br><span class="line">       3: dup</span><br><span class="line">       4: iconst_0</span><br><span class="line">       5: iconst_1</span><br><span class="line">       6: iastore</span><br><span class="line">       7: dup</span><br><span class="line">       8: iconst_1</span><br><span class="line">       9: bipush        6</span><br><span class="line">      11: iastore</span><br><span class="line">      12: dup</span><br><span class="line">      13: iconst_2</span><br><span class="line">      14: bipush        8</span><br><span class="line">      16: iastore</span><br><span class="line">      17: putstatic     #4                  // Field nums:[I</span><br><span class="line">      20: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法调用的指令"><a href="#方法调用的指令" class="headerlink" title="方法调用的指令"></a>方法调用的指令</h2><ul><li>invokestatic，顾名思义，这个指令用于调用某个类的静态方法，这是方法调用指令中最快的一个。</li><li>invokespecial, 用来调用构造函数，但也可以用于调用同一个类中的 private 方法, 以及可见的超类方法。</li><li>invokevirtual，如果是具体类型的目标对象，invokevirtual 用于调用公共，受保护和 package 级的私有方法。</li><li>invokeinterface，当通过接口引用来调用方法时，将会编译为 invokeinterface 指令。</li><li>invokedynamic，JDK7 新增加的指令，是实现“动态类型语言”（Dynamically Typed Language）支持而进行的升级改进，同时也是 JDK8 以后支持 lambda 表达式的实现基础。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是字节码？&quot;&gt;&lt;a href=&quot;#什么是字节码？&quot; class=&quot;headerlink&quot; title=&quot;什么是字节码？&quot;&gt;&lt;/a&gt;什么是字节码？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我们平时所说的 Java 字节码，指的是用 Java 语言编译成的字节码。准确的说能在 JVM 平台上执行的字节码格式都是一样的。所以应该统称为 JVM 字节码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的 JVM 上运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java 虚拟机与 Java 语言并没有必然的联系，它只与特定的二进制文件格式 .class 文件格式所关联，.class 文件中包含了 Java 虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他的辅助信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java bytecode 由单字节（byte）的指令组成，理论上最多支持 256 个操作码（opcode）。 实际上 Java 只使用了200左右的操作码，还有一些操作码则保留给调试操作。详情见：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://yonghong.tech/2021/01/jvm-instruction-set/&quot;&gt;JVM 指令集对照表&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 01 —— 5 分钟回顾一下 Java 基础知识</title>
    <link href="http://yonghong.tech/java-advance/01-jvm-basic/"/>
    <id>http://yonghong.tech/java-advance/01-jvm-basic/</id>
    <published>2021-05-14T13:00:00.000Z</published>
    <updated>2021-05-14T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-生态圈"><a href="#Java-生态圈" class="headerlink" title="Java 生态圈"></a>Java 生态圈</h2><p>Java 是目前应用最为广泛的软件开发平台之一。随着 Java 以及 Java 社区的不断壮大，Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p><ul><li>作为一个平台：Java 虚拟机扮演着举足轻重的作用。<ul><li>Groovy、Scala、JRuby、Kotlin 等都是 Java 平台的一部分。</li></ul></li><li>作为一种文化：Java 几乎成为了开源的代名词<ul><li>第三方开源软件和框架，如，Tomcat、Struts、MyBatis、Spring 等</li><li>就连 JDK 和 JVM 自身也有不少开源的实现，如 OpenJDK、Harmony</li></ul></li><li>作为一个社区，Java 拥有全世界最多的技术拥护者和开源社区的支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到 Java 的身影。其应用形式之复杂、参与人数之众也令人咋舌。</li></ul><span id="more"></span><h2 id="Java-跨平台的语言"><a href="#Java-跨平台的语言" class="headerlink" title="Java 跨平台的语言"></a>Java 跨平台的语言</h2><h3 id="Java-虚拟机规范"><a href="#Java-虚拟机规范" class="headerlink" title="Java 虚拟机规范"></a>Java 虚拟机规范</h3><p>The Java Virtual Machine is the cornerstone of the Java platform. <strong>It is the component of the technology responsible for its hardware- and operating system-independence</strong>, the small size of its compiled code, and its ability to protect users from malicious programs.</p><p>The Java Virtual Machine is an abstract computing machine. Like a real computing machine, it has an instruction set and manipulates various memory areas at run time. It is reasonably common to implement a programming language using a virtual machine; the best-known virtual machine may be the P-Code machine of UCSD Pascal.</p><h3 id="JVM-跨语言的平台"><a href="#JVM-跨语言的平台" class="headerlink" title="JVM 跨语言的平台"></a>JVM 跨语言的平台</h3><p>随着 Java 7 的正式发布，Java 虚拟机的设计者们通过 JSR-292 规范基本实现在 Java 虚拟机平台上运行非 Java 语言编写的程序。</p><p>Java 虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说，Java 虚拟机拥有语言无关性，并不会单纯地与 Java 语言“终身绑定”，只要其他编程语言的编译结果满足并包含 Java 虚拟机的内部指令集，符号表以及其他的辅助信息，他就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-19-34-orUTHy-CAZ1Zb.png" alt="Java 跨平台的语言"></p><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-19-40-%E6%BA%90%E7%A0%81%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%B7%A8%E5%B9%B3%E5%8F%B0-R6Uzxy.png" alt="源码跨平台和二进制跨平台"></p><ul><li>Java、C++、Rust 的区别<ul><li>C/C++ 完全相信而且惯着程序员，让大家自行管理内存，可以编写很自由的代码，但一 不小心就会造成内存泄漏等问题，导致程序崩溃。</li><li>Java/Golang 完全不相信程序员，但也惯着程序员。所有的内存生命周期都由 JVM 运行 时统一管理。 在绝大部分场景下，你可以非常自由的写代码，而且不用关心内存到底是 什么情况。 内存使用有问题的时候，我们可以通过 JVM 来进行信息相关的分析诊断和 调整。 这也是本课程的目标。</li><li>Rust 语言选择既不相信程序员，也不惯着程序员。 让你在写代码的时候，必须清楚明白 的用 Rust 的规则管理好你的变量，好让机器能明白高效地分析和管理内存。 但是这样 会导致代码不利于人的理解，写代码很不自由，学习成本也很高。</li></ul></li></ul><h3 id="多语言混合编程"><a href="#多语言混合编程" class="headerlink" title="多语言混合编程"></a>多语言混合编程</h3><p>Java 平台上的多语言混合编程正在成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</p><p>试想一下，在一个项目之中，并行处理使用 Clojure 语言编写，展示层使用 JRuby/Rails，中间层则是 Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生 API 一样方便，因为他们最终都运行在一个虚拟机之上。</p><p>对于这些运行在虚拟机之上、Java 语言之外的语言，来自系统级的、底层的支持正在迅速增强，以 JSR-292 为核心的一系列项目和功能改进（如，Davinci Machine 项目、Nashorn 引擎、InvokeDynamic 指令、java.lang.invoke 包等），推动 Java 虚拟机从 Java 语言的虚拟机向多语言虚拟机发展。</p><h3 id="两种架构"><a href="#两种架构" class="headerlink" title="两种架构"></a>两种架构</h3><p>Java 编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。</p><p>具体来说两种架构之间的区别：</p><ul><li>基于栈式架构的特点<ul><li>设计和实现更简单，适用于资源受限的系统；</li><li>避开了寄存器的分配难题：使用零地址指令方式分配；</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作数。指令集更小，编译器容易实现；</li><li>不需要硬件支持，可移植性更好，更好实现跨平台。</li></ul></li><li>基于寄存器架构的特点<ul><li>典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机；</li><li>指令集架构则完全依赖硬件，可移植性差；</li><li>性能优秀和执行更高效；</li><li>花费更少的指令去完成一项操作；</li><li>在大部分情况下，基于寄存器架构的指令集往往都是一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。</li></ul></li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>同样执行 2+3 这种逻辑操作，其指令分别如下：</p><p>基于栈的计算流程（以 Java 虚拟机为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iconst_2 <span class="comment">// 常量 2 入栈</span></span><br><span class="line">istore_1</span><br><span class="line">iconst_3 <span class="comment">// 常量 3 入栈</span></span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd     <span class="comment">// 常量 2、3 出栈，执行相加</span></span><br><span class="line">istore_0 <span class="comment">// 结果 5 入栈</span></span><br></pre></td></tr></table></figure><p>而基于寄存器的计算流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,<span class="number">2</span>  <span class="comment">// 将 eax 寄存器的值设置为 2</span></span><br><span class="line">mov eax,<span class="number">3</span>  <span class="comment">// 使 eax 寄存器的值加 3</span></span><br></pre></td></tr></table></figure><p>代码演示一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackStruTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">cd chapter_01</span><br><span class="line">javac StackStruTest.java</span><br><span class="line">javap -v StackStruTest</span><br><span class="line">Classfile /Users/yonghong/Coding/jvm/song/chapter_01/StackStruTest.class</span><br><span class="line">  Last modified 2020-11-17; size 277 bytes</span><br><span class="line">  MD5 checksum 9a7da6f68b8101238c5ab826d90154c5</span><br><span class="line">  Compiled from &quot;StackStruTest.java&quot;</span><br><span class="line">public class StackStruTest</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line"><span class="meta">   #</span><span class="bash">1 = Methodref          <span class="comment">#3.#12         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">2 = Class              <span class="comment">#13            // StackStruTest</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">3 = Class              <span class="comment">#14            // java/lang/Object</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">4 = Utf8               &lt;init&gt;</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">5 = Utf8               ()V</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">6 = Utf8               Code</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">7 = Utf8               LineNumberTable</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">8 = Utf8               main</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">9 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">10 = Utf8               SourceFile</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">11 = Utf8               StackStruTest.java</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">12 = NameAndType        <span class="comment">#4:#5          // &quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash">13 = Utf8               StackStruTest</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">14 = Utf8               java/lang/Object</span></span><br><span class="line">&#123;</span><br><span class="line">  public StackStruTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 2: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=2, args_size=1</span><br><span class="line">         0: iconst_5 // 直接返回了 5</span><br><span class="line">         1: istore_1</span><br><span class="line">         2: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 4: 0</span><br><span class="line">        line 5: 2</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;StackStruTest.java&quot;</span><br></pre></td></tr></table></figure><p>由于跨平台的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的。优点是跨平台、指令集小，编译器容易实现；缺点是性能下降，实现同样的功能需要更多的指令。</p><p>时至今日，尽管嵌入式平台已经不是 Java 程序的主流运行平台了（准确来说是 HotSpot 虚拟机的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p><p>答：基于栈式架构的虚拟机跨平台、指令集小，编译器容易实现，在非资源受限的场景中也是可以使用的。</p><h2 id="JVM-的生命周期"><a href="#JVM-的生命周期" class="headerlink" title="JVM 的生命周期"></a>JVM 的生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java 虚拟机的启动时通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ul><li>一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序；</li><li>程序开始执行时他才运行，程序结束时他就停止；</li><li>执行一个所谓的 Java 程序的时候，真真正正在执行的是一个叫做 Java 虚拟机的进程。</li></ul><h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p>有如下的几种情况：</p><ul><li>程序正常执行结束；</li><li>程序在执行过程中遇到了异常或错误而异常终止；</li><li>由于操作系统出现错误而导致 Java 虚拟机进程终止；</li><li>某线程调用 Runtime 类或 System 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或者 halt 操作；</li><li>除此之外，JNI（Java Native Interface）规范中描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时 Java 虚拟机的退出情况。</li></ul><h2 id="JVM-发展历程"><a href="#JVM-发展历程" class="headerlink" title="JVM 发展历程"></a>JVM 发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ul><li>早在 1996 年 Java 1.0 版本的时候，Sun 公司发布了一款名为 Sun Classic VM 的 Java 虚拟机，它同时也是世界上第一款商用 Java 虚拟机，JDK 1.4 时完全被淘汰。</li><li>这款虚拟机内部只提供解释器。</li><li>如果使用 JIT 编译器，就需要进行外挂。但是一旦使用了 JIT 编译器，JIT 就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li><li>现在 HotSpot 内置了此虚拟机。</li></ul><h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><ul><li>为了解决上一个虚拟机问题，JDK 1.2 时，Sun 提供了此虚拟机；</li><li>Exact Memory Management: 准确式内存管理；<ul><li>也可以叫 Non-Conservative/Accurate Memory Management</li><li>虚拟机可以知道内存中某个位置的数据具体是什么类型</li></ul></li><li>具备现代高性能虚拟机的雏形<ul><li>热点探测</li><li>编译器与解释器混合工作模式</li></ul></li><li>只在 Solaris 平台短暂使用，其他平台上还是 Classic VM<ul><li>英雄气短，终被 HotSpot 虚拟机替换</li></ul></li></ul><h3 id="HotSpot"><a href="#HotSpot" class="headerlink" title="HotSpot"></a>HotSpot</h3><ul><li>HotSpot 历史<ul><li>最初由一家名为 Longview Technologies 的小公司设计</li><li>1997 年，此公司被 Sun 收购；2009 年，Sun 公司被 Oracle 收购</li><li>JDK 1.3 时，HotSpot VM 成为默认虚拟机</li></ul></li><li>目前 HotSpot 占有绝对的市场地位，称霸武林<ul><li>现在使用比较多的 JDK 8、JDK 11中默认的虚拟机是 HotSpot</li><li>Sun/Oracle JDk 和 OpenJDK 的默认虚拟机</li></ul></li><li>从服务端、桌面端、嵌入式都有应用</li><li>名称中的 HotSpot 指的就是它的热点代码探测技术<ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li><li>通过编译器与解释器协同工作，在最优的程序响应时间与最佳执行性能中取得平衡</li></ul></li></ul><h3 id="BEA-的-JRockit"><a href="#BEA-的-JRockit" class="headerlink" title="BEA 的 JRockit"></a>BEA 的 JRockit</h3><ul><li>专注于服务器应用<ul><li>它可以不太关注程序启动速度，因此 JRockit 内部不包含解释器实现，全部代码都是靠即时编译器编译后执行</li></ul></li><li>大量的行业基准测试显示，JRockit JVM 是世界上最快的 JVM。<ul><li>使用 JRockit 产品，客户已经体验带了显著的性能提高（一些超过了 70%）和硬件成本的减少（达50%）。</li></ul></li><li>优势：全面的 Java 运行时解决方案组合<ul><li>JRockit 面向延迟敏感型应用的解决方案 JRockit Real Time 提供以毫秒或微秒级的 JVM 响应时间，适合财务，军事指挥，电信网络的需要。</li><li>MissionControl 服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li></ul></li><li>2008年，BEA 被 Oracle 收购</li></ul><h3 id="IBM-的-J9"><a href="#IBM-的-J9" class="headerlink" title="IBM 的 J9"></a>IBM 的 J9</h3><ul><li>全称：IBM Technology for Java Virtual Machine，简称 IT4J，内部代号 J9</li><li>市场定位与 HotSpot 接近，服务端、桌面应用、嵌入式等多用途 VM</li><li>广泛应用于 IBM 的各种 Java 产品</li><li>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的虚拟机。</li><li>2017左右，IBM 发布了开源 J9 VM，命名为 OpenJ9，交给 Eclipse 基金会管理，也称为 Eclipse OpenJ9</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Java-生态圈&quot;&gt;&lt;a href=&quot;#Java-生态圈&quot; class=&quot;headerlink&quot; title=&quot;Java 生态圈&quot;&gt;&lt;/a&gt;Java 生态圈&lt;/h2&gt;&lt;p&gt;Java 是目前应用最为广泛的软件开发平台之一。随着 Java 以及 Java 社区的不断壮大，Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为一个平台：Java 虚拟机扮演着举足轻重的作用。&lt;ul&gt;
&lt;li&gt;Groovy、Scala、JRuby、Kotlin 等都是 Java 平台的一部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作为一种文化：Java 几乎成为了开源的代名词&lt;ul&gt;
&lt;li&gt;第三方开源软件和框架，如，Tomcat、Struts、MyBatis、Spring 等&lt;/li&gt;
&lt;li&gt;就连 JDK 和 JVM 自身也有不少开源的实现，如 OpenJDK、Harmony&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作为一个社区，Java 拥有全世界最多的技术拥护者和开源社区的支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到 Java 的身影。其应用形式之复杂、参与人数之众也令人咋舌。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JDK 16 正式发布！</title>
    <link href="http://yonghong.tech/release/jdk-16/"/>
    <id>http://yonghong.tech/release/jdk-16/</id>
    <published>2021-04-03T02:00:00.000Z</published>
    <updated>2021-04-03T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>JDK 16 在 2021 年 3 月 16 日正式发布了，这次发布的主要功能有：</p><ul><li>JEP 338: Vector API (Incubator)</li><li>JEP 347: Enable C++14 Language Features</li><li>JEP 357: Migrate from Mercurial to Git</li><li>JEP 369: Migrate to GitHub</li><li>JEP 376: ZGC: Concurrent Thread-Stack Processing</li><li>JEP 380: Unix-Domain Socket Channels</li><li>JEP 386: Alpine Linux Port</li><li>JEP 387: Elastic Metaspace</li><li>JEP 388: Windows/AArch64 Port</li><li>JEP 389: Foreign Linker API (Incubator)</li><li>JEP 390: Warnings for Value-Based Classes</li><li>JEP 392: Packaging Tool</li><li>JEP 393: Foreign-Memory Access API (Third Incubator)</li><li>JEP 394: Pattern Matching for instanceof</li><li>JEP 395: Records</li><li>JEP 396: Strongly Encapsulate JDK Internals by Default</li><li>JEP 397: Sealed Classes (Second Preview)</li></ul><span id="more"></span><hr><h3 id="JEP-338-Vector-API-Incubator"><a href="#JEP-338-Vector-API-Incubator" class="headerlink" title="JEP 338: Vector API (Incubator)"></a>JEP 338: Vector API (Incubator)</h3><p>Vector API 这是一个新的初始迭代孵化器模块，模块包：<code>jdk.incubator.vector</code>，用于表示在运行时可靠地编译到支持的 CPU 架构上的最佳矢量硬件指令的矢量计算。</p><h3 id="JEP-347-Enable-C-14-Language-Features"><a href="#JEP-347-Enable-C-14-Language-Features" class="headerlink" title="JEP 347: Enable C++14 Language Features"></a>JEP 347: Enable C++14 Language Features</h3><p>允许在 JDK 底层的 C ++ 源代码中使用 C ++ 14 的新语言特性，并且提供了在 HotSpot 虚拟机代码中，哪些代码使用了这些新特性的指南。</p><h3 id="JEP-357-Migrate-from-Mercurial-to-Git"><a href="#JEP-357-Migrate-from-Mercurial-to-Git" class="headerlink" title="JEP 357: Migrate from Mercurial to Git"></a>JEP 357: Migrate from Mercurial to Git</h3><p>将 OpenJDK 社区的源代码存储库从 Mercurial（hg）迁移到 Git。</p><h3 id="JEP-369-Migrate-to-GitHub"><a href="#JEP-369-Migrate-to-GitHub" class="headerlink" title="JEP 369: Migrate to GitHub"></a>JEP 369: Migrate to GitHub</h3><p>在 GitHub 上托管 OpenJDK 社区的 Git 存储库。</p><h3 id="JEP-376-ZGC-Concurrent-Thread-Stack-Processing"><a href="#JEP-376-ZGC-Concurrent-Thread-Stack-Processing" class="headerlink" title="JEP 376: ZGC: Concurrent Thread-Stack Processing"></a>JEP 376: ZGC: Concurrent Thread-Stack Processing</h3><p>ZGC 是一种较新的垃圾回收器，指在解决 HotSpot 虚拟机中的 GC 停顿及可伸缩问题。</p><p>ZGC 最早是在 JDK 11 中集成进来的，在 <a href="https://yonghong.tech/release/jdk-15/">JDK 15</a> 中正式转正。</p><p>这个版本则是为了让 ZGC 支持并发栈处理，解决了最后一个重大瓶颈，把 ZGC 中的线程栈处理从安全点移到了并发阶段。并且还提供了一种机制，使得其他 HotSpot 子系统可以通过该机制延迟处理线程栈。</p><h3 id="JEP-380-Unix-Domain-Socket-Channels"><a href="#JEP-380-Unix-Domain-Socket-Channels" class="headerlink" title="JEP 380: Unix-Domain Socket Channels"></a>JEP 380: Unix-Domain Socket Channels</h3><p>UNIX 域套接字通道，为 <code>java.nio.channels</code> 包中的套接字通道和服务端套接字通道 APIs 增加 Unix 域套接字通道所有特性支持。</p><p>UNIX 域套接字主要用于同一主机上的进程间通信（IPC），大部分方面与 TCP/IP套接字类似，不同的是 UNIX 域套接字是通过文件系统路径名寻址，而不是通过 IP 地址和端口号。</p><h3 id="JEP-386-Alpine-Linux-Port"><a href="#JEP-386-Alpine-Linux-Port" class="headerlink" title="JEP 386: Alpine Linux Port"></a>JEP 386: Alpine Linux Port</h3><p>在 x64 和 AArch64 平台体系结构上，将 JDK 移植到 Alpine Linux 以及使用 musl 作为其主要 C 语言库的其他 Linux 发行版中。</p><h3 id="JEP-387-Elastic-Metaspace"><a href="#JEP-387-Elastic-Metaspace" class="headerlink" title="JEP 387: Elastic Metaspace"></a>JEP 387: Elastic Metaspace</h3><p>弹性的元空间，可以帮助 HotSpot 虚拟机，将元空间中未使用的 class 元数据内存更及时地返回给操作系统，以减少元空间的内存占用空间。</p><p>另外，还简化了元空间的代码，以降低维护成本。</p><h3 id="JEP-388-Windows-AArch64-Port"><a href="#JEP-388-Windows-AArch64-Port" class="headerlink" title="JEP 388: Windows/AArch64 Port"></a>JEP 388: Windows/AArch64 Port</h3><p>将 JDK 移植到 Windows/ AArch64 平台系列。</p><h3 id="JEP-389-Foreign-Linker-API-Incubator"><a href="#JEP-389-Foreign-Linker-API-Incubator" class="headerlink" title="JEP 389: Foreign Linker API (Incubator)"></a>JEP 389: Foreign Linker API (Incubator)</h3><p>引入了一个新的 API，该 API 提供了对本地 native 代码的静态类型访问支持。</p><h3 id="JEP-390-Warnings-for-Value-Based-Classes"><a href="#JEP-390-Warnings-for-Value-Based-Classes" class="headerlink" title="JEP 390: Warnings for Value-Based Classes"></a>JEP 390: Warnings for Value-Based Classes</h3><p>基于值的类的警告，将基础类型包装类指定为基于值的类，废除其构造函数以进行删除，从而提示新的弃用警告。并且提供了在任何基于值的类的实例上不正常进行同步的警告。</p><h3 id="JEP-392-Packaging-Tool"><a href="#JEP-392-Packaging-Tool" class="headerlink" title="JEP 392: Packaging Tool"></a>JEP 392: Packaging Tool</h3><p>提供了 jpackage 打包工具，可用于打包独立的 Java 应用程序。</p><p>jpackage 打包工具是在 JDK 14 中首次作为孵化工具引入的新特性，到了 JDK 15 它仍然还在孵化中，现在它终于转正了。</p><h3 id="JEP-393-Foreign-Memory-Access-API-Third-Incubator"><a href="#JEP-393-Foreign-Memory-Access-API-Third-Incubator" class="headerlink" title="JEP 393: Foreign-Memory Access API (Third Incubator)"></a>JEP 393: Foreign-Memory Access API (Third Incubator)</h3><p>外部内存访问 API（三次孵化中），引入了一个新的 API，可以帮助 Java 应用程序更安全、有效地访问 Java 堆之外的外部内存。</p><p>这个最早在 JDK 14 中成为孵化特性，JDK 15/ JDK 16 中继续二、三次孵化并对其 API 有了一些更新，这个可以在 JDK 17 中好好期待一下转正。</p><h3 id="JEP-394-Pattern-Matching-for-instanceof"><a href="#JEP-394-Pattern-Matching-for-instanceof" class="headerlink" title="JEP 394: Pattern Matching for instanceof"></a>JEP 394: Pattern Matching for instanceof</h3><p>模式匹配 for instanceof，相当于是增强的 instanceof，在 JDK 14 中首次成为预览特性，在 JDK 16 中正式转正。</p><p>模式匹配的到来将使得 instanceof 变得更简洁、更安全，为什么这么说，请看下面的示例。</p><p>正常的 instanceof 写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> IPad) &#123;</span><br><span class="line">    IPad iPad = (IPad) object;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> IPhone) &#123;</span><br><span class="line">    IPhone iPhone = (IPhone) object;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模式匹配的 instanceof 写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> IPad iPad) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> IPhone iPhone) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断、赋值一步到位。</p><h3 id="JEP-395-Records"><a href="#JEP-395-Records" class="headerlink" title="JEP 395: Records"></a>JEP 395: Records</h3><p>简单来说，Records 就是一种新的语法糖，目的还是为了简化代码，在 JDK 14 中首次成为预览特性，在 JDK 16 中正式转正。</p><p>Records 可以在一定程度上避免低级冗余的代码，比如：constructors, getters, equals(), hashCode(), toString() 方法等，相当于 Lombok 的 @Data 注解，但又不能完全替代。</p><h3 id="JEP-396-Strongly-Encapsulate-JDK-Internals-by-Default"><a href="#JEP-396-Strongly-Encapsulate-JDK-Internals-by-Default" class="headerlink" title="JEP 396: Strongly Encapsulate JDK Internals by Default"></a>JEP 396: Strongly Encapsulate JDK Internals by Default</h3><p>JDK 内部默认强封装，JDK 16 开始对 JDK 内部大部分元素默认进行强封装，sun.misc.Unsafe 之类的关键内部 API 除外，从而限制对它们的访问。</p><p>此外，用户仍然可以选择自 JDK 9 以来的默认的宽松的强封装，这样可以帮助用户毫不费力地升级到未来的 Java 版本。</p><h3 id="JEP-397-Sealed-Classes-Second-Preview"><a href="#JEP-397-Sealed-Classes-Second-Preview" class="headerlink" title="JEP 397: Sealed Classes (Second Preview)"></a>JEP 397: Sealed Classes (Second Preview)</h3><p>封闭类（二次预览），可以是封闭类和或者封闭接口，用来增强 Java 编程语言，防止其他类或接口扩展或实现它们。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>官方日志：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L3Byb2plY3RzL2pkay8xNi8=">https://openjdk.java.net/projects/jdk/16/<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qZGsuamF2YS5uZXQvMTYvcmVsZWFzZS1ub3Rlcw==">https://jdk.java.net/16/release-notes<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;JDK 16 在 2021 年 3 月 16 日正式发布了，这次发布的主要功能有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JEP 338: Vector API (Incubator)&lt;/li&gt;
&lt;li&gt;JEP 347: Enable C++14 Language Features&lt;/li&gt;
&lt;li&gt;JEP 357: Migrate from Mercurial to Git&lt;/li&gt;
&lt;li&gt;JEP 369: Migrate to GitHub&lt;/li&gt;
&lt;li&gt;JEP 376: ZGC: Concurrent Thread-Stack Processing&lt;/li&gt;
&lt;li&gt;JEP 380: Unix-Domain Socket Channels&lt;/li&gt;
&lt;li&gt;JEP 386: Alpine Linux Port&lt;/li&gt;
&lt;li&gt;JEP 387: Elastic Metaspace&lt;/li&gt;
&lt;li&gt;JEP 388: Windows/AArch64 Port&lt;/li&gt;
&lt;li&gt;JEP 389: Foreign Linker API (Incubator)&lt;/li&gt;
&lt;li&gt;JEP 390: Warnings for Value-Based Classes&lt;/li&gt;
&lt;li&gt;JEP 392: Packaging Tool&lt;/li&gt;
&lt;li&gt;JEP 393: Foreign-Memory Access API (Third Incubator)&lt;/li&gt;
&lt;li&gt;JEP 394: Pattern Matching for instanceof&lt;/li&gt;
&lt;li&gt;JEP 395: Records&lt;/li&gt;
&lt;li&gt;JEP 396: Strongly Encapsulate JDK Internals by Default&lt;/li&gt;
&lt;li&gt;JEP 397: Sealed Classes (Second Preview)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="release" scheme="http://yonghong.tech/categories/release/"/>
    
    
    <category term="JDK" scheme="http://yonghong.tech/tags/JDK/"/>
    
    <category term="Java" scheme="http://yonghong.tech/tags/Java/"/>
    
    <category term="release" scheme="http://yonghong.tech/tags/release/"/>
    
    <category term="ZGC" scheme="http://yonghong.tech/tags/ZGC/"/>
    
    <category term="GitHub" scheme="http://yonghong.tech/tags/GitHub/"/>
    
    <category term="Vector" scheme="http://yonghong.tech/tags/Vector/"/>
    
    <category term="Metaspace" scheme="http://yonghong.tech/tags/Metaspace/"/>
    
    <category term="Sealed" scheme="http://yonghong.tech/tags/Sealed/"/>
    
    <category term="instanceof" scheme="http://yonghong.tech/tags/instanceof/"/>
    
  </entry>
  
  <entry>
    <title>【macOS 命令】scutil</title>
    <link href="http://yonghong.tech/macos-command/scutil/"/>
    <id>http://yonghong.tech/macos-command/scutil/</id>
    <published>2021-03-29T12:00:00.000Z</published>
    <updated>2021-03-29T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>管理系统配置参数。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>对系统的用户名和主机名进行修改</p><ul><li>ComputerName 就是电脑名称，给人看的（在下图中，电脑名称）</li><li>HostName 主机名，但通常不会设置这个值</li><li>LocalHostName 主机名，和 Linux 系统的 hostname 一样（在下图中，本地网络中电脑名称）</li></ul><span id="more"></span><p><img src="https://up-img.yonghong.tech/pic/2021/03/29-20-27-%E6%88%AA%E5%B1%8F2021-03-29%20%E4%B8%8B%E5%8D%888.27.22-EnugWj.png" alt="电脑名称、主机名设置"></p><p>hostname 命令取值的顺序：</p><ul><li>hostname 命令设置的值</li><li>HostName 属性值</li><li>LocalHostName 属性值（通常系统都会设置此属性）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看系统主机名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scutil --get ComputerName</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scutil --get HostName</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scutil --get LocalHostName</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改系统主机名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scutil --<span class="built_in">set</span> ComputerName xxx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scutil --<span class="built_in">set</span> HostName xxx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scutil --<span class="built_in">set</span> LocalHostName xxx</span></span><br></pre></td></tr></table></figure><p>查看 DNS 配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scutil --dns</span></span><br></pre></td></tr></table></figure><p>查看代理信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scutil --proxy</span></span><br></pre></td></tr></table></figure><p>查看网络信息（ipv4/ipv6）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scutil --nwi</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;管理系统配置参数。&lt;/p&gt;
&lt;h2 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot; title=&quot;用法&quot;&gt;&lt;/a&gt;用法&lt;/h2&gt;&lt;p&gt;对系统的用户名和主机名进行修改&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ComputerName 就是电脑名称，给人看的（在下图中，电脑名称）&lt;/li&gt;
&lt;li&gt;HostName 主机名，但通常不会设置这个值&lt;/li&gt;
&lt;li&gt;LocalHostName 主机名，和 Linux 系统的 hostname 一样（在下图中，本地网络中电脑名称）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="macOS 命令" scheme="http://yonghong.tech/categories/macOS-%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="macOS 命令" scheme="http://yonghong.tech/tags/macOS-%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>MySQL update 语句 set 顺序</title>
    <link href="http://yonghong.tech/2021/03/mysql-update-set-order/"/>
    <id>http://yonghong.tech/2021/03/mysql-update-set-order/</id>
    <published>2021-03-01T14:24:00.000Z</published>
    <updated>2021-03-01T14:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>绝大多数数据库，在执行 update 语句时，update t set a = b, b = a 便可实现 a、b 列值互换，赋值表达式右侧的值取的都是原始值。MySQL 则是例外，其单表更新是自左到右依次完成，即先完成 a = b，然后在完成 b = a (此时 a = b），所以执行结果变成 a、b 列都是 b，然后多表更新则又不尊从该更新法则。</p><p>这个问题源于业务中一次对券有效期进行延期的操作，需求是对优惠券有效期延期 35 天。</p><ul><li>一部分券在生效中，直接修改过期时间即可；</li><li>一部分券已经过期，修改过期时间后，需要判断一下是否仍然是过期的还是生效中的，修改券的状态</li></ul><span id="more"></span><p>所以 SQL 语句大致如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPDATE coupon </span><br><span class="line"><span class="keyword">SET</span> end_time <span class="operator">=</span> DATE_ADD(end_time, <span class="type">INTERVAL</span> <span class="number">35</span> <span class="keyword">DAY</span>), </span><br><span class="line">status <span class="operator">=</span> (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> end_time <span class="operator">&gt;</span> NOW() <span class="keyword">THEN</span> <span class="string">&#x27;生效中&#x27;</span> <span class="keyword">ELSE</span> <span class="string">&#x27;已过期&#x27;</span> <span class="keyword">END</span>), </span><br><span class="line">gmt_modify <span class="operator">=</span> NOW() </span><br><span class="line"><span class="keyword">WHERE</span> ... ;</span><br></pre></td></tr></table></figure><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>这个地方就有个问题，当修改 status 的时候 end_time 到底是原始数据，还是修改后的数据。经过测试，是使用的修改后的数据，接下来去 MySQL 官网中求证一下。</p><h2 id="MySQL-官方文档的说明"><a href="#MySQL-官方文档的说明" class="headerlink" title="MySQL 官方文档的说明"></a>MySQL 官方文档的说明</h2><p>MySQL 官网文档中是这样描述的，当你要更新一个列的时候，UPDATE 语句使用的是这列值的当前值。举个例子：下面这个语句从左到右顺序执行，先执行 col1 = col + 1，此时 col1 已经是加 1 后的值了，执行 col2 = col1 的时候，也是加 1 后的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE t1 <span class="keyword">SET</span> col1 <span class="operator">=</span> col1 <span class="operator">+</span> <span class="number">1</span>, col2 <span class="operator">=</span> col1;</span><br></pre></td></tr></table></figure><p><strong>但是，这个规则只适用于单表的 UPDATE，多表就不适用于这个规则了，多表更新，赋值语句不确保任何给定的顺序执行，可能是原值，也可能是新值。</strong></p><h2 id="MySQL-如何实现两列互换"><a href="#MySQL-如何实现两列互换" class="headerlink" title="MySQL 如何实现两列互换"></a>MySQL 如何实现两列互换</h2><p>编程语言中，实现两个变量互换很简单：引入临时变量 tmp，tmp = a，a = b，b = tmp 即可实现 a、b 互换，但是 SQL 中没有临时变量，又如何实现变量互换呢？解决方案还是使用临时变量（只不过临时变量是某数据列的值，然后后面再覆盖该数据列的值），假设有 a b 列，a = 100，b = 1，实现 a b 互换，我们可以使用通用手法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">=</span> a <span class="operator">+</span> b, <span class="number">101</span></span><br><span class="line">b <span class="operator">=</span> a <span class="operator">-</span> b, <span class="number">100</span></span><br><span class="line">a <span class="operator">=</span> a <span class="operator">-</span> b, <span class="number">1</span></span><br></pre></td></tr></table></figure><p>至此，a = 1, b = 100，实现 a、b 值互换，SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update t <span class="keyword">set</span> a <span class="operator">=</span> a <span class="operator">+</span> b, b <span class="operator">=</span> a <span class="operator">-</span> b, a <span class="operator">=</span> a <span class="operator">-</span> b;</span><br></pre></td></tr></table></figure><h2 id="MySQL-多表更新的例子"><a href="#MySQL-多表更新的例子" class="headerlink" title="MySQL 多表更新的例子"></a>MySQL 多表更新的例子</h2><p>两张表：pur_po_bill_detail（采购单细表），wm_sh_bill_detail（收货单细表），采购后，先根据采购单细表创建收货单，然后根据收货单入库。</p><p><strong>pur_po_bill_detail（采购单细表）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `pur_po_bill_detail` (</span><br><span class="line">  `sid` <span class="type">int</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `bill_id` <span class="type">bigint</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;po单号id&#x27;</span>,</span><br><span class="line">  `bill_no` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单号&#x27;</span>,</span><br><span class="line">  `pw_count` <span class="type">decimal</span>(<span class="number">20</span>,<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;已入库数量&#x27;</span>,</span><br><span class="line">  `th_count` <span class="type">decimal</span>(<span class="number">20</span>,<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;不合格数量&#x27;</span>,</span><br><span class="line">  `bill_status` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`sid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;采购订单细表&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>wm_sh_bill_detail（收货单细表）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `wm_sh_bill_detail` (</span><br><span class="line">  `sid` <span class="type">int</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `bill_id` <span class="type">bigint</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;收货单id&#x27;</span>,</span><br><span class="line">  `bill_no` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ref_number` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> <span class="string">&#x27;采购单号&#x27;</span>,</span><br><span class="line">  `ref_detail_sid` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> <span class="string">&#x27;采购单行项目sid&#x27;</span>,</span><br><span class="line">  `sh_count` <span class="type">decimal</span>(<span class="number">20</span>,<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `in_count` <span class="type">decimal</span>(<span class="number">20</span>,<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `left_count` <span class="type">decimal</span>(<span class="number">20</span>,<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  ...</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY (`sid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;收货单细表&#x27;</span></span><br></pre></td></tr></table></figure><p>下述sql是在收货单入库时反写采购单细表入库数量、状态。</p><p>当采购单行项目：入库数量 + 不合格退货数量 &gt;= 订单数量，状态变成已入库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPDATE pur_po_bill_detail t0, wm_sh_bill_detail t1</span><br><span class="line"><span class="keyword">set</span> t0.pw_count <span class="operator">=</span> <span class="built_in">coalesce</span>(t0.pw_count,<span class="number">0</span>) <span class="operator">+</span> t1.in_count, </span><br><span class="line">t0.th_count <span class="operator">=</span> <span class="built_in">coalesce</span>(t0.th_count,<span class="number">0</span>) <span class="operator">+</span> <span class="built_in">coalesce</span>(t1.left_count,<span class="number">0</span>),</span><br><span class="line">t0.bill_status <span class="operator">=</span> <span class="keyword">case</span> <span class="keyword">when</span> t0.pw_count <span class="operator">+</span> t0.th_count <span class="operator">&gt;=</span> t0.goods_count <span class="keyword">then</span> <span class="string">&#x27;已入库&#x27;</span> <span class="keyword">else</span> t0.bill_status <span class="keyword">end</span></span><br><span class="line"><span class="keyword">WHERE</span> t0.sid <span class="operator">=</span> t1.ref_detail_sid <span class="keyword">and</span> t1.bill_no <span class="operator">=</span> <span class="string">&#x27;SH20180001&#x27;</span>;</span><br></pre></td></tr></table></figure><p>sql执行结果失败，系mysql多表更新，在case判断时，t0.pw_count, t0.th_count取到的是原值。所以mysql多表更新需要注意：</p><p>赋值语句、case语句尽量避免依赖引用，如本案case使用了赋值语句pw_count,th_count列，所以判断就出问题啦；可通过update语句拆分来实现多表复杂更新目标。</p><p>上述update语句拆分，先更新数量，然后更新状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UPDATE pur_po_bill_detail t0, wm_sh_bill_detail t1</span><br><span class="line"><span class="keyword">set</span> t0.pw_count <span class="operator">=</span> <span class="built_in">coalesce</span>(t0.pw_count,<span class="number">0</span>) <span class="operator">+</span> t1.in_count, </span><br><span class="line">t0.th_count <span class="operator">=</span> <span class="built_in">coalesce</span>(t0.th_count,<span class="number">0</span>) <span class="operator">+</span> <span class="built_in">coalesce</span>(t1.left_count,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">WHERE</span> t0.sid <span class="operator">=</span> t1.ref_detail_sid <span class="keyword">and</span> t1.bill_no <span class="operator">=</span> <span class="string">&#x27;SH20180001&#x27;</span>;</span><br><span class="line"></span><br><span class="line">UPDATE pur_po_bill_detail t0, wm_sh_bill_detail t1</span><br><span class="line"><span class="keyword">set</span> t0.bill_status <span class="operator">=</span> <span class="keyword">case</span> <span class="keyword">when</span> t0.pw_count <span class="operator">+</span> t0.th_count <span class="operator">&gt;=</span> t0.goods_count <span class="keyword">then</span> <span class="string">&#x27;已入库&#x27;</span> <span class="keyword">else</span> t0.bill_status <span class="keyword">end</span></span><br><span class="line"><span class="keyword">WHERE</span> t0.sid <span class="operator">=</span> t1.ref_detail_sid <span class="keyword">and</span> t1.bill_no <span class="operator">=</span> <span class="string">&#x27;SH20180001&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="再次回到业务中来"><a href="#再次回到业务中来" class="headerlink" title="再次回到业务中来"></a>再次回到业务中来</h2><p>再次回到业务场景中来，如果采用券的过期时间全部更新这种方式的话，先执行 end_time 延期，再去判断是否过期，这个时候使用的 end_time 已经是修改过的了。</p><p>其实这种更新方式也没有必要，如果券延期后还是过期的，那么其实也可以不更新券的有效期，那么 SQL 就变成了下面这样的。先过滤出延期后是生效状态的券，在进行更新。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UPDATE coupon </span><br><span class="line"><span class="keyword">SET</span> end_time <span class="operator">=</span> DATE_ADD(end_time, <span class="type">INTERVAL</span> <span class="number">35</span> <span class="keyword">DAY</span>), </span><br><span class="line">status <span class="operator">=</span> <span class="string">&#x27;生效中&#x27;</span>, </span><br><span class="line">gmt_modify <span class="operator">=</span> NOW() </span><br><span class="line"><span class="keyword">WHERE</span> ... </span><br><span class="line"><span class="keyword">AND</span> DATE_ADD(end_time, <span class="type">INTERVAL</span> <span class="number">35</span> <span class="keyword">DAY</span>) <span class="operator">&gt;</span> NOW() ;</span><br></pre></td></tr></table></figure><h2 id="MySQL-官方文档原文"><a href="#MySQL-官方文档原文" class="headerlink" title="MySQL 官方文档原文"></a>MySQL 官方文档原文</h2><p>If you access a column from the table to be updated in an expression, <a href="https://dev.mysql.com/doc/refman/8.0/en/update.html"><code>UPDATE</code></a> uses the current value of the column. For example, the following statement sets <code>col1</code> to one more than its current value:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE t1 <span class="keyword">SET</span> col1 <span class="operator">=</span> col1 <span class="operator">+</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>The second assignment in the following statement sets <code>col2</code> to the current (updated) <code>col1</code> value, not the original <code>col1</code> value. The result is that <code>col1</code> and <code>col2</code> have the same value. This behavior differs from standard SQL.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE t1 <span class="keyword">SET</span> col1 <span class="operator">=</span> col1 <span class="operator">+</span> <span class="number">1</span>, col2 <span class="operator">=</span> col1;</span><br></pre></td></tr></table></figure><p>Single-table <a href="https://dev.mysql.com/doc/refman/8.0/en/update.html"><code>UPDATE</code></a> assignments are generally evaluated from left to right. For multiple-table updates, there is no guarantee that assignments are carried out in any particular order.</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NodWFuZ3hpbi9hcnRpY2xlL2RldGFpbHMvODQ1NTgwNTA=">谈谈mysql update语句 set顺序问题、列交换sql实现及多表更新注意事项<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vNS43L2VuL3VwZGF0ZS5odG1s">https://dev.mysql.com/doc/refman/5.7/en/update.html<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL3VwZGF0ZS5odG1s">https://dev.mysql.com/doc/refman/8.0/en/update.html<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;绝大多数数据库，在执行 update 语句时，update t set a = b, b = a 便可实现 a、b 列值互换，赋值表达式右侧的值取的都是原始值。MySQL 则是例外，其单表更新是自左到右依次完成，即先完成 a = b，然后在完成 b = a (此时 a = b），所以执行结果变成 a、b 列都是 b，然后多表更新则又不尊从该更新法则。&lt;/p&gt;
&lt;p&gt;这个问题源于业务中一次对券有效期进行延期的操作，需求是对优惠券有效期延期 35 天。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一部分券在生效中，直接修改过期时间即可；&lt;/li&gt;
&lt;li&gt;一部分券已经过期，修改过期时间后，需要判断一下是否仍然是过期的还是生效中的，修改券的状态&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://yonghong.tech/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://yonghong.tech/tags/MySQL/"/>
    
    <category term="UPDATE" scheme="http://yonghong.tech/tags/UPDATE/"/>
    
    <category term="数据库" scheme="http://yonghong.tech/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>如何在macOS根目录创建文件夹</title>
    <link href="http://yonghong.tech/2021/02/create-folder-in-macos-root/"/>
    <id>http://yonghong.tech/2021/02/create-folder-in-macos-root/</id>
    <published>2021-02-27T02:24:00.000Z</published>
    <updated>2021-02-27T02:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在短短的两个月里，已经遇到了 2 次这个问题，第 1 次是 macOS@Catalina 版本，第 2 次是升级后的 macOS@Big Sur 版本，在这里记录一下解决办法。</p><h2 id="macOS-Catalina-版本"><a href="#macOS-Catalina-版本" class="headerlink" title="macOS@Catalina 版本"></a>macOS@Catalina 版本</h2><p>重启系统进入恢复模式，关闭 SIP，重启后命令行执行下面这行代码，再创建文件夹就能成功了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -uw /</span><br></pre></td></tr></table></figure><h2 id="macOS-Big-Sur-版本"><a href="#macOS-Big-Sur-版本" class="headerlink" title="macOS@Big Sur 版本"></a>macOS@Big Sur 版本</h2><p>重启系统进入恢复模式，关闭 SIP（不确定有没有这个步骤，如果有人尝试可以评论一下），接下来稍稍麻烦一点，修改 /etc/synthetic.conf 文件</p><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/synthetic.conf</span><br></pre></td></tr></table></figure><p>输入如下内容，data 换成你要创建的文件夹，后面是映射目录，注意，中间是 Tab，不是空格</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data    /private/data</span><br></pre></td></tr></table></figure><p>重启系统后，系统根目录出现了对应的文件夹，这个文件夹是一个软链接，链接到了前面写的映射目录中。</p><p>如图，我在我电脑根目录下创建了一个 home 文件夹的软链接，实际存储在 /private/home 这个文件夹中。</p><p><img src="https://up-img.yonghong.tech/pic/2021/02/27-12-28-%E6%88%AA%E5%B1%8F2021-02-26%20%E4%B8%8B%E5%8D%888.41.34-ovojux.png" alt="根目录下的home文件夹"></p><p>这是我的 /etc/synthetic.conf 文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cat /etc/synthetic.conf</span><br><span class="line">home/private/home</span><br></pre></td></tr></table></figure><h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9uZXdzbi5uZXQvc2F5L21hYy1iaWctc3VyLXJvb3QtcmVhZG9ubHkuaHRtbA==">Mac升级到big sur之后，根目录无法写入文件如何解决？<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zc3BhaS5jb20vcG9zdC81NTA2Ng==">macOS 开启或关闭 SIP<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zdXBwb3J0LmFwcGxlLmNvbS96aC1jbi9IVDIwMTMxNA==">关于基于 Intel 的 Mac 电脑上的 macOS 恢复功能<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在短短的两个月里，已经遇到了 2 次这个问题，第 1 次是 macOS@Catalina 版本，第 2 次是升级后的 macOS@Big Sur 版本，在这里记录一下解决办法。&lt;/p&gt;
&lt;h2 id=&quot;macOS-Catalina-版本&quot;&gt;&lt;a href=&quot;#macOS-Catalina-版本&quot; class=&quot;headerlink&quot; title=&quot;macOS@Catalina 版本&quot;&gt;&lt;/a&gt;macOS@Catalina 版本&lt;/h2&gt;&lt;p&gt;重启系统进入恢复模式，关闭 SIP，重启后命令行执行下面这行代码，再创建文件夹就能成功了。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo mount -uw /&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;macOS-Big-Sur-版本&quot;&gt;&lt;a href=&quot;#macOS-Big-Sur-版本&quot; class=&quot;headerlink&quot; title=&quot;macOS@Big Sur 版本&quot;&gt;&lt;/a&gt;macOS@Big Sur 版本&lt;/h2&gt;&lt;p&gt;重启系统进入恢复模式，关闭 SIP（不确定有没有这个步骤，如果有人尝试可以评论一下），接下来稍稍麻烦一点，修改 /etc/synthetic.conf 文件&lt;/p&gt;</summary>
    
    
    
    <category term="macOS" scheme="http://yonghong.tech/categories/macOS/"/>
    
    
    <category term="macOS" scheme="http://yonghong.tech/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>JVM 指令集对照表</title>
    <link href="http://yonghong.tech/2021/01/jvm-instruction-set/"/>
    <id>http://yonghong.tech/2021/01/jvm-instruction-set/</id>
    <published>2021-01-07T02:24:00.000Z</published>
    <updated>2021-01-07T02:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java Virtual Machine Specification 中，有对 JVM 指令集的详细描述，可以打开链接查看：</p><ul><li>Java 11：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2UxMS9odG1sL2p2bXMtNi5odG1s">https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html<i class="fa fa-external-link-alt"></i></span></li><li>Java 8：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWw=">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html<i class="fa fa-external-link-alt"></i></span></li></ul><p>也有人整理了一个对照表，记录在下面</p><span id="more"></span><table><thead><tr><th align="center">字节码</th><th align="center">助记符</th><th>指令含义</th></tr></thead><tbody><tr><td align="center">0x00</td><td align="center">nop</td><td>None</td></tr><tr><td align="center">0x01</td><td align="center">aconst_null</td><td>将null推送至栈顶</td></tr><tr><td align="center">0x02</td><td align="center">iconst_m1</td><td>将int型-1推送至栈顶</td></tr><tr><td align="center">0x03</td><td align="center">iconst_0</td><td>将int型0推送至栈顶</td></tr><tr><td align="center">0x04</td><td align="center">iconst_1</td><td>将int型1推送至栈顶</td></tr><tr><td align="center">0x05</td><td align="center">iconst_2</td><td>将int型2推送至栈顶</td></tr><tr><td align="center">0x06</td><td align="center">iconst_3</td><td>将int型3推送至栈顶</td></tr><tr><td align="center">0x07</td><td align="center">iconst_4</td><td>将int型4推送至栈顶</td></tr><tr><td align="center">0x08</td><td align="center">iconst_5</td><td>将int型5推送至栈顶</td></tr><tr><td align="center">0x09</td><td align="center">lconst_0</td><td>将long型0推送至栈顶</td></tr><tr><td align="center">0x0a</td><td align="center">lconst_1</td><td>将long型1推送至栈顶</td></tr><tr><td align="center">0x0b</td><td align="center">fconst_0</td><td>将float型0推送至栈顶</td></tr><tr><td align="center">0x0c</td><td align="center">fconst_1</td><td>将float型1推送至栈顶</td></tr><tr><td align="center">0x0d</td><td align="center">fconst_2</td><td>将float型2推送至栈顶</td></tr><tr><td align="center">0x0e</td><td align="center">dconst_0</td><td>将double型0推送至栈顶</td></tr><tr><td align="center">0x0f</td><td align="center">dconst_1</td><td>将double型1推送至栈顶</td></tr><tr><td align="center">0x10</td><td align="center">bipush</td><td>将单字节的常量值(-128~127)推送至栈顶</td></tr><tr><td align="center">0x11</td><td align="center">sipush</td><td>将一个短整型常量(-32768~32767)推送至栈顶</td></tr><tr><td align="center">0x12</td><td align="center">ldc</td><td>将int,float或String型常量值从常量池中推送至栈顶</td></tr><tr><td align="center">0x13</td><td align="center">ldc_w</td><td>将int,float或String型常量值从常量池中推送至栈顶(宽索引)</td></tr><tr><td align="center">0x14</td><td align="center">ldc2_w</td><td>将long或double型常量值从常量池中推送至栈顶(宽索引)</td></tr><tr><td align="center">0x15</td><td align="center">iload</td><td>将指定的int型本地变量推送至栈顶</td></tr><tr><td align="center">0x16</td><td align="center">lload</td><td>将指定的long型本地变量推送至栈顶</td></tr><tr><td align="center">0x17</td><td align="center">fload</td><td>将指定的float型本地变量推送至栈顶</td></tr><tr><td align="center">0x18</td><td align="center">dload</td><td>将指定的double型本地变量推送至栈顶</td></tr><tr><td align="center">0x19</td><td align="center">aload</td><td>将指定的引用类型本地变量推送至栈顶</td></tr><tr><td align="center">0x1a</td><td align="center">iload_0</td><td>将第一个int型本地变量推送至栈顶</td></tr><tr><td align="center">0x1b</td><td align="center">iload_1</td><td>将第二个int型本地变量推送至栈顶</td></tr><tr><td align="center">0x1c</td><td align="center">iload_2</td><td>将第三个int型本地变量推送至栈顶</td></tr><tr><td align="center">0x1d</td><td align="center">iload_3</td><td>将第四个int型本地变量推送至栈顶</td></tr><tr><td align="center">0x1e</td><td align="center">lload_0</td><td>将第一个long型本地变量推送至栈顶</td></tr><tr><td align="center">0x1f</td><td align="center">lload_1</td><td>将第二个long型本地变量推送至栈顶</td></tr><tr><td align="center">0x20</td><td align="center">lload_2</td><td>将第三个long型本地变量推送至栈顶</td></tr><tr><td align="center">0x21</td><td align="center">lload_3</td><td>将第四个long型本地变量推送至栈顶</td></tr><tr><td align="center">0x22</td><td align="center">fload_0</td><td>将第一个float型本地变量推送至栈顶</td></tr><tr><td align="center">0x23</td><td align="center">fload_1</td><td>将第二个float型本地变量推送至栈顶</td></tr><tr><td align="center">0x24</td><td align="center">fload_2</td><td>将第三个float型本地变量推送至栈顶</td></tr><tr><td align="center">0x25</td><td align="center">fload_3</td><td>将第四个float型本地变量推送至栈顶</td></tr><tr><td align="center">0x26</td><td align="center">dload_0</td><td>将第一个double型本地变量推送至栈顶</td></tr><tr><td align="center">0x27</td><td align="center">dload_1</td><td>将第二个double型本地变量推送至栈顶</td></tr><tr><td align="center">0x28</td><td align="center">dload_2</td><td>将第三个double型本地变量推送至栈顶</td></tr><tr><td align="center">0x29</td><td align="center">dload_3</td><td>将第四个double型本地变量推送至栈顶</td></tr><tr><td align="center">0x2a</td><td align="center">aload_0</td><td>将第一个引用类型本地变量推送至栈顶</td></tr><tr><td align="center">0x2b</td><td align="center">aload_1</td><td>将第二个引用类型本地变量推送至栈顶</td></tr><tr><td align="center">0x2c</td><td align="center">aload_2</td><td>将第三个引用类型本地变量推送至栈顶</td></tr><tr><td align="center">0x2d</td><td align="center">aload_3</td><td>将第四个引用类型本地变量推送至栈顶</td></tr><tr><td align="center">0x2e</td><td align="center">iaload</td><td>将int型数组指定索引的值推送至栈顶</td></tr><tr><td align="center">0x2f</td><td align="center">laload</td><td>将long型数组指定索引的值推送至栈顶</td></tr><tr><td align="center">0x30</td><td align="center">faload</td><td>将float型数组指定索引的值推送至栈顶</td></tr><tr><td align="center">0x31</td><td align="center">daload</td><td>将double型数组指定索引的值推送至栈顶</td></tr><tr><td align="center">0x32</td><td align="center">aaload</td><td>将引用类型数组指定索引的值推送至栈顶</td></tr><tr><td align="center">0x33</td><td align="center">baload</td><td>将boolean或byte型数组指定索引的值推送至栈顶</td></tr><tr><td align="center">0x34</td><td align="center">caload</td><td>将char型数组指定索引的值推送至栈顶</td></tr><tr><td align="center">0x35</td><td align="center">saload</td><td>将short型数组指定索引的值推送至栈顶</td></tr><tr><td align="center">0x36</td><td align="center">istore</td><td>将栈顶int型数值存入指定本地变量</td></tr><tr><td align="center">0x37</td><td align="center">lstore</td><td>将栈顶long型数值存入指定本地变量</td></tr><tr><td align="center">0x38</td><td align="center">fstore</td><td>将栈顶float型数值存入指定本地变量</td></tr><tr><td align="center">0x39</td><td align="center">dstore</td><td>将栈顶double型数值存入指定本地变量</td></tr><tr><td align="center">0x3a</td><td align="center">astore</td><td>将栈顶引用类型数值存入指定本地变量</td></tr><tr><td align="center">0x3b</td><td align="center">istore_0</td><td>将栈顶int型数值存入第一个本地变量</td></tr><tr><td align="center">0x3c</td><td align="center">istore_1</td><td>将栈顶int型数值存入第二个本地变量</td></tr><tr><td align="center">0x3d</td><td align="center">istore_2</td><td>将栈顶int型数值存入第三个本地变量</td></tr><tr><td align="center">0x3e</td><td align="center">istore_3</td><td>将栈顶int型数值存入第四个本地变量</td></tr><tr><td align="center">0x3f</td><td align="center">lstore_0</td><td>将栈顶long型数值存入第一个本地变量</td></tr><tr><td align="center">0x40</td><td align="center">lstore_1</td><td>将栈顶long型数值存入第二个本地变量</td></tr><tr><td align="center">0x41</td><td align="center">lstore_2</td><td>将栈顶long型数值存入第三个本地变量</td></tr><tr><td align="center">0x42</td><td align="center">lstore_3</td><td>将栈顶long型数值存入第四个本地变量</td></tr><tr><td align="center">0x43</td><td align="center">fstore_0</td><td>将栈顶float型数值存入第一个本地变量</td></tr><tr><td align="center">0x44</td><td align="center">fstore_1</td><td>将栈顶float型数值存入第二个本地变量</td></tr><tr><td align="center">0x45</td><td align="center">fstore_2</td><td>将栈顶float型数值存入第三个本地变量</td></tr><tr><td align="center">0x46</td><td align="center">fstore_3</td><td>将栈顶float型数值存入第四个本地变量</td></tr><tr><td align="center">0x47</td><td align="center">dstore_0</td><td>将栈顶double型数值存入第一个本地变量</td></tr><tr><td align="center">0x48</td><td align="center">dstore_1</td><td>将栈顶double型数值存入第二个本地变量</td></tr><tr><td align="center">0x49</td><td align="center">dstore_2</td><td>将栈顶double型数值存入第三个本地变量</td></tr><tr><td align="center">0x4a</td><td align="center">dstore_3</td><td>将栈顶double型数值存入第四个本地变量</td></tr><tr><td align="center">0x4b</td><td align="center">astore_0</td><td>将栈顶引用型数值存入第一个本地变量</td></tr><tr><td align="center">0x4c</td><td align="center">astore_1</td><td>将栈顶引用型数值存入第二个本地变量</td></tr><tr><td align="center">0x4d</td><td align="center">astore_2</td><td>将栈顶引用型数值存入第三个本地变量</td></tr><tr><td align="center">0x4e</td><td align="center">astore_3</td><td>将栈顶引用型数值存入第四个本地变量</td></tr><tr><td align="center">0x4f</td><td align="center">iastore</td><td>将栈顶int型数值存入指定数组的指定索引位置</td></tr><tr><td align="center">0x50</td><td align="center">lastore</td><td>将栈顶long型数值存入指定数组的指定索引位置</td></tr><tr><td align="center">0x51</td><td align="center">fastore</td><td>将栈顶float型数值存入指定数组的指定索引位置</td></tr><tr><td align="center">0x52</td><td align="center">dastore</td><td>将栈顶double型数值存入指定数组的指定索引位置</td></tr><tr><td align="center">0x53</td><td align="center">aastore</td><td>将栈顶引用型数值存入指定数组的指定索引位置</td></tr><tr><td align="center">0x54</td><td align="center">bastore</td><td>将栈顶boolean或byte型数值存入指定数组的指定索引位置</td></tr><tr><td align="center">0x55</td><td align="center">castore</td><td>将栈顶char型数值存入指定数组的指定索引位置</td></tr><tr><td align="center">0x56</td><td align="center">sastore</td><td>将栈顶short型数值存入指定数组的指定索引位置</td></tr><tr><td align="center">0x57</td><td align="center">pop</td><td>将栈顶数值弹出(数值不能是long或double类型的)</td></tr><tr><td align="center">0x58</td><td align="center">pop2</td><td>将栈顶的一个(对于非long或double类型)或两个数值(对于非long或double的其他类型)弹出</td></tr><tr><td align="center">0x59</td><td align="center">dup</td><td>复制栈顶数值并将复制值压入栈顶</td></tr><tr><td align="center">0x5a</td><td align="center">dup_x1</td><td>复制栈顶数值并将两个复制值压入栈顶</td></tr><tr><td align="center">0x5b</td><td align="center">dup_x2</td><td>复制栈顶数值并将三个(或两个)复制值压入栈顶</td></tr><tr><td align="center">0x5c</td><td align="center">dup2</td><td>复制栈顶一个(对于long或double类型)或两个(对于非long或double的其他类型)数值并将复制值压入栈顶</td></tr><tr><td align="center">0x5d</td><td align="center">dup2_x1</td><td>dup_x1指令的双倍版本</td></tr><tr><td align="center">0x5e</td><td align="center">dup2_x2</td><td>dup_x2指令的双倍版本</td></tr><tr><td align="center">0x5f</td><td align="center">swap</td><td>将栈顶最顶端的两个数值互换(数值不能是long或double类型)</td></tr><tr><td align="center">0x60</td><td align="center">iadd</td><td>将栈顶两int型数值相加并将结果压入栈顶</td></tr><tr><td align="center">0x61</td><td align="center">ladd</td><td>将栈顶两long型数值相加并将结果压入栈顶</td></tr><tr><td align="center">0x62</td><td align="center">fadd</td><td>将栈顶两float型数值相加并将结果压入栈顶</td></tr><tr><td align="center">0x63</td><td align="center">dadd</td><td>将栈顶两double型数值相加并将结果压入栈顶</td></tr><tr><td align="center">0x64</td><td align="center">isub</td><td>将栈顶两int型数值相减并将结果压入栈顶</td></tr><tr><td align="center">0x65</td><td align="center">lsub</td><td>将栈顶两long型数值相减并将结果压入栈顶</td></tr><tr><td align="center">0x66</td><td align="center">fsub</td><td>将栈顶两float型数值相减并将结果压入栈顶</td></tr><tr><td align="center">0x67</td><td align="center">dsub</td><td>将栈顶两double型数值相减并将结果压入栈顶</td></tr><tr><td align="center">0x68</td><td align="center">imul</td><td>将栈顶两int型数值相乘并将结果压入栈顶</td></tr><tr><td align="center">0x69</td><td align="center">lmul</td><td>将栈顶两long型数值相乘并将结果压入栈顶</td></tr><tr><td align="center">0x6a</td><td align="center">fmul</td><td>将栈顶两float型数值相乘并将结果压入栈顶</td></tr><tr><td align="center">0x6b</td><td align="center">dmul</td><td>将栈顶两double型数值相乘并将结果压入栈顶</td></tr><tr><td align="center">0x6c</td><td align="center">idiv</td><td>将栈顶两int型数值相除并将结果压入栈顶</td></tr><tr><td align="center">0x6d</td><td align="center">ldiv</td><td>将栈顶两long型数值相除并将结果压入栈顶</td></tr><tr><td align="center">0x6e</td><td align="center">fdiv</td><td>将栈顶两float型数值相除并将结果压入栈顶</td></tr><tr><td align="center">0x6f</td><td align="center">ddiv</td><td>将栈顶两double型数值相除并将结果压入栈顶</td></tr><tr><td align="center">0x70</td><td align="center">irem</td><td>将栈顶两int型数值作取模运算并将结果压入栈顶</td></tr><tr><td align="center">0x71</td><td align="center">lrem</td><td>将栈顶两long型数值作取模运算并将结果压入栈顶</td></tr><tr><td align="center">0x72</td><td align="center">frem</td><td>将栈顶两float型数值作取模运算并将结果压入栈顶</td></tr><tr><td align="center">0x73</td><td align="center">drem</td><td>将栈顶两double型数值作取模运算并将结果压入栈顶</td></tr><tr><td align="center">0x74</td><td align="center">ineg</td><td>将栈顶int型数值取负并将结果压入栈顶</td></tr><tr><td align="center">0x75</td><td align="center">lneg</td><td>将栈顶long型数值取负并将结果压入栈顶</td></tr><tr><td align="center">0x76</td><td align="center">fneg</td><td>将栈顶float型数值取负并将结果压入栈顶</td></tr><tr><td align="center">0x77</td><td align="center">dneg</td><td>将栈顶double型数值取负并将结果压入栈顶</td></tr><tr><td align="center">0x78</td><td align="center">ishl</td><td>将int型数值左移指定位数并将结果压入栈顶</td></tr><tr><td align="center">0x79</td><td align="center">lshl</td><td>将long型数值左移指定位数并将结果压入栈顶</td></tr><tr><td align="center">0x7a</td><td align="center">ishr</td><td>将int型数值右(带符号)移指定位数并将结果压入栈顶</td></tr><tr><td align="center">0x7b</td><td align="center">lshr</td><td>将long型数值右(带符号)移指定位数并将结果压入栈顶</td></tr><tr><td align="center">0x7c</td><td align="center">iushr</td><td>将int型数值右(无符号)移指定位数并将结果压入栈顶</td></tr><tr><td align="center">0x7d</td><td align="center">lushr</td><td>将long型数值右(无符号)移指定位数并将结果压入栈顶</td></tr><tr><td align="center">0x7e</td><td align="center">iand</td><td>将栈顶两int型数值”按位与”并将结果压入栈顶</td></tr><tr><td align="center">0x7f</td><td align="center">land</td><td>将栈顶两long型数值”按位与”并将结果压入栈顶</td></tr><tr><td align="center">0x80</td><td align="center">ior</td><td>将栈顶两int型数值”按位或”并将结果压入栈顶</td></tr><tr><td align="center">0x81</td><td align="center">lor</td><td>将栈顶两long型数值”按位或”并将结果压入栈顶</td></tr><tr><td align="center">0x82</td><td align="center">ixor</td><td>将栈顶两int型数值”按位异或”并将结果压入栈顶</td></tr><tr><td align="center">0x83</td><td align="center">lxor</td><td>将栈顶两long型数值”按位异或”并将结果压入栈顶</td></tr><tr><td align="center">0x84</td><td align="center">iinc</td><td>将指定int型变量增加指定值(如i++, i–, i+=2等)</td></tr><tr><td align="center">0x85</td><td align="center">i2l</td><td>将栈顶int型数值强制转换为long型数值并将结果压入栈顶</td></tr><tr><td align="center">0x86</td><td align="center">i2f</td><td>将栈顶int型数值强制转换为float型数值并将结果压入栈顶</td></tr><tr><td align="center">0x87</td><td align="center">i2d</td><td>将栈顶int型数值强制转换为double型数值并将结果压入栈顶</td></tr><tr><td align="center">0x88</td><td align="center">l2i</td><td>将栈顶long型数值强制转换为int型数值并将结果压入栈顶</td></tr><tr><td align="center">0x89</td><td align="center">l2f</td><td>将栈顶long型数值强制转换为float型数值并将结果压入栈顶</td></tr><tr><td align="center">0x8a</td><td align="center">l2d</td><td>将栈顶long型数值强制转换为double型数值并将结果压入栈顶</td></tr><tr><td align="center">0x8b</td><td align="center">f2i</td><td>将栈顶float型数值强制转换为int型数值并将结果压入栈顶</td></tr><tr><td align="center">0x8c</td><td align="center">f2l</td><td>将栈顶float型数值强制转换为long型数值并将结果压入栈顶</td></tr><tr><td align="center">0x8d</td><td align="center">f2d</td><td>将栈顶float型数值强制转换为double型数值并将结果压入栈顶</td></tr><tr><td align="center">0x8e</td><td align="center">d2i</td><td>将栈顶double型数值强制转换为int型数值并将结果压入栈顶</td></tr><tr><td align="center">0x8f</td><td align="center">d2l</td><td>将栈顶double型数值强制转换为long型数值并将结果压入栈顶</td></tr><tr><td align="center">0x90</td><td align="center">d2f</td><td>将栈顶double型数值强制转换为float型数值并将结果压入栈顶</td></tr><tr><td align="center">0x91</td><td align="center">i2b</td><td>将栈顶int型数值强制转换为byte型数值并将结果压入栈顶</td></tr><tr><td align="center">0x92</td><td align="center">i2c</td><td>将栈顶int型数值强制转换为char型数值并将结果压入栈顶</td></tr><tr><td align="center">0x93</td><td align="center">i2s</td><td>将栈顶int型数值强制转换为short型数值并将结果压入栈顶</td></tr><tr><td align="center">0x94</td><td align="center">lcmp</td><td>比较栈顶两long型数值大小, 并将结果(1, 0或-1)压入栈顶</td></tr><tr><td align="center">0x95</td><td align="center">fcmpl</td><td>比较栈顶两float型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为NaN时, 将-1压入栈顶</td></tr><tr><td align="center">0x96</td><td align="center">fcmpg</td><td>比较栈顶两float型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为NaN时, 将1压入栈顶</td></tr><tr><td align="center">0x97</td><td align="center">dcmpl</td><td>比较栈顶两double型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为NaN时, 将-1压入栈顶</td></tr><tr><td align="center">0x98</td><td align="center">dcmpg</td><td>比较栈顶两double型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为NaN时, 将1压入栈顶</td></tr><tr><td align="center">0x99</td><td align="center">ifeq</td><td>当栈顶int型数值等于0时跳转</td></tr><tr><td align="center">0x9a</td><td align="center">ifne</td><td>当栈顶int型数值不等于0时跳转</td></tr><tr><td align="center">0x9b</td><td align="center">iflt</td><td>当栈顶int型数值小于0时跳转</td></tr><tr><td align="center">0x9c</td><td align="center">ifge</td><td>当栈顶int型数值大于等于0时跳转</td></tr><tr><td align="center">0x9d</td><td align="center">ifgt</td><td>当栈顶int型数值大于0时跳转</td></tr><tr><td align="center">0x9e</td><td align="center">ifle</td><td>当栈顶int型数值小于等于0时跳转</td></tr><tr><td align="center">0x9f</td><td align="center">if_icmpeq</td><td>比较栈顶两int型数值大小, 当结果等于0时跳转</td></tr><tr><td align="center">0xa0</td><td align="center">if_icmpne</td><td>比较栈顶两int型数值大小, 当结果不等于0时跳转</td></tr><tr><td align="center">0xa1</td><td align="center">if_icmplt</td><td>比较栈顶两int型数值大小, 当结果小于0时跳转</td></tr><tr><td align="center">0xa2</td><td align="center">if_icmpge</td><td>比较栈顶两int型数值大小, 当结果大于等于0时跳转</td></tr><tr><td align="center">0xa3</td><td align="center">if_icmpgt</td><td>比较栈顶两int型数值大小, 当结果大于0时跳转</td></tr><tr><td align="center">0xa4</td><td align="center">if_icmple</td><td>比较栈顶两int型数值大小, 当结果小于等于0时跳转</td></tr><tr><td align="center">0xa5</td><td align="center">if_acmpeq</td><td>比较栈顶两引用型数值, 当结果相等时跳转</td></tr><tr><td align="center">0xa6</td><td align="center">if_acmpne</td><td>比较栈顶两引用型数值, 当结果不相等时跳转</td></tr><tr><td align="center">0xa7</td><td align="center">goto</td><td>无条件跳转</td></tr><tr><td align="center">0xa8</td><td align="center">jsr</td><td>跳转至指定的16位offset位置, 并将jsr的下一条指令地址压入栈顶</td></tr><tr><td align="center">0xa9</td><td align="center">ret</td><td>返回至本地变量指定的index的指令位置(一般与jsr或jsr_w联合使用)</td></tr><tr><td align="center">0xaa</td><td align="center">tableswitch</td><td>用于switch条件跳转, case值连续(可变长度指令)</td></tr><tr><td align="center">0xab</td><td align="center">lookupswitch</td><td>用于switch条件跳转, case值不连续(可变长度指令)</td></tr><tr><td align="center">0xac</td><td align="center">ireturn</td><td>从当前方法返回int</td></tr><tr><td align="center">0xad</td><td align="center">lreturn</td><td>从当前方法返回long</td></tr><tr><td align="center">0xae</td><td align="center">freturn</td><td>从当前方法返回float</td></tr><tr><td align="center">0xaf</td><td align="center">dreturn</td><td>从当前方法返回double</td></tr><tr><td align="center">0xb0</td><td align="center">areturn</td><td>从当前方法返回对象引用</td></tr><tr><td align="center">0xb1</td><td align="center">return</td><td>从当前方法返回void</td></tr><tr><td align="center">0xb2</td><td align="center">getstatic</td><td>获取指定类的静态域, 并将其压入栈顶</td></tr><tr><td align="center">0xb3</td><td align="center">putstatic</td><td>为指定类的静态域赋值</td></tr><tr><td align="center">0xb4</td><td align="center">getfield</td><td>获取指定类的实例域, 并将其压入栈顶</td></tr><tr><td align="center">0xb5</td><td align="center">putfield</td><td>为指定类的实例域赋值</td></tr><tr><td align="center">0xb6</td><td align="center">invokevirtual</td><td>调用实例方法</td></tr><tr><td align="center">0xb7</td><td align="center">invokespecial</td><td>调用超类构建方法, 实例初始化方法, 私有方法</td></tr><tr><td align="center">0xb8</td><td align="center">invokestatic</td><td>调用静态方法</td></tr><tr><td align="center">0xb9</td><td align="center">invokeinterface</td><td>调用接口方法</td></tr><tr><td align="center">0xba</td><td align="center">invokedynamic</td><td>调用动态方法</td></tr><tr><td align="center">0xbb</td><td align="center">new</td><td>创建一个对象, 并将其引用引用值压入栈顶</td></tr><tr><td align="center">0xbc</td><td align="center">newarray</td><td>创建一个指定的原始类型(如int, float, char等)的数组, 并将其引用值压入栈顶</td></tr><tr><td align="center">0xbd</td><td align="center">anewarray</td><td>创建一个引用型(如类, 接口, 数组)的数组, 并将其引用值压入栈顶</td></tr><tr><td align="center">0xbe</td><td align="center">arraylength</td><td>获取数组的长度值并压入栈顶</td></tr><tr><td align="center">0xbf</td><td align="center">athrow</td><td>将栈顶的异常抛出</td></tr><tr><td align="center">0xc0</td><td align="center">checkcast</td><td>检验类型转换, 检验未通过将抛出 ClassCastException</td></tr><tr><td align="center">0xc1</td><td align="center">instanceof</td><td>检验对象是否是指定类的实际, 如果是将1压入栈顶, 否则将0压入栈顶</td></tr><tr><td align="center">0xc2</td><td align="center">monitorenter</td><td>获得对象的锁, 用于同步方法或同步块</td></tr><tr><td align="center">0xc3</td><td align="center">monitorexit</td><td>释放对象的锁, 用于同步方法或同步块</td></tr><tr><td align="center">0xc4</td><td align="center">wide</td><td>扩展本地变量的宽度</td></tr><tr><td align="center">0xc5</td><td align="center">multianewarray</td><td>创建指定类型和指定维度的多维数组(执行该指令时, 操作栈中必须包含各维度的长度值), 并将其引用压入栈顶</td></tr><tr><td align="center">0xc6</td><td align="center">ifnull</td><td>为null时跳转</td></tr><tr><td align="center">0xc7</td><td align="center">ifnonnull</td><td>不为null时跳转</td></tr><tr><td align="center">0xc8</td><td align="center">goto_w</td><td>无条件跳转(宽索引)</td></tr><tr><td align="center">0xc9</td><td align="center">jsr_w</td><td>跳转至指定的32位offset位置, 并将jsr_w的下一条指令地址压入栈顶</td></tr></tbody></table><p>推荐阅读：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTkvMDkvMDUvamF2YS1ieXRlY29kZS1lbmhhbmNlbWVudC5odG1s">字节码增强技术探索 - 美团技术团队<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Java Virtual Machine Specification 中，有对 JVM 指令集的详细描述，可以打开链接查看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 11：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2UxMS9odG1sL2p2bXMtNi5odG1s&quot;&gt;https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Java 8：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWw=&quot;&gt;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也有人整理了一个对照表，记录在下面&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://yonghong.tech/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yonghong.tech/tags/Java/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
    <category term="指令集" scheme="http://yonghong.tech/tags/%E6%8C%87%E4%BB%A4%E9%9B%86/"/>
    
    <category term="Instruction" scheme="http://yonghong.tech/tags/Instruction/"/>
    
  </entry>
  
  <entry>
    <title>hg clone 与 Mercurial</title>
    <link href="http://yonghong.tech/2021/01/mercurial/"/>
    <id>http://yonghong.tech/2021/01/mercurial/</id>
    <published>2021-01-06T14:24:00.000Z</published>
    <updated>2021-01-06T14:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mercurial是跨平台的分布式版本控制软件，主要由Python语言实现，但也包含用C语言实现的二进制比较工具。Mercurial一开始的主要运行平台是Linux，现在Mercurial已经移植到Windows、Mac OS X和大多数的类Unix系统中。Mercurial主要由命令行程序组成，现在也有了图形用户界面。对Mercurial的所有操作都由用不同的关键字作为参数调用程序“hg”来实现，Hg是参考水银的化学符号而取的名字。</p><p>Mercurial的主要设计目标包括高性能、可扩展性、分散性、完全分布式合作开发、能同时高效地处理纯文本和二进制文件，以及分支和合并功能，以此同时保持系统的简洁性[1]。Mercurial也包括一个集成的Web界面。</p><p>Mercurial的创建者和主要开发人员是Matt Mackal。其源代码采用GNU通用公共许可证第二版为授权，确保了Mercurial是一个自由软件。</p><span id="more"></span><h2 id="获取-Mercurial"><a href="#获取-Mercurial" class="headerlink" title="获取 Mercurial"></a>获取 Mercurial</h2><p>Mercurial 官方网站：<span class="exturl" data-url="aHR0cHM6Ly93d3cubWVyY3VyaWFsLXNjbS5vcmcv">https://www.mercurial-scm.org/<i class="fa fa-external-link-alt"></i></span></p><p>我们可以从官方网站上获取到软件安装包：<span class="exturl" data-url="aHR0cHM6Ly93d3cubWVyY3VyaWFsLXNjbS5vcmcvZG93bmxvYWRz">https://www.mercurial-scm.org/downloads<i class="fa fa-external-link-alt"></i></span></p><p>还可以根据系统选择合适安装方式安装命令行工具：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Debian/Ubuntu</span></span><br><span class="line"><span class="variable">$</span> apt<span class="literal">-get</span> install mercurial</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fedora</span></span><br><span class="line"><span class="variable">$</span> dnf install mercurial</span><br><span class="line"></span><br><span class="line"><span class="comment"># Gentoo</span></span><br><span class="line"><span class="variable">$</span> emerge mercurial</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mac OS (homebrew)</span></span><br><span class="line"><span class="variable">$</span> brew install mercurial</span><br><span class="line"></span><br><span class="line"><span class="comment"># FreeBSD</span></span><br><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> /usr/ports/devel/mercurial</span><br><span class="line"><span class="variable">$</span> make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solaris 11 Express</span></span><br><span class="line"><span class="variable">$</span> pkg install SUNWmercurial</span><br></pre></td></tr></table></figure><h2 id="使用-hg-命令行工具-clone-软件仓库"><a href="#使用-hg-命令行工具-clone-软件仓库" class="headerlink" title="使用 hg 命令行工具 clone 软件仓库"></a>使用 hg 命令行工具 clone 软件仓库</h2><p>比如 OpenJDK 的软件仓库：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hg clone https:<span class="regexp">//</span>hg.openjdk.java.net<span class="regexp">/jdk/</span>jdk11</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mercurial是跨平台的分布式版本控制软件，主要由Python语言实现，但也包含用C语言实现的二进制比较工具。Mercurial一开始的主要运行平台是Linux，现在Mercurial已经移植到Windows、Mac OS X和大多数的类Unix系统中。Mercurial主要由命令行程序组成，现在也有了图形用户界面。对Mercurial的所有操作都由用不同的关键字作为参数调用程序“hg”来实现，Hg是参考水银的化学符号而取的名字。&lt;/p&gt;
&lt;p&gt;Mercurial的主要设计目标包括高性能、可扩展性、分散性、完全分布式合作开发、能同时高效地处理纯文本和二进制文件，以及分支和合并功能，以此同时保持系统的简洁性[1]。Mercurial也包括一个集成的Web界面。&lt;/p&gt;
&lt;p&gt;Mercurial的创建者和主要开发人员是Matt Mackal。其源代码采用GNU通用公共许可证第二版为授权，确保了Mercurial是一个自由软件。&lt;/p&gt;</summary>
    
    
    
    <category term="版本控制" scheme="http://yonghong.tech/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
    <category term="hg" scheme="http://yonghong.tech/tags/hg/"/>
    
    <category term="Mercurial" scheme="http://yonghong.tech/tags/Mercurial/"/>
    
  </entry>
  
  <entry>
    <title>技术爱好者周刊 第11期 | 2020年12月14日</title>
    <link href="http://yonghong.tech/weekly-011/"/>
    <id>http://yonghong.tech/weekly-011/</id>
    <published>2020-12-14T02:24:00.000Z</published>
    <updated>2020-12-14T02:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>技术爱好者周刊，每周一发布，欢迎提<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dhbmd5b25naG9uZy95b25naG9uZy1tZS9pc3N1ZXM=">issue<i class="fa fa-external-link-alt"></i></span>贡献内容。</p></blockquote><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMTIvMTAvYXBhY2hlLWt5bGluLXByYWN0aWNlLWluLW1laXR1YW4uaHRtbA==">C++服务编译耗时优化原理及实践<i class="fa fa-external-link-alt"></i></span><br>大型C++工程项目，都会面临编译耗时较长的问题。不管是开发调试迭代、准入测试，亦或是持续集成阶段，编译行为无处不在，降低编译时间对提高研发效率来说具有非常重要意义。</li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvMnNvTHIxRjBYN3JjOGZaLTJmVEU2QQ==">爱奇艺微服务标准技术架构实践<i class="fa fa-external-link-alt"></i></span><br>为数以亿计的用户提供优质的视频服务的爱奇艺技术产品团队，为了适应业务的快速迭代和创新，并支撑海量的用户请求，很多团队都对各自的业务系统自发地进行了微服务架构的改造。</li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvbEhHQzlKZUtiM29rVnV1UXkzekNXZw==">步入超高清视频时代视频编码技术的机遇与挑战——AV1时代要来了<i class="fa fa-external-link-alt"></i></span><br>近些年随着视频行业的迅猛发展，尤其像短视频、点播、直播、VR等领域的爆发，人们对于高清、超高清视频体验的追求越来越强烈，流媒体平台如何在提升观众观看体验，同时降低播放成本，利用技术降低带宽消耗的同时又能最大化的还原视频的画质和质量，成为了重要的课题。</li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvTGtDb2FVRTVzbDg4SjkwaVZ3bG45QQ==">一文彻底理解 I/O 多路复用<i class="fa fa-external-link-alt"></i></span><br>这里的关键点在于，我们事先并不知道一个文件描述对应的I/O设备是否是可读的、是否是可写的，在外设的不可读或不可写的状态下进行I/O只会导致进程阻塞被暂停运行。</li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvVmlIS2Y5Y0Izbl9JalM0TFVIeXpLUQ==">10 张图告诉你，Kafka 是怎么做到支持百万级 TPS 的？<i class="fa fa-external-link-alt"></i></span><br>谈到大数据传输都会想到 Kafka，Kafka 号称大数据的杀手锏，在业界有很多成熟的应用场景并且被主流公司认可。这款为大数据而生的消息中间件，以其百万级TPS的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。在业界已经有很多成熟的消息中间件如：RabbitMQ, RocketMQ, ActiveMQ, ZeroMQ，为什么 Kafka 在众多的敌手中依然能有一席之地，当然靠的是其强悍的吞吐量。下面带领大家来揭秘。</li></ul><span id="more"></span><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLmlwYWxmaXNoLmNvbS9ibG9nLzIwMjAvMTIvMDgvYXBhY2hlX2Fycm93X3N1bW1hcnkv">Apache Arrow：一种适合异构大数据系统的内存列存数据格式标准<i class="fa fa-external-link-alt"></i></span><br>本文介绍一种内存列存数据格式：Apache Arrow，它有一个非常大的愿景：提供内存数据分析 (in-memory analytics) 的开发平台，让数据在异构大数据系统间移动、处理地更快。同时，比较特别的是这个项目的启动形式与其他项目也不相同，Arrow 项目的草台班子由 5 个 Apache Members、6 个 PMC Chairs 和一些其它项目的 PMC 及 committer 构成，他们直接找到 ASF 董事会，征得同意后直接以顶级 Apache 项目身份启动。</li></ul><h2 id="近期会议"><a href="#近期会议" class="headerlink" title="近期会议"></a>近期会议</h2><h3 id="第十一届中国数据库技术大会（DTCC2020）"><a href="#第十一届中国数据库技术大会（DTCC2020）" class="headerlink" title="第十一届中国数据库技术大会（DTCC2020）"></a>第十一届中国数据库技术大会（DTCC2020）</h3><p>报名链接：<span class="exturl" data-url="aHR0cDovL2R0Y2MuaXQxNjguY29tLw==">http://dtcc.it168.com/<i class="fa fa-external-link-alt"></i></span></p><p>会议时间：2020年12月21日 ~ 1010年12月23日</p><p>2020年12月21日~12月23日，由 IT168 旗下 ITPUB 企业社区平台主办的第十一届中国数据库技术大会（DTCC2020），将在北京隆重召开。大会以“架构革新 高效可控”为主题，设置2大主会场，20+技术专场，将邀请超百位行业专家，重点围绕数据架构、AI与大数据、传统企业数据库实践和国产开源数据库等内容展开分享和探讨，为广大数据领域从业人士提供一场年度盛会和交流平台。</p><p>为了帮助更多企业落地数据项目实施方案，今年将继续开设多门深度培训课程，内容涵盖数据中台、去IOE实践、区块链技术、内核开发实践等。3天传统技术演讲+1天深度主题，将汇聚各行业精英、技术领袖、行业专家和数据英雄，带来超过100场主题演讲和超5场培训课程的头脑风暴，诚邀您的加入。</p><p>历经十年的积累与沉淀，如今的DTCC已然成为国内数据库领域的技术风向标，见证了整个行业的发展与演变。作为顶级的数据领域技术盛会，DTCC2020将继续秉承一贯的干货分享和实践指导原则，期待大家的热情参与！</p><h3 id="第十届PostgreSQL中国技术大会"><a href="#第十届PostgreSQL中国技术大会" class="headerlink" title="第十届PostgreSQL中国技术大会"></a>第十届PostgreSQL中国技术大会</h3><p>报名链接：<span class="exturl" data-url="aHR0cDovL3BnY29uZjIwMjAucG9zdGdyZXMuY24v">http://pgconf2020.postgres.cn/<i class="fa fa-external-link-alt"></i></span></p><p>会议时间：2021年1月15日 ~ 2021年1月16日</p><p>2021年1月15～1月16日，由 PostgreSQL 中文社区主办的第十届《PostgreSQL 中国技术大会》将在南京索菲特银河大酒店现场隆重举办。</p><p>PostgreSQL 作为功能最强的的开源关系型数据库之一，得到了越来越多企业的推广和运用，也越来越受到广大技术爱好者的欢迎和重视。</p><p>本次大会以“开源，自研，新机遇”为主题。除了设立一个主会场外，还设立了多个分会场。大会汇聚了来自互联网、电商、教育，金融等各行业领域的专家，这将是 PostgreSQL 发展史上的又一次交流盛会。</p><h2 id="其他周报"><a href="#其他周报" class="headerlink" title="其他周报"></a>其他周报</h2><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1YW55Zi93ZWVrbHkvYmxvYi9tYXN0ZXIvZG9jcy9pc3N1ZS0xMzcubWQ=">科技爱好者周刊（第 137 期）：Slack 被收购，以及企业的技术选型<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BvbGFyaXMxMTE5L2dvbGFuZ3dlZWtseS9ibG9iL21hc3Rlci9kb2NzL2lzc3VlLTA3My5tZA==">Go语言爱好者周刊：第 73 期<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3plbmFueS93ZWVrbHkvYmxvYi9tYXN0ZXIvc29mdHdhcmUvMjAyMC8xMjA3Lm1k">2020.12.07 - Flying the Nest: WebThings Gateway 1.0<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N3aWZ0T2xkRHJpdmVyL2lPUy1XZWVrbHkvYmxvYi9tYXN0ZXIvUmVwb3J0cy8yMDIwLyUyMzEzNy0yMDIwLjEyLjE0Lm1k">老司机 iOS 周报 #139 | 2020-12-14<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9yd2Vla2x5Lm9yZy8yMDIwLTQ5Lmh0bWw=">R Weekly 2020-49 ggplot2, static code analysis, visual CV<i class="fa fa-external-link-alt"></i></span></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;技术爱好者周刊，每周一发布，欢迎提&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL3dhbmd5b25naG9uZy95b25naG9uZy1tZS9pc3N1ZXM=&quot;&gt;issue&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;贡献内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;后端&quot;&gt;&lt;a href=&quot;#后端&quot; class=&quot;headerlink&quot; title=&quot;后端&quot;&gt;&lt;/a&gt;后端&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMTIvMTAvYXBhY2hlLWt5bGluLXByYWN0aWNlLWluLW1laXR1YW4uaHRtbA==&quot;&gt;C++服务编译耗时优化原理及实践&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;大型C++工程项目，都会面临编译耗时较长的问题。不管是开发调试迭代、准入测试，亦或是持续集成阶段，编译行为无处不在，降低编译时间对提高研发效率来说具有非常重要意义。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvMnNvTHIxRjBYN3JjOGZaLTJmVEU2QQ==&quot;&gt;爱奇艺微服务标准技术架构实践&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;为数以亿计的用户提供优质的视频服务的爱奇艺技术产品团队，为了适应业务的快速迭代和创新，并支撑海量的用户请求，很多团队都对各自的业务系统自发地进行了微服务架构的改造。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvbEhHQzlKZUtiM29rVnV1UXkzekNXZw==&quot;&gt;步入超高清视频时代视频编码技术的机遇与挑战——AV1时代要来了&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;近些年随着视频行业的迅猛发展，尤其像短视频、点播、直播、VR等领域的爆发，人们对于高清、超高清视频体验的追求越来越强烈，流媒体平台如何在提升观众观看体验，同时降低播放成本，利用技术降低带宽消耗的同时又能最大化的还原视频的画质和质量，成为了重要的课题。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvTGtDb2FVRTVzbDg4SjkwaVZ3bG45QQ==&quot;&gt;一文彻底理解 I/O 多路复用&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;这里的关键点在于，我们事先并不知道一个文件描述对应的I/O设备是否是可读的、是否是可写的，在外设的不可读或不可写的状态下进行I/O只会导致进程阻塞被暂停运行。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvVmlIS2Y5Y0Izbl9JalM0TFVIeXpLUQ==&quot;&gt;10 张图告诉你，Kafka 是怎么做到支持百万级 TPS 的？&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;谈到大数据传输都会想到 Kafka，Kafka 号称大数据的杀手锏，在业界有很多成熟的应用场景并且被主流公司认可。这款为大数据而生的消息中间件，以其百万级TPS的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。在业界已经有很多成熟的消息中间件如：RabbitMQ, RocketMQ, ActiveMQ, ZeroMQ，为什么 Kafka 在众多的敌手中依然能有一席之地，当然靠的是其强悍的吞吐量。下面带领大家来揭秘。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术爱好者周刊" scheme="http://yonghong.tech/categories/%E6%8A%80%E6%9C%AF%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A/"/>
    
    
    <category term="技术爱好者周刊" scheme="http://yonghong.tech/tags/%E6%8A%80%E6%9C%AF%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>JDK 15来袭，带你深入掌握 Java 15 新特性</title>
    <link href="http://yonghong.tech/2020/12/jdk-15-new-feature/"/>
    <id>http://yonghong.tech/2020/12/jdk-15-new-feature/</id>
    <published>2020-12-10T02:24:00.000Z</published>
    <updated>2020-12-10T02:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>视频来源：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXZmNHkxQjd0dA==">https://www.bilibili.com/video/BV1vf4y1B7tt<i class="fa fa-external-link-alt"></i></span></p><h2 id="大背景"><a href="#大背景" class="headerlink" title="大背景"></a>大背景</h2><h3 id="25-岁的-Java"><a href="#25-岁的-Java" class="headerlink" title="25 岁的 Java"></a>25 岁的 Java</h3><h4 id="Java-的现状"><a href="#Java-的现状" class="headerlink" title="Java 的现状"></a>Java 的现状</h4><p>2020 年是 Java 诞生的第 25 个年头，Oracle 表示，目前 Java 仍然流行是流行的编程语言，广泛使用在企业中。目前全世界有超过 69% 的专职开发人员使用 Java，全世界有 510 亿台活动 Java 虚拟机（JVM）在部署中，目前 Java 主要被用于分析、数据管理、大数据、DevOps、移动、持续开发工具和聊天机器人等服务。</p><h4 id="历史版本的主要新特性"><a href="#历史版本的主要新特性" class="headerlink" title="历史版本的主要新特性"></a>历史版本的主要新特性</h4><p>在过去的这些年中，Java 在过去增强功能的推动下为用户提供了超过二十年的创新。例如：</p><ul><li>JDK 5：enum、泛型、自动装箱与拆箱、可变参数、增强循环等</li><li>JDK 6：支持脚本语言、JDBC 4.0 API</li><li>JDK 7：支持 try-with-resources、switch 语句块增加 String 支持、NIO 2.0 包</li><li>JDK 8：lambda 表达式、Stream API、新的日期时间的 API、方法引用、构造器引用</li><li>JDK 9：模块化系统、jshell</li><li>JDK 10：局部变量的类型推断</li><li>JDK 11：ZGC 的引入、Epsilon GC</li><li>JDK 12：switch 表达式、Shenandoah GC、增强 G1</li><li>JDK 13：switch 表达式引入 yield、文本块</li><li>JDK 14：instanceof 模式识别、Records、弃用 Parallel Scavenge + Serial GC 组合、删除 CMS GC</li></ul><span id="more"></span><h4 id="近期版本发布及维护时间"><a href="#近期版本发布及维护时间" class="headerlink" title="近期版本发布及维护时间"></a>近期版本发布及维护时间</h4><p>OpenJDK 发版本路线图：</p><p><img src="https://up-img.yonghong.tech/pic/2020/12/10-09-20-lKGMjQBUu1XzDeP-96MbI6.jpg" alt="OpenJDK 发版本路线图"></p><p>Oracle Java SE 支持路线图：<span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9qYXZhL3RlY2hub2xvZ2llcy9qYXZhLXNlLXN1cHBvcnQtcm9hZG1hcC5odG1s">https://www.oracle.com/java/technologies/java-se-support-roadmap.html<i class="fa fa-external-link-alt"></i></span></p><p><img src="https://up-img.yonghong.tech/pic/2020/12/10-09-20-Oracle-Java-SE-%E6%94%AF%E6%8C%81%E8%B7%AF%E7%BA%BF%E5%9B%BE-Bwu1zb.png" alt="Oracle Java SE 支持路线图"></p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>因为是小步快跑、快速迭代，因此此处解释下这两个词：孵化器模块（Incubator）和预览特性（Preview）。</p><h4 id="孵化器模块（Incubator-孵化版-实验版）"><a href="#孵化器模块（Incubator-孵化版-实验版）" class="headerlink" title="孵化器模块（Incubator/孵化版/实验版）"></a>孵化器模块（Incubator/孵化版/实验版）</h4><p>尚未确定的 API/工具，主要用于从 Java 社区收集使用反馈，稳定性无保障，后期有较大可能性移除。</p><h4 id="预览特性（Preview-预览版）"><a href="#预览特性（Preview-预览版）" class="headerlink" title="预览特性（Preview/预览版）"></a>预览特性（Preview/预览版）</h4><p>规格已成型，实现已确定，但还未最终定稿。这些特性还是存在被移除的可能性，但一般来说最后都会被固定下来。</p><h3 id="新特性关注点"><a href="#新特性关注点" class="headerlink" title="新特性关注点"></a>新特性关注点</h3><p>角度一：语法层面</p><p>lambda 表达式、switch、自动装箱和拆箱、enum、接口中的静态方法、默认方法、私有方法</p><p>角度二：API 层面</p><p>Stream API、新的日期时间的 API、Optional、String、集合框架</p><p>角度三：底层优化</p><p>JVM 优化、元空间、GC、GC 的组合、GC 的参数、js 的执行引擎、集合底层实现等</p><h2 id="新特性概述"><a href="#新特性概述" class="headerlink" title="新特性概述"></a>新特性概述</h2><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><p>这次发布的主要功能有：</p><p>Java 15 为用户提供了 14 项主要的增强/更改,包括一个孵化器模块、三个预览功能、两个不推荐使用的功能以及两个删除功能。</p><p><span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L3Byb2plY3RzL2pkay8xNS8=">https://openjdk.java.net/projects/jdk/15/<i class="fa fa-external-link-alt"></i></span></p><p><strong>Features</strong></p><ul><li>339:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzM5">Edwards-Curve Digital Signature Algorithm (EdDSA)<i class="fa fa-external-link-alt"></i></span> </li><li>360:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzYw">Sealed Classes (Preview)<i class="fa fa-external-link-alt"></i></span> </li><li>371:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzcx">Hidden Classes<i class="fa fa-external-link-alt"></i></span>          </li><li>372:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzcy">Remove the Nashorn JavaScript Engine<i class="fa fa-external-link-alt"></i></span> </li><li>373:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzcz">Reimplement the Legacy DatagramSocket API<i class="fa fa-external-link-alt"></i></span> </li><li>374:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzc0">Disable and Deprecate Biased Locking<i class="fa fa-external-link-alt"></i></span> </li><li>375:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzc1">Pattern Matching for instanceof (Second Preview)<i class="fa fa-external-link-alt"></i></span> </li><li>377:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzc3">ZGC: A Scalable Low-Latency Garbage Collector<i class="fa fa-external-link-alt"></i></span> </li><li>378:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzc4">Text Blocks<i class="fa fa-external-link-alt"></i></span>             </li><li>379:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzc5">Shenandoah: A Low-Pause-Time Garbage Collector<i class="fa fa-external-link-alt"></i></span> </li><li>381:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzgx">Remove the Solaris and SPARC Ports<i class="fa fa-external-link-alt"></i></span> </li><li>383:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzgz">Foreign-Memory Access API (Second Incubator)<i class="fa fa-external-link-alt"></i></span> </li><li>384:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzg0">Records (Second Preview)<i class="fa fa-external-link-alt"></i></span> </li><li>385:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzg1">Deprecate RMI Activation for Removal<i class="fa fa-external-link-alt"></i></span> </li></ul><p>对应中文特性：（JEP：JDK Enhancement Proposals，JDK 增强建议，也就是 JDK 的特性新增和改进提案。）</p><ul><li>JEP 339：EdDSA 数字签名算法</li><li>JEP 360：密封类（预览）</li><li>JEP 371：隐藏类</li><li>JEP 372：删除 Nashorn JavaScript 引擎</li><li>JEP 373：重新实现 Legacy DatagramSocket API</li><li>JEP 374：禁用偏向锁</li><li>JEP 375：instanceof 模式匹配（第二次预览）</li><li>JEP 377：ZGC：一个可扩展的低延迟垃圾收集器</li><li>JEP 378：文本块</li><li>JEP 379：Shenandoah：低暂停时间垃圾收集器</li><li>JEP 381：移除 Solaris 和 SPARC 端口</li><li>JEP 383：外部存储器访问 API（第二个孵化版）</li><li>JEP 384：Records（第二次预览）</li><li>JEP 385：废弃 RMI 激活机制</li></ul><p>总结：</p><ul><li>JDK 15 整体来看新特性方面并不算很亮眼，它主要是对之前版本预览特性的功能做了确定，如文本块、ZGC 等，这么一来我们就可以放心大胆的使用了。</li><li>你发任你发，我用 Java 8。</li></ul><h3 id="做出贡献的企业"><a href="#做出贡献的企业" class="headerlink" title="做出贡献的企业"></a>做出贡献的企业</h3><p>通过 Oracle 的官方博文中看到，虽然主力军 Oracle 干了 79.68% 的工作量，其次是开源巨头红帽。但还是有不少企业参与其中。国内企业贡献最多的居然是腾讯公司，被 Oracle 点名感谢。阿里巴巴和华为也做出了不可磨灭的贡献。Java 有中国科技力量的贡献能大大提升中国 IT 的硬实力。</p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>支持 Java 15 的开发工具</p><p>目前，官方博文说支持 Java 15 的工具，就下面这三款：</p><ul><li>JetBrains IDEA</li><li>Apache NetBeans</li><li>Eclipse Marketplace</li></ul><p>运行 JDK 15 需要 IDEA 2020.2 才能支持。（JDK 14 要求 2020.1）</p><p>JDK 15 下载路径：</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9qYXZhL3RlY2hub2xvZ2llcy9qYXZhc2UvamRrMTUtYXJjaGl2ZS1kb3dubG9hZHMuaHRtbA==">https://www.oracle.com/java/technologies/javase/jdk15-archive-downloads.html<i class="fa fa-external-link-alt"></i></span></p><p>如果使用 IDEA 需要设置 Project Structure -&gt; Project -&gt; Project language level 为 15 （Preview …）</p><p>如果使用 Gradle，还需配置 build.gradle</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启预览特性</span></span><br><span class="line">tasks.withType(JavaCompile) &#123;</span><br><span class="line">    <span class="keyword">options</span>.compilerArgs += <span class="string">&quot;--enable-preview&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新特性（主菜）"><a href="#新特性（主菜）" class="headerlink" title="新特性（主菜）"></a>新特性（主菜）</h2><h3 id="01-密封类"><a href="#01-密封类" class="headerlink" title="01-密封类"></a>01-密封类</h3><p><strong>JEP 360: Sealed Classes(Preview) 密封的类和接口（预览）</strong></p><p>通过密封的类和接口来增强 Java 编程语言，这是新的预览特性。</p><p>用于限制超类的使用，密封的类和接口限制其它可能继承或实现它们的其他类或接口。</p><p>这个特性的目标包括——允许类或接口的开发者来控制哪些代码负责实现，提供了比限制使用超类的访问修饰符声明方式更多的选择，并通过支持对模式的详尽分析而支持模式匹配的未来发展。</p><p>在 Java 中，类层次结构通过继承实现代码的重用，父类的方法可以被许多子类继承。</p><p>但是，类层次结构的目的并不总是重用代码。有时，其目的是对域中存在的各种可能性进行建模，例如图形库支持的形状类型或金融应用程序支持的贷款类型。当以这种方式使用类层次结构时，我们可能需要限制子类集从而来简化建模。</p><p>具体使用：</p><p>因为我们引入了 sealed class 或 interface。这些 class 或者 interface 只允许被指定的类或者 interface 进行拓展和实现。</p><p>使用修饰符 sealed class 或 interface，这些 class 或者 interface 只允许被指定的类或者 interface 进行拓展和实现。</p><p>使用修饰符 sealed，您可以将一个类声明为密封类。密封类使用 reserved 关键字 permits 列出可以直接拓展它的类。子类可以是最终的，非密封的或密封的。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">permits</span> <span class="title">Teacher</span>, <span class="title">Student</span>, <span class="title">Worker</span> </span>&#123; <span class="comment">// 人</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123; <span class="comment">// 教师</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sealed <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="title">permits</span> <span class="title">MiddleSchoolStudent</span>, <span class="title">GraduateStudent</span> </span>&#123; <span class="comment">// 学生</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MiddleSchoolStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123; <span class="comment">// 中学生</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GraduateStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123; <span class="comment">// 研究生</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">non-sealed <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123; <span class="comment">// 工人</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RailWayWorker</span> <span class="keyword">extends</span> <span class="title">Worker</span> </span>&#123; <span class="comment">// 铁路工人</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="02-隐藏类"><a href="#02-隐藏类" class="headerlink" title="02-隐藏类"></a>02-隐藏类</h3><p><strong>JEP 371: Hidden Classes（隐藏类）</strong></p><p>该提案通过启用标准 API 来定义<strong>无法发现</strong>且<strong>具有有限生命周期</strong>的隐藏类，从而提高 JVM 上所有语言的效率。JDK 内部和外部的框架将能够动态生成类，而这些类可以定义隐藏类。通常来说基于 JVM 的很多语言都有动态生成类的机制，这样可以提高语言的灵活性和效率。</p><ul><li>隐藏类天生为框架设计的，在运行时生成内部的 class。</li><li>隐藏类只能通过反射访问，不能直接被其他类的字节码访问。</li><li>隐藏类可以独立于其他类加载、卸载，这可以减少框架的内存占用。</li></ul><p><strong>Hidden Classes 是什么呢？</strong><br>Hidden Classes 就是不能直接被其他 class 的二进制代码使用的 class。Hidden Classes 主要被一些框架用来生成运行时类，但是这些类不是用来直接使用的，而是通过反射机制来调用。</p><p>比如在 JDK 8 中引入的 lambda 表达式，JVM 并不会在编译的时候将 lambda 表达式转换成为专门的类，而是在运行时将相应的字节码动态生成相应的类对象。</p><p>另外使用动态代理也可以为某些类生成新的动态类。</p><p><strong>那么我们希望这些动态生成的类需要具有什么特性呢？</strong></p><ul><li><strong>不可发现性。</strong>因为我们是为某些静态的类动态生成的动态类，所以我们希望把这个动态生成的类看做是静态类的一部分。所以我们不希望除了该静态类之外的其他机制发现。</li><li><strong>访问控制。</strong>我们希望在访问控制静态类的同时，也能控制到动态生成的类。</li><li><strong>生命周期。</strong>动态生成类的生命周期一般都比较短，我们并不需要将其保存和静态类的生命周期一致。</li></ul><p><strong>API 的支持</strong><br>所以我们需要一些 API 来定义无法发现的且具有有限生命周期的隐藏类。这将提高所有基于 JVM 的语言实现的效率。比如：</p><ul><li>java.lang.reflect.Proxy 可以定义隐藏类作为实现代理接口的代理类。</li><li>java.lang.invoke.StringConcatFactory 可以生成隐藏类来保存常量连接的方法。</li><li>java.lang.invoke.LambdaMetaFactory 可以生成隐藏的 nestmate 类，以容纳访问封闭变量的 lambda 主体。</li></ul><p>普通类是通过调用 ClassLoader::defineClass 创建的，而隐藏来是通过调用 Lookup::defineHiddenClass 创建的。这使 JVM 从提供的字节中派生一个隐藏类，链接该隐藏类，并返回提供对隐藏类的反射访问的查找对象。调用程序可以通过返回的查找对象来获取隐藏类的 Class 对象。</p><h3 id="03-instanceof-模式匹配"><a href="#03-instanceof-模式匹配" class="headerlink" title="03-instanceof 模式匹配"></a>03-instanceof 模式匹配</h3><p><strong>JEP 375: Pattern Matching for instanceof(Second Preview) instanceof 自动匹配模式</strong></p><p>在 Java 14 中作为预览语言功能引入的 instanceof 模式匹配，在 Java 15 中处于第二次预览，而没有任何更改。</p><p>模式匹配允许程序中的通用逻辑（主要是从对象中的条件提取组件）可以更简洁地表达，Haskell 和 C# 等语言已采用模式匹配来实现简洁和安全性。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceofTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String str = (String) obj;</span><br><span class="line">            System.out.println(str.contains(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Not String Type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String str) &#123;</span><br><span class="line">            System.out.println(str.contains(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Not String Type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1(<span class="string">&quot;Hello, Java&quot;</span>);</span><br><span class="line">        test2(<span class="string">&quot;Hello, Java&quot;</span>);</span><br><span class="line">        test1(<span class="keyword">null</span>);</span><br><span class="line">        test2(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="04-ZGC-功能转正"><a href="#04-ZGC-功能转正" class="headerlink" title="04-ZGC 功能转正"></a>04-ZGC 功能转正</h3><p><strong>JEP 377: ZGC: A Scalable Low-Latency Garbage Collector(Production) ZGC 功能转正</strong></p><p>ZGC 是 Java 11 引入的新的垃圾收集器（JDK 9 以后默认的垃圾收集器是 G1），经过了多个实验阶段，自此终于成为正式特性。</p><p>自 2018 年以来，ZGC 已增加了许多改进，从并发类卸载、取消使用未使用的内存、对类数据共享的支持到改进的 NUMA 感知。此外，最大堆大小从 4 TB 增加到 16 TB。支持的平台包括 Linux、Windows 和 macOS。</p><p>ZGC 是一个重新设计的并发的垃圾回收器，通过减少 GC 停顿时间来提高性能。</p><p>但这并不是替换默认的 GC，默认的 GC 仍然还是 G1；之前需要通过 <code>-XX:+UnlockExperimentalVMOptions</code>, <code>-XX:+UseZGC</code> 来启用 ZGC，现在只需要 <code>-XX:+UseZGC</code> 就可以。相信不久的将来它必将成为默认的垃圾回收器。</p><p>相关的参数有 ZAllocationSpikeTolerance、ZCollectionInterval、ZFragmentationLimit、ZMarkStackSpaceLimit、ZProactive、ZUncommit、ZUncommitDelay、ZAllocationStall、ZPageAllocation、ZPageCacheFlush、ZRelocationSet、ZRelocationSetGroup、ZUncommit。</p><h3 id="05-文本块功能转正"><a href="#05-文本块功能转正" class="headerlink" title="05-文本块功能转正"></a>05-文本块功能转正</h3><p><strong>JEP 378: 文本块功能转正</strong></p><p>Text Blocks 首次是在 JDK 13 中以预览功能出现的，然后在 JDK 14 中又预览了一次，终于在 JDK 15 中被确定下来，可以放心使用了。</p><p>文本块是一种多行字符串文字，它避免了大多数转义序列的需要，以一种可预测的方式自动设置字符串的格式，并在需要时使开发人员可以控制格式，简化编写 Java 程序的任务。</p><p>文本块建议的目标是提高 Java 程序中的字符串的可读性，这些字符串便是以非 Java 语言编写的代码。另一个目标是支持从字符串文本迁移，规定任何新构造都可以表达与字符串文本相同的字符串集，解释相同的转义序列，并且以与字符串文本相同的方式进行操作。OpenJDK 开发人员希望添加转义序列来管理显式空白和换行控件。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextBlockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String text = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                The Sound of Silence</span></span><br><span class="line"><span class="string">                寂静之声</span></span><br><span class="line"><span class="string">                Hello darkness, my old friend</span></span><br><span class="line"><span class="string">                你好 黑暗 我的老朋友</span></span><br><span class="line"><span class="string">                I&#x27;ve come to talk with you again</span></span><br><span class="line"><span class="string">                我又来和你交谈</span></span><br><span class="line"><span class="string">                Because a vision softly creeping</span></span><br><span class="line"><span class="string">                因为有一种幻觉正向悄悄地向我袭来</span></span><br><span class="line"><span class="string">                Left its seeds while I was sleeping</span></span><br><span class="line"><span class="string">                在我熟睡的时候留下了它的种子</span></span><br><span class="line"><span class="string">                And the vision that was planted in my brain</span></span><br><span class="line"><span class="string">                这种幻觉在我的脑海里生根发芽</span></span><br><span class="line"><span class="string">                Still remains</span></span><br><span class="line"><span class="string">                缠绕着我</span></span><br><span class="line"><span class="string">                Within the sound of silence 取消换行 \</span></span><br><span class="line"><span class="string">                伴随着寂静的声音\s空格</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="06-Records"><a href="#06-Records" class="headerlink" title="06-Records"></a>06-Records</h3><p><strong>JEP 384: Records Class（预览）</strong></p><p>Records Class 也是第二次出现的预览功能，它在 JDK 14 中也出现过一次了，使用 Record 可以更方便的创建一个常量类，使用的前后代码对比如下。</p><ul><li>当你用 Record 声明一个类时，该类将自动拥有以下功能：<ul><li>获取成员变量的简单方法，以上面的代码为例 name() 和 partner()。注意区分于我们平常 getter 的写法。</li><li>一个 equals 方法的实现，执行比较时会比较该类的所有成员属性。</li><li>重写 equals 当然要重写 hashCode。</li><li>一个可以打印该类所有成员属性的 toString 方法。</li><li>请注意只会有一个构造方法。</li></ul></li></ul><h2 id="新特性（配菜）"><a href="#新特性（配菜）" class="headerlink" title="新特性（配菜）"></a>新特性（配菜）</h2><h3 id="01-EdDSA-数字签名算法"><a href="#01-EdDSA-数字签名算法" class="headerlink" title="01-EdDSA 数字签名算法"></a>01-EdDSA 数字签名算法</h3><p><strong>JEP 339: Edwards-Curve Digital Signature Algorithm（EdDSA 数字签名算法）</strong></p><p>这是一个新的功能。新加入基于 Edwards-Curve 数字签名算法（Edwards-Curve Digital Signature Algorithm）的加密签名，即爱德华兹曲线数字签名算法。</p><p>与 JDK 中的现有签名方案相比，EdDSA 具有更高的安全性和性能，因此备受关注。它已经在 OpenSSL 和 BoringSSL 等加密库中得到支持，在区块链领域用的比较多。</p><p>EdDSA 是一种现代的椭圆曲线方案，具有 JDK 中现有签名方案的优点。</p><h3 id="02-重新实现-DatagramSocket-API"><a href="#02-重新实现-DatagramSocket-API" class="headerlink" title="02-重新实现 DatagramSocket API"></a>02-重新实现 DatagramSocket API</h3><p><strong>JEP 373: Reimplement the Legacy DatagramSocket API（重新实现 DatagramSocket API）</strong></p><p>新的计划是 JEP 353 的后续，该方案重新实现了遗留的套接字 API。</p><p>java.net.datagram.Socket 和 java.net.MulticastSocket 的当前实现可以追溯到 JDK 1.0，那时 IPv6 还在开发中。因此，当前的多播套接字实现尝试调和 IPv4 和 IPv6 难以维护的方式。</p><ul><li>通过替换 java.net.datagram 的基础实现，重新实现旧版 DatagramSocket API。</li><li>更改 java.net.DatagramSocket 和 java.net.MulticastSocket 为更加简单、现代化的底层实现。提高了 JDK 的可维护性和稳定性。</li></ul><p>新的实现：</p><ul><li>易于调试和维护</li><li>与 Project Loom 中正在探索的虚拟线程协同</li></ul><h3 id="03-禁用偏向锁"><a href="#03-禁用偏向锁" class="headerlink" title="03-禁用偏向锁"></a>03-禁用偏向锁</h3><p><strong>JEP 374: Disable and Deprecate Biased Locking 禁用偏向锁定</strong></p><p>在默认情况下禁用偏向锁定，并弃用所有相关命令行选项。目标是确定是否需要继续支持偏置锁定的高维护成本的遗留同步优化，<strong>HotSpot 虚拟机使用该优化来减少非竞争锁定的开销</strong>。尽管某些 Java 应用程序在禁用偏向锁后可能会出现性能下降，但偏向锁的性能提高通常不像以前那么明显。</p><h3 id="04-Shenandoah-GC-转正"><a href="#04-Shenandoah-GC-转正" class="headerlink" title="04-Shenandoah GC 转正"></a>04-Shenandoah GC 转正</h3><p>Shenandoah 垃圾回收算法终于从实验特性转变为产品特性，这是一个从 JDK 12 引入的回收算法，该算法通过与正在运行的 Java 线程同时进行疏散工作来减少 GC 暂停时间。Shenandoah 的暂停时间与堆大小无关，无论堆大小是 200 MB 还是 200 GB，都具有相同的一致暂停时间。</p><p>怎么形容 Shenandoah GC 和 ZGC 的关系呢？异同点大概如下：</p><ul><li>相同点：性能几乎可以认为是相同的。</li><li>不同的：ZGC 是 Oracle JDK 的，根正苗红。而 Shenandoah 只存在于 OpenJDK 中，因此使用时需要注意你的 JDK 版本。</li></ul><p>打开方式：使用 <code>-XX:+UseShenandoahGC</code> 命令行参数打开。</p><h3 id="05-外部存储器访问-API"><a href="#05-外部存储器访问-API" class="headerlink" title="05-外部存储器访问 API"></a>05-外部存储器访问 API</h3><p><strong>JEP 383: Foreign-Memory Access API(Second Incubator) 外部存储器访问 API（孵化器版）</strong></p><p>目的是引入一个 API，以允许 Java 程序安全、有效地访问 Java 堆之外的外部存储器。如本机、持久和托管堆。</p><p>有许多 Java 程序是访问外部内存的，比如 Ignite 和 MapDB。该 API 将有助于避免与垃圾收集相关的成本以及与跨进程共享内存以及通过将文件映射到内存来序列化和反序列化内存内容相关的不可预测性。该 Java API 目前没有为访问外部存储内存提供令人满意的解决方案。但是在新的提议中，API 不应该破化 JVM 的安全性。</p><p>Foreign-Memory Access API 在 JDK 14 被作为 Incubator API 引入，在 JDK 15 处于 Second Incubator，提供了改进。</p><h3 id="06-移除-Solaris-和-SPARC-端口"><a href="#06-移除-Solaris-和-SPARC-端口" class="headerlink" title="06-移除 Solaris 和 SPARC 端口"></a>06-移除 Solaris 和 SPARC 端口</h3><p><strong>JEP 381: Remove the Solaris and SPARC Ports（移除 Solaris 和 SPARC 端口）</strong></p><p>删除对 Solaris/SPARC、Solaris/x64 和 Linux/SPARC 端口的源代码和构建支持，在 JDK 14 中被标记为废弃，在 JDK 15 版本正式移除。</p><p>许多正在开发的项目和功能（如 Valhalla、Loom 和 Panama）需要进行重大更改以适应 CPU 架构和操作系统特定代码。</p><p>近年来，Solaris 和 SPARC 都已被 Linux 操作系统和英特尔处理器取代。放弃对 Solaris 和 SPARC 端口的支持将使 OpenJDK 社区的贡献者能够加速开发新功能，从而推动平台向前发展。</p><h3 id="07-移除-the-Nashorn-JS-引擎"><a href="#07-移除-the-Nashorn-JS-引擎" class="headerlink" title="07-移除 the Nashorn JS 引擎"></a>07-移除 the Nashorn JS 引擎</h3><p><strong>JEP 372: Remove the Nashorn JavaScript Engine</strong></p><p>Nashorn 是在 JDK 提出的脚本执行引擎，该功能是 2014 年 3 月发布的 JDK 8 的新特性。在 JDK 11 就已经把它标记为废弃了，JDK 15 完全移除。</p><p>在 JDK 11 中取以代之的是 GraalVM。GraalVM 是一个运行时平台，它支持 Java 和其他基于 Java 字节码的语言，但也支持其他语言，如 JavaScript，Ruby，Python 或 LLVM。性能是 Nashorn 的 2 倍以上。</p><p>JDK 15 移除了 Nashorn JavaScript Engine 及 jjs 命令行工具。具体就是 jdk.scripting.nashorn 及 jdk.scripting.nashorn.shell 这两个模块被移除了。</p><p>补充：</p><p><img src="https://up-img.yonghong.tech/pic/2020/12/10-09-20-graalvm-e6kACA.png" alt="Graal VM"></p><p>Graal VM 在 HotSpot VM 基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin、C、C++、JavaScript、Ruby、Python、R等</p><h3 id="08-废弃-RMI-激活机制"><a href="#08-废弃-RMI-激活机制" class="headerlink" title="08-废弃 RMI 激活机制"></a>08-废弃 RMI 激活机制</h3><p><strong>JEP: Deprecate RMI Activation for Removal</strong></p><p>RMI Activation 被标记为 Deprecate，将会在未来的版本中删除。RMI 激活机制是 RMI 中一个过时的部分，自 Java 8 以来一直是可选的而非必选项。RMI 激活机制增加了持续的维护负担。RMI 的其他部分暂时不会被弃用。</p><p>在 RMI 系统中，我们使用延迟激活。延迟激活将激活对象推迟到客户第一次使用（即第一次方法调用）之前。</p><p>既然 RMI Activation 这么好用，为什么要废弃呢？</p><p>因为对于现代应用程序来说，分布式系统大部分都是基于 Web 的，Web 服务器已经解决了穿越防火墙，过滤请求，身份验证和安全性的问题，并且也提供了很多延迟加载的技术。</p><p>所以在现代应用程序中，RMI Activation 已经很少被使用到了。并且在各种开源代码库中，也基本上找不到 RMI Activation 的使用代码了。</p><p>为了减少 RMI Activation 的维护成本，在 JDK 8 中，RMI Activation 被置为可选的。现在在 JDK 15，终于可以废弃了。</p><h2 id="新特性（饭后甜点）"><a href="#新特性（饭后甜点）" class="headerlink" title="新特性（饭后甜点）"></a>新特性（饭后甜点）</h2><h3 id="01-添加项"><a href="#01-添加项" class="headerlink" title="01-添加项"></a>01-添加项</h3><ul><li>升级了 Unicode，支持 Unicode 13</li><li>给 CharSequence 新增了 isEmpty 方法</li><li>JDK 15 对 TreeMap 提供了 putIfAbsent、computeIfAbsent、computeIfPresent、compute、merge 方法提供了 overriding 实现</li><li>jcmd 的 GC.heap_dump 命令现在支持 gz 选项，以 dump 出 gzip 压缩版的 heap。压缩等级从 1（压缩快） 到 9（压缩慢），默认为1。</li><li>jdk.net.ExtendedSocketOptions 新增 SO_INCOMING_NAPI_ID 选项</li><li>新增 jdk.tls.client.SignatureSchemes 及 jdk.tls.server.SignatureSchemes 用于配置 TLS Signature Schemes</li><li>支持 certificate_authorities</li></ul><h3 id="02-移除项-amp-废弃项"><a href="#02-移除项-amp-废弃项" class="headerlink" title="02-移除项&amp;废弃项"></a>02-移除项&amp;废弃项</h3><ul><li>淘汰了 <code>-XX:UseAdaptiveGCBoundary</code></li><li>废弃了 ForceNUMA 选项</li><li>默认禁用了 Native SunEC Implementation</li></ul><h3 id="03-其他事项"><a href="#03-其他事项" class="headerlink" title="03-其他事项"></a>03-其他事项</h3><p>已知问题：</p><ul><li>HttpClient 现在没有覆盖在 SSLContext Default Parameters 中指定的 Protocols</li></ul><p>其他事项：</p><ul><li>当 DatagramPacket 没有设置 port 的时候，其 getPort 方法返回 0</li><li>优化了默认 G1 Heap Region Size 的计算</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;视频来源：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXZmNHkxQjd0dA==&quot;&gt;https://www.bilibili.com/video/BV1vf4y1B7tt&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;大背景&quot;&gt;&lt;a href=&quot;#大背景&quot; class=&quot;headerlink&quot; title=&quot;大背景&quot;&gt;&lt;/a&gt;大背景&lt;/h2&gt;&lt;h3 id=&quot;25-岁的-Java&quot;&gt;&lt;a href=&quot;#25-岁的-Java&quot; class=&quot;headerlink&quot; title=&quot;25 岁的 Java&quot;&gt;&lt;/a&gt;25 岁的 Java&lt;/h3&gt;&lt;h4 id=&quot;Java-的现状&quot;&gt;&lt;a href=&quot;#Java-的现状&quot; class=&quot;headerlink&quot; title=&quot;Java 的现状&quot;&gt;&lt;/a&gt;Java 的现状&lt;/h4&gt;&lt;p&gt;2020 年是 Java 诞生的第 25 个年头，Oracle 表示，目前 Java 仍然流行是流行的编程语言，广泛使用在企业中。目前全世界有超过 69% 的专职开发人员使用 Java，全世界有 510 亿台活动 Java 虚拟机（JVM）在部署中，目前 Java 主要被用于分析、数据管理、大数据、DevOps、移动、持续开发工具和聊天机器人等服务。&lt;/p&gt;
&lt;h4 id=&quot;历史版本的主要新特性&quot;&gt;&lt;a href=&quot;#历史版本的主要新特性&quot; class=&quot;headerlink&quot; title=&quot;历史版本的主要新特性&quot;&gt;&lt;/a&gt;历史版本的主要新特性&lt;/h4&gt;&lt;p&gt;在过去的这些年中，Java 在过去增强功能的推动下为用户提供了超过二十年的创新。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK 5：enum、泛型、自动装箱与拆箱、可变参数、增强循环等&lt;/li&gt;
&lt;li&gt;JDK 6：支持脚本语言、JDBC 4.0 API&lt;/li&gt;
&lt;li&gt;JDK 7：支持 try-with-resources、switch 语句块增加 String 支持、NIO 2.0 包&lt;/li&gt;
&lt;li&gt;JDK 8：lambda 表达式、Stream API、新的日期时间的 API、方法引用、构造器引用&lt;/li&gt;
&lt;li&gt;JDK 9：模块化系统、jshell&lt;/li&gt;
&lt;li&gt;JDK 10：局部变量的类型推断&lt;/li&gt;
&lt;li&gt;JDK 11：ZGC 的引入、Epsilon GC&lt;/li&gt;
&lt;li&gt;JDK 12：switch 表达式、Shenandoah GC、增强 G1&lt;/li&gt;
&lt;li&gt;JDK 13：switch 表达式引入 yield、文本块&lt;/li&gt;
&lt;li&gt;JDK 14：instanceof 模式识别、Records、弃用 Parallel Scavenge + Serial GC 组合、删除 CMS GC&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java" scheme="http://yonghong.tech/categories/Java/"/>
    
    
    <category term="JDK" scheme="http://yonghong.tech/tags/JDK/"/>
    
    <category term="Java" scheme="http://yonghong.tech/tags/Java/"/>
    
    <category term="15" scheme="http://yonghong.tech/tags/15/"/>
    
  </entry>
  
  <entry>
    <title>技术爱好者周刊 第10期 | 2020年12月07日</title>
    <link href="http://yonghong.tech/weekly-010/"/>
    <id>http://yonghong.tech/weekly-010/</id>
    <published>2020-12-07T02:24:00.000Z</published>
    <updated>2020-12-07T02:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>技术爱好者周刊，每周一发布，欢迎提<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dhbmd5b25naG9uZy95b25naG9uZy1tZS9pc3N1ZXM=">issue<i class="fa fa-external-link-alt"></i></span>贡献内容。</p></blockquote><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9uaW9jb2Rlci5jb20vMjAyMC8xMS8yOC9DbGlja0hvdXNlJUU5JTlCJTg2JUU3JUJFJUE0JUU2JTkwJUFEJUU1JUJCJUJBMS8=">ClickHouse集群搭建（一）<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9uaW9jb2Rlci5jb20vMjAyMC8xMS8yOS9DbGlja0hvdXNlJUU5JTlCJTg2JUU3JUJFJUE0JUU2JTkwJUFEJUU1JUJCJUJBMi8=">ClickHouse集群搭建（二）<i class="fa fa-external-link-alt"></i></span><br>ClickHouse 是俄罗斯的Yandex于2016年开源的列式存储数据库（DBMS），主要用于在线分析处理查询（OLAP），能够使用SQL查询实时生成分析数据报告。</li><li><span class="exturl" data-url="aHR0cDovL2dlbmVyYWx0aGluay5naXRodWIuaW8vMjAyMC8xMS8yMy9hYm91dC1SZWVudHJhbnRMb2NrLXByb2JsZW1zLw==">ReentrantLock 的这几个问题，你都知道吗？<i class="fa fa-external-link-alt"></i></span><br>之前分析 AQS 的时候，了解到 AQS 依赖于内部的两个 FIFO 队列来完成同步状态的管理，当线程获取锁失败的时候，会将当前线程以及等待状态等信息构造成 Node 对象并将其加入同步队列中，同时会阻塞当前线程。当释放锁的时候，会将首节点的 next 节点唤醒 (head 节点是虚拟节点)，使其再次尝试获取锁。</li><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMTIvMDMvc2VydmljZS1tZXNoLWluLW1laXR1YW4uaHRtbA==">复杂环境下落地Service Mesh的挑战与实践<i class="fa fa-external-link-alt"></i></span><br>在私有云集群环境下建设 Service Mesh ，往往需要对现有技术架构做较大范围的改造，同时会面临诸如兼容困难、规模化支撑技术挑战大、推广困境多等一系列复杂性问题。本文会系统性地讲解在美团在落地 Service Mesh 过程中，我们面临的一些挑战及实践经验，希望能对大家有所启发或者帮助。</li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTAxNDc5MTkwMjQ0MDk4MDYy">CDN工作原理及其在淘宝图片业务中的应用<i class="fa fa-external-link-alt"></i></span><br>淘宝的图片访问，有98%的流量都走了CDN缓存，只有2%会回源到源站，节省了大量的服务器资源。但是，如果在用户访问高峰期，图片内容大批量发生变化，大量用户的访问就会穿透cdn，对源站造成巨大的压力。今年双11，淘宝鹿班的主图价格表达升级项目，就面临了这种挑战，让我们看看是如何解决的吧。<span id="more"></span></li></ul><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMTIvMDMvY2lrbS0yMDIwLW5scC5odG1s">CIKM 2020 | 一文详解美团6篇精选论文<i class="fa fa-external-link-alt"></i></span><br>AI平台/搜索与NLP部/NLP中心/知识图谱组共有六篇论文（其中4篇长文，2篇短文）被国际会议CIKM2020接收，这些论文是知识图谱组在多模态知识图谱、MT-BERT、Graph Embedding和图谱可解释性等方向上的技术沉淀和应用。</li></ul><h2 id="近期会议"><a href="#近期会议" class="headerlink" title="近期会议"></a>近期会议</h2><h3 id="第十一届中国数据库技术大会（DTCC2020）"><a href="#第十一届中国数据库技术大会（DTCC2020）" class="headerlink" title="第十一届中国数据库技术大会（DTCC2020）"></a>第十一届中国数据库技术大会（DTCC2020）</h3><p>报名链接：<span class="exturl" data-url="aHR0cDovL2R0Y2MuaXQxNjguY29tLw==">http://dtcc.it168.com/<i class="fa fa-external-link-alt"></i></span></p><p>会议时间：2020年12月21日 ~ 1010年12月23日</p><p>2020年12月21日~12月23日，由 IT168 旗下 ITPUB 企业社区平台主办的第十一届中国数据库技术大会（DTCC2020），将在北京隆重召开。大会以“架构革新 高效可控”为主题，设置2大主会场，20+技术专场，将邀请超百位行业专家，重点围绕数据架构、AI与大数据、传统企业数据库实践和国产开源数据库等内容展开分享和探讨，为广大数据领域从业人士提供一场年度盛会和交流平台。</p><p>为了帮助更多企业落地数据项目实施方案，今年将继续开设多门深度培训课程，内容涵盖数据中台、去IOE实践、区块链技术、内核开发实践等。3天传统技术演讲+1天深度主题，将汇聚各行业精英、技术领袖、行业专家和数据英雄，带来超过100场主题演讲和超5场培训课程的头脑风暴，诚邀您的加入。</p><p>历经十年的积累与沉淀，如今的DTCC已然成为国内数据库领域的技术风向标，见证了整个行业的发展与演变。作为顶级的数据领域技术盛会，DTCC2020将继续秉承一贯的干货分享和实践指导原则，期待大家的热情参与！</p><h3 id="第十届PostgreSQL中国技术大会"><a href="#第十届PostgreSQL中国技术大会" class="headerlink" title="第十届PostgreSQL中国技术大会"></a>第十届PostgreSQL中国技术大会</h3><p>报名链接：<span class="exturl" data-url="aHR0cDovL3BnY29uZjIwMjAucG9zdGdyZXMuY24v">http://pgconf2020.postgres.cn/<i class="fa fa-external-link-alt"></i></span></p><p>会议时间：2021年1月15日 ~ 2021年1月16日</p><p>2021年1月15～1月16日，由 PostgreSQL 中文社区主办的第十届《PostgreSQL 中国技术大会》将在南京索菲特银河大酒店现场隆重举办。</p><p>PostgreSQL 作为功能最强的的开源关系型数据库之一，得到了越来越多企业的推广和运用，也越来越受到广大技术爱好者的欢迎和重视。</p><p>本次大会以“开源，自研，新机遇”为主题。除了设立一个主会场外，还设立了多个分会场。大会汇聚了来自互联网、电商、教育，金融等各行业领域的专家，这将是 PostgreSQL 发展史上的又一次交流盛会。</p><h2 id="其他周报"><a href="#其他周报" class="headerlink" title="其他周报"></a>其他周报</h2><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1YW55Zi93ZWVrbHkvYmxvYi9tYXN0ZXIvZG9jcy9pc3N1ZS0xMzYubWQ=">科技爱好者周刊（第 136 期）：利特伍德奇迹定律<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BvbGFyaXMxMTE5L2dvbGFuZ3dlZWtseS9ibG9iL21hc3Rlci9kb2NzL2lzc3VlLTA3Mi5tZA==">Go语言爱好者周刊：第 72 期<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3plbmFueS93ZWVrbHkvYmxvYi9tYXN0ZXIvc29mdHdhcmUvMjAyMC8xMTMwLm1k">2020.11.30 - FrontPage: The Good, The Bad, and The Ugly<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N3aWZ0T2xkRHJpdmVyL2lPUy1XZWVrbHkvYmxvYi9tYXN0ZXIvUmVwb3J0cy8yMDIwLyUyMzEzNy0yMDIwLjEyLjA3Lm1k">老司机 iOS 周报 #138 | 2020-12-07<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9yd2Vla2x5Lm9yZy8yMDIwLTQ4Lmh0bWw=">R Weekly 2020-48 Your first R package, magrittr, engineering Shiny<i class="fa fa-external-link-alt"></i></span></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;技术爱好者周刊，每周一发布，欢迎提&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL3dhbmd5b25naG9uZy95b25naG9uZy1tZS9pc3N1ZXM=&quot;&gt;issue&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;贡献内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;后端&quot;&gt;&lt;a href=&quot;#后端&quot; class=&quot;headerlink&quot; title=&quot;后端&quot;&gt;&lt;/a&gt;后端&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9uaW9jb2Rlci5jb20vMjAyMC8xMS8yOC9DbGlja0hvdXNlJUU5JTlCJTg2JUU3JUJFJUE0JUU2JTkwJUFEJUU1JUJCJUJBMS8=&quot;&gt;ClickHouse集群搭建（一）&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9uaW9jb2Rlci5jb20vMjAyMC8xMS8yOS9DbGlja0hvdXNlJUU5JTlCJTg2JUU3JUJFJUE0JUU2JTkwJUFEJUU1JUJCJUJBMi8=&quot;&gt;ClickHouse集群搭建（二）&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;ClickHouse 是俄罗斯的Yandex于2016年开源的列式存储数据库（DBMS），主要用于在线分析处理查询（OLAP），能够使用SQL查询实时生成分析数据报告。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2dlbmVyYWx0aGluay5naXRodWIuaW8vMjAyMC8xMS8yMy9hYm91dC1SZWVudHJhbnRMb2NrLXByb2JsZW1zLw==&quot;&gt;ReentrantLock 的这几个问题，你都知道吗？&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;之前分析 AQS 的时候，了解到 AQS 依赖于内部的两个 FIFO 队列来完成同步状态的管理，当线程获取锁失败的时候，会将当前线程以及等待状态等信息构造成 Node 对象并将其加入同步队列中，同时会阻塞当前线程。当释放锁的时候，会将首节点的 next 节点唤醒 (head 节点是虚拟节点)，使其再次尝试获取锁。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMTIvMDMvc2VydmljZS1tZXNoLWluLW1laXR1YW4uaHRtbA==&quot;&gt;复杂环境下落地Service Mesh的挑战与实践&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;在私有云集群环境下建设 Service Mesh ，往往需要对现有技术架构做较大范围的改造，同时会面临诸如兼容困难、规模化支撑技术挑战大、推广困境多等一系列复杂性问题。本文会系统性地讲解在美团在落地 Service Mesh 过程中，我们面临的一些挑战及实践经验，希望能对大家有所启发或者帮助。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTAxNDc5MTkwMjQ0MDk4MDYy&quot;&gt;CDN工作原理及其在淘宝图片业务中的应用&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;淘宝的图片访问，有98%的流量都走了CDN缓存，只有2%会回源到源站，节省了大量的服务器资源。但是，如果在用户访问高峰期，图片内容大批量发生变化，大量用户的访问就会穿透cdn，对源站造成巨大的压力。今年双11，淘宝鹿班的主图价格表达升级项目，就面临了这种挑战，让我们看看是如何解决的吧。</summary>
    
    
    
    <category term="技术爱好者周刊" scheme="http://yonghong.tech/categories/%E6%8A%80%E6%9C%AF%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A/"/>
    
    
    <category term="技术爱好者周刊" scheme="http://yonghong.tech/tags/%E6%8A%80%E6%9C%AF%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>欧陆词典每日一句-2020年11月</title>
    <link href="http://yonghong.tech/eudic-2020-11/"/>
    <id>http://yonghong.tech/eudic-2020-11/</id>
    <published>2020-11-30T12:00:00.000Z</published>
    <updated>2020-11-30T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>I have to make a difficult choice. Decide quickly. 我必须做一个艰难的选择。那就是迅速做出决定。</p></blockquote><hr><p>If I were you, I wouldn’t worry about it. 如果我是你，我不会为此而担忧。</p><p>They worked hard at whatever they did, but they had a sense of achievement. 无论做什么，他们都很努力，有一种成就感。</p><p>A company should find ways to innovate not just in products but also in functions, business models and processes. 一个公司要寻求的不仅仅是产品创新，还应寻求运营、商业模式和流程方面的创新。</p><span id="more"></span><p>I just trust that the principle of reciprocity is true, and I give what I want. 我相信互利互惠的原则，我想要得到就要付出。</p><p>Most successful people are unorthodox persons whose minds wander outside traditional ways of thinking. 大多数成功的人都并非遵循传统之人，他们的思维方式都游离在传统的思维方式之外。</p><p>Curriculums — from grammar school to college, should evolve to focus less on memorizing facts and more on creativity and complex communication. 从语法学校到大学的课程，都应该逐渐发展，更多地注重创新和复杂的交流，而不是把重点放在记忆事实上。</p><p>Gradually it became dark outside. The rain was still beating on the windows, and I could hear the wind in the trees. 外面的天渐渐黑了。雨点仍然拍打着窗户，还可以听到风在树枝间呼啸。</p><hr><p>Almost all companies recognize the importance of innovation today. 如今，几乎所有的公司都知道创新的重要性。</p><p>I wish you well. You have my best wishes. 我祝福你。向你致以最好的祝愿。</p><p>Too much happiness can be destructive. 乐极也会生悲。</p><p>If you can speak the language, it’s easier to get to know the country and its people. 如果会说当地语言，了解这个国家和人民就会更加容易。</p><p>Truly my favorite part is to see the kids jumping up and down and they just get so excited. 我最喜欢的就是看着孩子们兴奋地蹦蹦跳跳。</p><p>People are curious by nature. 人类天性好奇。</p><p>They believed in goodness, in community, and helping one another. 他们信仰美德，信仰团体，信仰互助。</p><hr><p>In my line of work, I receive a lot of emails. I also send a lot of emails. 在我的职业生涯中，我收到过不少电子邮件，也发出去不少。</p><p>Your joy for life, transmitted wherever you took your smile, and the sparkle in those unforgettable eyes. 你对生活的欣喜，通过你的微笑和你令人难忘的双眸中的闪光，传遍了你的所到之处。</p><p>Use your voice to speak out for what’s right. 用你的影响力去为正义发声。</p><p>All kinds of myths surround the lives of well-known people. 名人的生活总是被各种各样的荒诞故事所围绕。</p><p>Demand is rising rapidly, because of the world’s increasing population and expanding industry. 需求量正在激增，因为整个世界人口急剧增长，工业规模不断扩大。</p><p>If I could go back in history and live when I liked, I wouldn’t go back very far. 如果我能回到过去并生活在我喜欢的年代，我不会选很久以前。</p><p>You might imagine the job you will get when you finish school. 你可能会设想自己毕业后从事的工作。</p><hr><p>We often use slang expressions when we talk, because they are so vivid and colorful. 我们说话时会经常使用俚语，因为俚语很生动、很丰富多彩。</p><p>You need to recognize each step of progress you take towards achieving your goals. 你成功路上的每一点进步都值得自己的认可。</p><p>With a lot of hard work and a good education, anything is possible. 只要你愿意努力工作，努力接受教育，任何事情都是可能的。</p><p>Think of an email as a letter. Spelling, grammar and punctuation should not be overlooked. 把编辑电子邮件当成在写信，拼写、语法、标点都不应忽视。</p><p>The ability to work well with others and collaborate on projects is a sought-after ability in nearly every position. 对于任何职位，与他人保持良好的合作关系，可以进行有效的项目合作，这些对职场人来说都是倍受追捧的能力。</p><p>I like to collect bits and pieces from different parts of the world. 我喜欢在世界各地搜集点点滴滴的东西。</p><p>I have to make a difficult choice. Decide quickly. 我必须做一个艰难的选择。那就是迅速做出决定。</p><hr><p>A well-organized essay will group similar ideas together and put them in the proper order. 一篇条理清晰的文章会把相似的观点组织在一起，并按适当的顺序排列。</p><p>Wherever you go and for whatever reason, it’s important to be safe. 不论你去哪，因为什么原因，安全都很重要。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;I have to make a difficult choice. Decide quickly. 我必须做一个艰难的选择。那就是迅速做出决定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;If I were you, I wouldn’t worry about it. 如果我是你，我不会为此而担忧。&lt;/p&gt;
&lt;p&gt;They worked hard at whatever they did, but they had a sense of achievement. 无论做什么，他们都很努力，有一种成就感。&lt;/p&gt;
&lt;p&gt;A company should find ways to innovate not just in products but also in functions, business models and processes. 一个公司要寻求的不仅仅是产品创新，还应寻求运营、商业模式和流程方面的创新。&lt;/p&gt;</summary>
    
    
    
    <category term="学英语" scheme="http://yonghong.tech/categories/%E5%AD%A6%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="http://yonghong.tech/tags/%E8%8B%B1%E8%AF%AD/"/>
    
    <category term="学英语" scheme="http://yonghong.tech/tags/%E5%AD%A6%E8%8B%B1%E8%AF%AD/"/>
    
    <category term="欧陆词典" scheme="http://yonghong.tech/tags/%E6%AC%A7%E9%99%86%E8%AF%8D%E5%85%B8/"/>
    
    <category term="每日一句" scheme="http://yonghong.tech/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%8F%A5/"/>
    
  </entry>
  
</feed>
