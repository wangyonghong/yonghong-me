<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>永红的互联网手记</title>
  
  <subtitle>我相信好代码和好产品改变世界！</subtitle>
  <link href="http://yonghong.tech/atom.xml" rel="self"/>
  
  <link href="http://yonghong.tech/"/>
  <updated>2021-06-18T13:00:00.000Z</updated>
  <id>http://yonghong.tech/</id>
  
  <author>
    <name>王永红(Micheal Wang)</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 进阶 06 —— JVM 垃圾回收算法</title>
    <link href="http://yonghong.tech/java-advance/06-jvm-gc-algo/"/>
    <id>http://yonghong.tech/java-advance/06-jvm-gc-algo/</id>
    <published>2021-06-18T13:00:00.000Z</published>
    <updated>2021-06-18T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么会有-GC"><a href="#为什么会有-GC" class="headerlink" title="为什么会有 GC"></a>为什么会有 GC</h1><p>本质上是内存资源的有限性，因此需要大家共享使用，手工申请，手动释放。</p><p>垃圾收集，不是 Java 语言的伴生产物。早在 1960 年，第一门开始使用内存动态分配和垃圾收集技术的 Lisp 语言诞生。</p><p>关于垃圾收集有三个经典问题：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><span id="more"></span><p>垃圾收集机制是 Java 语言的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java 的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p><p>面试题：</p><ul><li>垃圾回收器，各自优缺点，CMS、G1</li><li>GC 算法有哪些，目前的 JDK 版本采用什么回收算法</li><li>GC 两种判定方法</li><li>分代回收</li><li>垃圾收集策略和算法</li><li>平时如何搭配使用垃圾回收器</li><li>什么情况触发垃圾回收</li><li>System.gc() runtime.gc()</li><li>Java  GC 机制，GC Roots 有哪些</li><li>CMS 回收停顿了几次，为什么？</li></ul><h1 id="什么是垃圾（Garbage）"><a href="#什么是垃圾（Garbage）" class="headerlink" title="什么是垃圾（Garbage）"></a>什么是垃圾（Garbage）</h1><p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。An object is considered garbage when it  can no longer be  reached from any pointer in the running program .</p><p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占用的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</p><h1 id="为什么需要垃圾回收"><a href="#为什么需要垃圾回收" class="headerlink" title="为什么需要垃圾回收"></a>为什么需要垃圾回收</h1><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停的生产而从来不打扫一样。</p><p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便 JVM 将整理出的内存分配给新的对象。</p><p>随着应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有 GC 就不能保证应用程序的正常进行。而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。</p><h1 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h1><p>在早期的 C/C++ 时代，垃圾回收基本上是手工进行的。开发人员可以使用 new 关键字进行内存申请，并使用 delete 关键字进行内存释放。比如以下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> cmBaseGroupBridge();</span><br><span class="line"><span class="comment">// 如果注册失败，使用 delete 关键字释放该对象所占用内存区域</span></span><br><span class="line"><span class="keyword">if</span> (pBridg-&gt;Register(kDestroy) != NO_ERROR) &#123;</span><br><span class="line">    <span class="keyword">delete</span> pBridge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄露，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。</p><p>有了垃圾回收机制后，上述代码块极有可能变成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> cmBaseGroupBridge();</span><br><span class="line">pBridg-&gt;Register(kDestroy);</span><br></pre></td></tr></table></figure><p>现在，除了 Java 以外，C#、Python、Ruby 等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式已经成为现代开发语言必备的标准。</p><h1 id="Java-垃圾回收机制"><a href="#Java-垃圾回收机制" class="headerlink" title="Java 垃圾回收机制"></a>Java 垃圾回收机制</h1><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低了内存泄漏和内存溢出的风险。</p><ul><li>没有垃圾回收器，java 也会和 cpp 一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li></ul><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专注地专心于业务开发。</p><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy90ZWNobm90ZXMvZ3VpZGVzL3ZtL2djdHVuaW5nL3RvYy5odG1s">Oracle 官网关于垃圾回收的介绍<i class="fa fa-external-link-alt"></i></span></p><p>担忧：</p><p>对于 Java 开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于”自动“，那么这将会是一场灾难，最严重的就会弱化 Java 开发人员在程序出现内存溢出时定位问题和解决问题的能力。</p><p>此时，了解 JVM 的自动内存分配和内存回收原理就显得非常重要，只有在真正了解 JVM 是如何管理内存后，我们才能够在遇见 OOM 时，快速地根据错误异常日志定位问题和解决问题。</p><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集册很难过为系统达到更高并发量的瓶颈时，我们就必须对这些”自动化“的技术是是必要的监控和调优。</p><p>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至全堆和方法区的回收。</p><hr><ul><li>其中，Java 堆是垃圾收集器的工作重点</li></ul><p>从次数上讲：</p><ul><li>频繁收集年轻代</li><li>较少收集老年代</li><li>基本不动方法区/永久代/元空间</li></ul><h1 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h1><h2 id="垃圾标记阶段"><a href="#垃圾标记阶段" class="headerlink" title="垃圾标记阶段"></a>垃圾标记阶段</h2><p>在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活的对象，哪些是已经死亡的对象</strong>。只有被标记为已经死亡的对象，GC 才会在执行垃圾回收时，释放掉其所占有的内存空间，因此这个过程我们称为<strong>垃圾标记阶段</strong>。</p><p>那么在 JVM 中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p><p>判断对象存活一般有两种方式：<strong>引用计数法</strong>和<strong>可达性分析算法</strong>。</p><h3 id="方式一：引用计数算法"><a href="#方式一：引用计数算法" class="headerlink" title="方式一：引用计数算法"></a>方式一：引用计数算法</h3><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的<strong>引用计数器属性用于记录对象被引用的情况</strong>。</p><p>对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，即表示对象 A 不可能再被使用，可进行回收。</p><p>优点：<strong>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性</strong>。</p><p>缺点：</p><ul><li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong>。</li><li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命的缺陷，导致在 Java 的垃圾回收器中没有使用这类算法。</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的 Python，它更是同时支持引用计数和垃圾收集机制。</p><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p><p>Java 并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</p><p>Python 如何解决循环引用？</p><ul><li>手动解除：很好理解，就是在合适的时机，解除引用关系。</li><li>使用弱引用 weakref，weakref 是 Python 提供的标准库，旨在解决循环引用。</li></ul><h3 id="方式二：可达性分析算法"><a href="#方式二：可达性分析算法" class="headerlink" title="方式二：可达性分析算法"></a>方式二：可达性分析算法</h3><p>可达性分析算法又叫做跟搜索算法，或者是追踪性垃圾收集。</p><p>相对于引用计数法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</p><p>相较于引用计数算法，这里的可达性分析就是 Java、C# 选择的。这种类型的垃圾收集器通常也叫做<strong>追踪性垃圾收集器（Tracing Garbage Collector）</strong>。</p><p>所谓 ”GC Roots“ 根集合就是一组必须活跃的引用。</p><p>基本思路：</p><ul><li>可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达</strong>。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为<strong>引用链（Reference Chain）</strong></li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象</li><li>在可达性分析算法中，只有能够被根对象集合直接或间接连接的对象才是存活对象</li></ul><p>这个算法目前较为常用。</p><h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><p>在 Java 语言中，GC Roots 包括以下几类元素：</p><ul><li>虚拟机栈中引用的对象<ul><li>比如，各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li>本地方法栈内 JNI（通常说的本地方法）引用的对象</li><li>方法区中类静态属性引用的对象<ul><li>比如：Java 类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象<ul><li>比如：字符串常量池里的引用</li></ul></li><li>所有被同步锁 synchronized 持有的对象</li><li>Java 虚拟机内部的引用<ul><li>基本数据类型对应的 Class 对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li></ul></li><li>反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</li></ul><p>除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象 临时性 地加入，共同构成完整 GC Roots 集合。比如，分代收集和局部回收（Partial GC）</p><ul><li>如果只针对 Java 堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入 GC Roots 集合中去考虑，才能保证可达性分析的准确性。</li></ul><p><strong>小技巧：</strong>由于 Root 采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root。</p><p><strong>注意：</strong>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能够保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p><p>这点也是导致 GC 时进行必须 ”Stop The World“ 的一个重要原因。</p><ul><li>即使是号称（几乎）不会发生停顿的 CMS 收集器中，<strong>枚举根节点时也是必须要停顿的</strong>。</li></ul><h4 id="对象的-finalization-机制"><a href="#对象的-finalization-机制" class="headerlink" title="对象的 finalization 机制"></a>对象的 finalization 机制</h4><p>Java 语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 finalize() 方法。</p><p> finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p><p>永远不要主动调用对象的 finalize() 方法，应该交给垃圾回收机制调用。理由包括以下 3 点：</p><ul><li><p>在 finalize() 时可能会导致对象复活。</p></li><li><p>finalize() 方法执行时间是没有保障的，它完全由 GC 线程决定，极端情况下，若不发生 GC，则  finalize() 方法将没有执行机会。</p></li><li><p>一个糟糕的  finalize() 会严重影响 GC 性能</p></li></ul><p>从功能上来说， finalize() 方法与 C++ 中的析构函数比较相似，但是 Java 采用的是基于垃圾回收器的自动内存管理机制，所以  finalize() 方法在本质上不同于 C++ 中的析构函数。</p><p>由于  finalize() 方法的存在，虚拟机中的对象一般处于三种可能的状态。</p><h4 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h4><p>如果所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是 ”非死不可“ 的，这时候它们暂时处于 ”缓刑“ 阶段。一个无法触及的对象有可能在某一个条件下 ”复活“，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p><ul><li>可触及的：从根节点开始，可以到达这个对象。</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在  finalize() 中复活。</li><li>不可触及的：对象的 finalize() 方法被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为  finalize() 方法只会被调用一次。</li></ul><p>以上 3 种状态中，是由于 finalize() 方法的存在进行的区分。只有在对象不可触及时才可以被回收。</p><h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><p>判定一个对象 objA 是否可回收，至少要经历两次标记过程：</p><ul><li>如果对象 objA 到 GC Roots 没有引用链，则进行第一次标记</li><li>进行筛选，判断此对象是否有必要执行  finalize() 方法<ul><li>如果对象 objA 没有重写 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，则虚拟机视为 ”没有必要执行“，objA 被判定为不可触及的。</li><li>如果对象 objA 重写了 finalize() 方法，且还未执行过，那么 objA 会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 finalize() 方法执行。</li><li>finalize() 方法是对象逃脱死亡的最后机会，稍后 GC 会对 F-Queue 队列中的对象进行第二次标记。如果 objA 在 finalize() 方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA 会被移出 ”即将回收“ 集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize() 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的 finalize() 方法只会被调用一次。</li></ul></li></ul><h4 id="MAT-与-JProfiler-的-GC-Roots-溯源"><a href="#MAT-与-JProfiler-的-GC-Roots-溯源" class="headerlink" title="MAT 与 JProfiler 的 GC Roots 溯源"></a>MAT 与 JProfiler 的 GC Roots 溯源</h4><p>MAT 是 Memory Analyzer 的简称，它是一款功能强大的 Java 堆内存分析器，用于查找内存泄露以及查看内存消耗情况。</p><p>MAT 是基于 Eclipse 开发的，是一款免费的性能分析工具。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWNsaXBzZS5vcmcvbWF0Lw==">https://www.eclipse.org/mat/<i class="fa fa-external-link-alt"></i></span></p><h4 id="获取-dump-文件"><a href="#获取-dump-文件" class="headerlink" title="获取 dump 文件"></a>获取 dump 文件</h4><ul><li>命令行使用 jmap<ul><li>jps</li><li>jmap -dump:format=b,live,file=test1.bin 14036</li></ul></li><li>使用 JVisualVM 导出<ul><li>捕获的 heap dump 文件是一个临时文件，关闭 JVisualVM 后自动删除，若要保留，需要将其另存为文件。</li><li>可以通过以下方式捕获 heap dump<ul><li>在左侧 Application 子窗口中右击相应的应用程序，选择 Heap Dump</li><li>在 Monitor 子标签页中点击 Heap Dump 按钮</li></ul></li><li>本地应用程序的 Heap Dumps 作为应用程序标签页的一个子标签页打开。同时，Heap Dump 在左侧 Application 栏中对应一个含有时间戳的节点，右击这个节点选择 Save As 即可将 Heap Dump 文件保存到本地。</li></ul></li></ul><h2 id="垃圾清除阶段"><a href="#垃圾清除阶段" class="headerlink" title="垃圾清除阶段"></a>垃圾清除阶段</h2><p>当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p><p>目前在 JVM 比较常见的三种垃圾收集算法是 标记-清除算法（Mark-Sweep）、复制算法（Copying）、标记-压缩算法（Mark-Compact）</p><h3 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被 J.McCarthy 等人在 1960 年提出并应用于 List 语言。</p><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为 Stop The World），然后进行两项工作，第一项是标记，第二项则是清除。</p><ul><li>标记：Collector 从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的 Header 中记录为可达对象。</li><li>清除：Collector 对对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收。</li></ul><p>缺点：</p><ul><li>效率不算高</li><li>在进行 GC 的时候，需要停止整个应用程序，导致用户体验差</li><li>这种方式清理出来的空闲内存空间是不连续的，产生内存碎片。需要维护一个空闲列表</li></ul><p>注意：何为清除？</p><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。</p><h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky 于1963 年发表了著名的论文，”使用双存储区的 Lisp 语言垃圾收集器 （A Lisp Garbage Collector Algorithm Using Serial Secondary Storage）“。M.L.Minsky 本人成功地引入到了 Lisp 语言的一个实现版本中。</p><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>将活着的内存空间分为两块，每次只是用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p><p>优点</p><ul><li><p>没有标记和清除过程，实现简单，运行高效</p></li><li><p>复制过去以后保证空间的连续性，不会出现”碎片问题“</p></li></ul><p>缺点</p><ul><li><p>此算法的缺点也是很明显的，就是需要两倍的内存空间。</p></li><li><p>对于 G1 这种分拆成为大量 region 的GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销也不小</p></li></ul><p>特别的：</p><ul><li>如果系统中的垃圾对象很多，复制短发需要复制的存活对象数量并不会太大，或者说非常低。</li></ul><p>应用场景：</p><p>在新生代，对应常规应用的垃圾回收，一次通常可以回收 70% - 99% 的内存空间，回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p><h3 id="标记-压缩算法（Mark-Compact）"><a href="#标记-压缩算法（Mark-Compact）" class="headerlink" title="标记-压缩算法（Mark-Compact）"></a>标记-压缩算法（Mark-Compact）</h3><h4 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h4><p>复制算法的高效性，是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p><p>标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以 JVM 的设计者需要在此基础上进行改进。标记-压缩（Mark-Compact）算法也由此诞生。</p><p>1970 年前后，G.L.Steele、C.J.Chene 和 D.S.Wise 等研究者发布标记-压缩算法。在许多现代的垃圾回收器中，人们都是用了标记-压缩算法或其改进版本。</p><h4 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h4><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象。</p><p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</p><p>之后清理边界外所有的空间。</p><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为 标记-清除-压缩（Mark-Sweep-Compact） 算法。</p><p>二者本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。</p><p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p><p><strong>指针碰撞（Bump the Pointer）</strong></p><p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞。</p><p><strong>优点</strong></p><p>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可。</p><p>消除了复制算法当中，内存减半的高额代价</p><p><strong>缺点</strong></p><p>从效率上来说，标记-整理算法要低于复制算法。</p><p>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。</p><p>移动的过程中，需要全程暂停用户应用程序。即：STW</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><table><thead><tr><th></th><th>Mark-Sweep</th><th>Mark-Compact</th><th>Copying</th></tr></thead><tbody><tr><td>速度</td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td>空间开销</td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的 2 倍大小（不堆积碎片）</td></tr><tr><td>移动对象</td><td>否</td><td>是</td><td>是</td></tr></tbody></table><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记阶段，比标记-清除算法多了一个整理内存的阶段。</p><p><strong>难道就没有一种最优算法吗？</strong></p><p>没有最好的算法，只有最合适的算法。</p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和缺点。分代收集算法应运而生。</p><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，<strong>不同生命周期的对象可以采取不同的收集方式，以便提高回收效率</strong>。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年龄代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在 Java 程序运行过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如 HTTP 请求中的 Session 对象、线程、Socket 连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String 对象，由于其不变性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p>目前几乎所有的 GC 都是采用分代收集（Generational Collecting）算法执行垃圾回收的。</p><p>在 HotSpot 中，基于分代的概念，GC 所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><ul><li>年轻代（Young Gen）<ul><li>年轻代的特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li><li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过 HotSpot 中的两个 Survivor 的设计得到缓解</li></ul></li><li>老年代（Tenured Gen）<ul><li>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</li><li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或是标记-清除与标记-整理的混合实现。<ul><li>Mark 阶段的开销与存活对象的数量成正比。</li><li>Sweep 阶段的开销与所管理区域大小成正比。</li><li>Compact 阶段的开销与存活对象的数据成正比。</li></ul></li></ul></li></ul><p><strong>以 HotSpot 中的 CMS 回收器为例，CMS 是基于 Mark-Sweep 实现的，对于对象的回收率很高。而对于碎片问题，CMS 采用基于 Mark-Compact 算法的 Serial Old 回收器作为补偿：当内存回收不佳（碎片导致的 Concurrent Mode Failure 时），将采用 Serial Old 执行 Full GC 以达到对老年代内存的整理。</strong></p><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。</p><h2 id="增量收集算法、分区算法"><a href="#增量收集算法、分区算法" class="headerlink" title="增量收集算法、分区算法"></a>增量收集算法、分区算法</h2><h3 id="增量收集算法（Incremental-Collecting）"><a href="#增量收集算法（Incremental-Collecting）" class="headerlink" title="增量收集算法（Incremental Collecting）"></a>增量收集算法（Incremental Collecting）</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种 STW 的状态。在 STW 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，<strong>将严重影响用户体验或者系统的稳定性</strong>。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><p>基本思想：如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，<strong>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</strong>。</p><p>总的来说，增量收集算法的基础仍然是传统的标记-清除和复制算法。<strong>增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段方式完成标记、清理或复制工作。</strong></p><p>缺点：使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为<strong>线程切换和上下文转换</strong>的消耗，会使得垃圾回收的总体成本上升，<strong>造成系统吞吐量的下降</strong>。</p><h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><p>一般来说，在相同条件下，堆空间越大，一次 GC 时所需要的时间就越长，有关 GC 产生的停顿也越长。为了更好的控制 GC 产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次 GC 所产生的停顿。</p><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间 region。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p><p>总结：注意，这些只是基本的算法思路，实际 GC 实现过程要复杂的多，目前还在发展中的前沿 GC 都是复合算法，并且并行和并发兼备。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;为什么会有-GC&quot;&gt;&lt;a href=&quot;#为什么会有-GC&quot; class=&quot;headerlink&quot; title=&quot;为什么会有 GC&quot;&gt;&lt;/a&gt;为什么会有 GC&lt;/h1&gt;&lt;p&gt;本质上是内存资源的有限性，因此需要大家共享使用，手工申请，手动释放。&lt;/p&gt;
&lt;p&gt;垃圾收集，不是 Java 语言的伴生产物。早在 1960 年，第一门开始使用内存动态分配和垃圾收集技术的 Lisp 语言诞生。&lt;/p&gt;
&lt;p&gt;关于垃圾收集有三个经典问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哪些内存需要回收？&lt;/li&gt;
&lt;li&gt;什么时候回收？&lt;/li&gt;
&lt;li&gt;如何回收？&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 05 —— JVM 相关工具</title>
    <link href="http://yonghong.tech/java-advance/05-jvm-args-tools/"/>
    <id>http://yonghong.tech/java-advance/05-jvm-args-tools/</id>
    <published>2021-06-11T13:00:00.000Z</published>
    <updated>2021-06-11T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM-命令行工具"><a href="#JVM-命令行工具" class="headerlink" title="JVM 命令行工具"></a>JVM 命令行工具</h2><table><thead><tr><th align="center">工具</th><th>简介</th></tr></thead><tbody><tr><td align="center">java</td><td>Java 应用的启动程序</td></tr><tr><td align="center">javac</td><td>JDK 内置的编译工具</td></tr><tr><td align="center">javap</td><td>反编译 class 文件的工具</td></tr><tr><td align="center">javadoc</td><td>根据 Java 代码和标准注释,自动生成相关的API说明文档</td></tr><tr><td align="center">javah</td><td>JNI 开发时, 根据 java 代码生成需要的 .h文件。</td></tr><tr><td align="center">extcheck</td><td>检查某个 jar 文件和运行时扩展 jar 有没有版本冲突，很少使用</td></tr><tr><td align="center">jdb</td><td>Java Debugger ; 可以调试本地和远端程序, 属于 JPDA 中的一个 demo 实现, 供其他调试器参考。开发时很使用</td></tr><tr><td align="center">jdeps</td><td>探测 class 或 jar 包需要的依赖</td></tr><tr><td align="center">jar</td><td>打包工具，可以将文件和目录打包成为 .jar 文件；.jar 文件本质上就是 zip 文件, 只是后缀不同。使用时按顺序对应好选项和参数即可。</td></tr><tr><td align="center">keytool</td><td>安全证书和密钥的管理工具; （支持生成、导入、导出等操作）</td></tr><tr><td align="center">jarsigner</td><td>JAR 文件签名和验证工具</td></tr><tr><td align="center">policytool</td><td>实际上这是一款图形界面工具, 管理本机的 Java 安全策略</td></tr><tr><td align="center">jps/jinfo</td><td>查看 java 进程</td></tr><tr><td align="center"><strong>jstat</strong></td><td>查看 JVM 内部 gc 相关信息</td></tr><tr><td align="center"><strong>jmap</strong></td><td>查看 heap 或类占用空间统计</td></tr><tr><td align="center"><strong>jstack</strong></td><td>查看线程信息</td></tr><tr><td align="center">jcmd</td><td>执行 JVM 相关分析命令（整合命令）</td></tr><tr><td align="center">jrunscript/jjs</td><td>执行 js 命令</td></tr></tbody></table><span id="more"></span><h3 id="常用命令实例"><a href="#常用命令实例" class="headerlink" title="常用命令实例"></a>常用命令实例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br><span class="line">jps -mlv </span><br><span class="line"><span class="meta">#</span><span class="bash"> -l 列出 Java 进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -m 列出传递给 main 方法的参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v 列出传递给 JVM 的参数</span></span><br><span class="line"></span><br><span class="line">jinfo pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参考：https://blog.csdn.net/maosijunzi/article/details/46049117</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> jstat   内存信息</span></span><br><span class="line">jstat -gc pid 1000 1000 # 每1000ms打印1次，打印1000次</span><br><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">4352.0 4352.0 4352.0  0.0   34944.0  10175.9   198132.0   152461.3  142132.0 134139.5 19624.0 16988.2     26    0.201   0      0.000    0.201</span><br><span class="line">4352.0 4352.0 4352.0  0.0   34944.0  10175.9   198132.0   152461.3  142132.0 134139.5 19624.0 16988.2     26    0.201   0      0.000    0.201</span><br><span class="line">4352.0 4352.0 4352.0  0.0   34944.0  10175.9   198132.0   152461.3  142132.0 134139.5 19624.0 16988.2     26    0.201   0      0.000    0.201</span><br><span class="line"><span class="meta">#</span><span class="bash"> S0C：第一个幸存区的大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> S1C：第二个幸存区的大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> S0U：第一个幸存区的使用大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> S1U：第二个幸存区的使用大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> EC：伊甸园区的大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> EU：伊甸园区的使用大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> OC：老年代大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> OU：老年代使用大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MC：方法区大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MU：方法区使用大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CCSC：压缩类空间大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CCSU：压缩类空间使用大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> YGC：年轻代垃圾回收次数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> YGCT：年轻代垃圾回收消耗时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> FGC：老年代垃圾回收次数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> FGCT：老年代垃圾回收消耗时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> GCT：垃圾回收消耗总时间</span></span><br><span class="line"></span><br><span class="line">jstat -gcutil pid 1000 1000</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">  0.00  79.37  72.86  78.50  94.45  86.65     27    0.207     0    0.000    0.207</span><br><span class="line">  0.00  79.37  72.86  78.50  94.45  86.65     27    0.207     0    0.000    0.207</span><br><span class="line">  0.00  79.37  72.86  78.50  94.45  86.65     27    0.207     0    0.000    0.207</span><br><span class="line"><span class="meta">#</span><span class="bash"> S0：幸存1区当前使用比例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> S1：幸存2区当前使用比例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> E：伊甸园区使用比例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> O：老年代使用比例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> M：元数据区使用比例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CCS：压缩使用比例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> YGC：年轻代垃圾回收次数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> FGC：老年代垃圾回收次数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> FGCT：老年代垃圾回收消耗时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> GCT：垃圾回收消耗总时间</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只看 Young 或 Old 区</span></span><br><span class="line">jstat -gcnew pid</span><br><span class="line">jstat -gcold pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> jmap    对象信息</span></span><br><span class="line">jmap -heap pid      # 堆内存</span><br><span class="line">jmap -histo pid     # 直方图</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> jstack  线程信息</span></span><br><span class="line">jstack -l pid       # 将线程相关的 locks 信息一起输 出，比如持有的锁，等待的锁。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> jcmd 综合了前面的几个命令</span></span><br><span class="line">jcmd pid VM.version</span><br><span class="line">jcmd pid VM.flags</span><br><span class="line">jcmd pid VM.command_line</span><br><span class="line">jcmd pid VM.system_properties</span><br><span class="line">jcmd pid Thread.print</span><br><span class="line">jcmd pid GC.class_histogram</span><br><span class="line">jcmd pid GC.heap_info</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当curl命令用</span></span><br><span class="line">jrunscript -e &quot;cat(&#x27;http://www.baidu.com&#x27;)&quot; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行js脚本片段</span></span><br><span class="line">jrunscript -e &quot;print(&#x27;hello,kk.jvm&#x27;+1)&quot; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行js文件</span> </span><br><span class="line">jrunscript -l js -f /XXX/XXX/test.js</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JVM-图形化工具"><a href="#JVM-图形化工具" class="headerlink" title="JVM 图形化工具"></a>JVM 图形化工具</h2><h3 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h3><p>JDK 自带工具</p><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-11-jconsole-mem-MJI7ul.png" alt="jconsole-内存"><br><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-12-jconsole-thread-b0RSWW.png" alt="jconsole-线程"><br><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-12-jconsole-guide-KgMCzE.png" alt="jconsole-概览"></p><h3 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h3><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-15-jvisualvm-guide-JU8yC7.png" alt="jvisualvm"></p><h3 id="VisualGC"><a href="#VisualGC" class="headerlink" title="VisualGC"></a>VisualGC</h3><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-16-VisualGC-poZ5Sm.png" alt="VisualGC"></p><h3 id="jmc"><a href="#jmc" class="headerlink" title="jmc"></a>jmc</h3><p>需要安装 Oracle JDK。</p><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-16-jmc-yNni2V.png" alt="jmc"><br><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-16-jmc-1-5ultLq.png" alt="jmc-1"><br><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-16-jmc-2-gKxxpd.png" alt="jmc-2"><br><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-16-jmc-3-GleUio.png" alt="jmc-3"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;JVM-命令行工具&quot;&gt;&lt;a href=&quot;#JVM-命令行工具&quot; class=&quot;headerlink&quot; title=&quot;JVM 命令行工具&quot;&gt;&lt;/a&gt;JVM 命令行工具&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;工具&lt;/th&gt;
&lt;th&gt;简介&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;java&lt;/td&gt;
&lt;td&gt;Java 应用的启动程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;javac&lt;/td&gt;
&lt;td&gt;JDK 内置的编译工具&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;javap&lt;/td&gt;
&lt;td&gt;反编译 class 文件的工具&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;javadoc&lt;/td&gt;
&lt;td&gt;根据 Java 代码和标准注释,自动生成相关的API说明文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;javah&lt;/td&gt;
&lt;td&gt;JNI 开发时, 根据 java 代码生成需要的 .h文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;extcheck&lt;/td&gt;
&lt;td&gt;检查某个 jar 文件和运行时扩展 jar 有没有版本冲突，很少使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jdb&lt;/td&gt;
&lt;td&gt;Java Debugger ; 可以调试本地和远端程序, 属于 JPDA 中的一个 demo 实现, 供其他调试器参考。开发时很使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jdeps&lt;/td&gt;
&lt;td&gt;探测 class 或 jar 包需要的依赖&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jar&lt;/td&gt;
&lt;td&gt;打包工具，可以将文件和目录打包成为 .jar 文件；.jar 文件本质上就是 zip 文件, 只是后缀不同。使用时按顺序对应好选项和参数即可。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;keytool&lt;/td&gt;
&lt;td&gt;安全证书和密钥的管理工具; （支持生成、导入、导出等操作）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jarsigner&lt;/td&gt;
&lt;td&gt;JAR 文件签名和验证工具&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;policytool&lt;/td&gt;
&lt;td&gt;实际上这是一款图形界面工具, 管理本机的 Java 安全策略&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jps/jinfo&lt;/td&gt;
&lt;td&gt;查看 java 进程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;jstat&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;查看 JVM 内部 gc 相关信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;jmap&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;查看 heap 或类占用空间统计&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;jstack&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;查看线程信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jcmd&lt;/td&gt;
&lt;td&gt;执行 JVM 相关分析命令（整合命令）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jrunscript/jjs&lt;/td&gt;
&lt;td&gt;执行 js 命令&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记（一）</title>
    <link href="http://yonghong.tech/reading-notes/001/"/>
    <id>http://yonghong.tech/reading-notes/001/</id>
    <published>2021-05-31T13:00:00.000Z</published>
    <updated>2021-05-31T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="《秒赞》林桂枝"><a href="#《秒赞》林桂枝" class="headerlink" title="《秒赞》林桂枝"></a>《秒赞》林桂枝</h2><p>1.你的样子里，有你走过的路，读过的书，看过的风景。</p><p>2.想当垃圾吃垃圾，想当辣椒吃辣椒，想当什么自己要想好吃什么。</p><ul><li>创建“好东西”文件夹，在里面放好的设计与照片、出色的演讲、有见地的文章、有趣的事物。</li><li>准备一个“好东西”本子，随时记录有趣的对话和文字，补充新词汇，不断丰富自己的储备。</li><li>将自己认为“有感觉”的词汇记下来，接着将这些词汇分给不同的人和不同的事物，想想这些词该给谁，与什么东西结合最有意思。</li><li>读完一本书，写个简短的读书心得；看完一部电影，记录自己的感受。有时间多写，忙的话写几行字也可以。</li><li>你记录的点点滴滴将会成为你个人的宝贵资产，你的缪斯女神，更是让你工作顺利、表现优秀的利器。</li></ul><p>3.人能想象到的一切都是真实的。——毕加索</p><span id="more"></span><hr><h2 id="《财务自由之路-I》博多·舍费尔"><a href="#《财务自由之路-I》博多·舍费尔" class="headerlink" title="《财务自由之路 I》博多·舍费尔"></a>《财务自由之路 I》博多·舍费尔</h2><p>1.我将生活简化为5个领域：健康、财务、关系、情感和人生意义。5个领域都同等重要。</p><p>2.为什么人们想在短期内变得富有？因为他们想获得足够的能为他们服务的金钱。因为他们想拥有一台赚钱机器，而非穷其一生当一台赚钱机器。因为他们想拥有足够的资金，以过上一种收支平衡的生活。</p><p>3.你的事业建立在你最大的爱好之上。用你的爱好来赚钱。花点时间分析一下，你真正感兴趣的是什么、你的才能在哪方面，之后你才有可能从事一份自己既感兴趣又能赚钱的工作。</p><p>4.责任这个单词在英语中叫作“responsibility”，在这个单词中隐藏着另外两个单词“response”（回应）和“ability”（技巧）。因此，责任这一词用英语来解释就是：有技巧地进行回应。以争吵应对争执，以冲突应对挑衅，绝非最佳的问题解决方式。</p><p>5.如果提的问题是“谁来负责任”，那我们就是在寻找借口。当我们说“你负有责任”时，将事情引向积极方向的机会就消失了。而且，这个关于责任的问题还会将我们一直引向过去。正确的提问应该是：“在当时谁应该对此负责？”但你现在不能拓宽你当时的可控领域，所以需要将精力运用在当下。我们提出的问题也应该以当下为中心：我们现在能做些什么？</p><p>6.日记本是空白的书籍，是你可以自己写作的书籍，专属于你个人。每个人都应该每天写自己的成功日记，记录下当天所有的成功事件：你获得的每一次夸奖和每一次认可，无论是你遵守纪律，完成一项任务，还是你使某人快乐。…… 随着时间的推移，你还需要一本思想日记本（记录你的所有创意）、一本关系日记本（记录所有使你快乐的关系）、一本知识日记本（记录你从自己犯过的错误中学到的所有东西，使你以后不会再重蹈覆辙），以及其他内容的日记本……</p><p>7.去为你的劣势找到解决方案，去为你的优势找一个教练吧！</p><p>8.你在未来5年当中可以休息一整年。在一整年的时间里，你可以做想做的任何事，并有能力支付这一年的所有账单。你可以去旅行，做使你快乐但平时又没有足够时间来做的事情。</p><p>9.一致性不是绝对的美德。如果我今天的观点与昨天不同，是不是就因为改变自身方向而没有一致性了呢？我的确与自己的过去不相一致了，但于真理而言，我是保持一致了……一致性在于按照认知去追随真理。</p><p>10.借口是我们讲给自己听的谎言。我们应该自己对自己越来越诚实，承担越来越多的责任。</p><p>11.全世界最富有的投资者沃伦·巴菲特说过：“毕竟，只有当潮水退去时，你才知道谁在裸泳。”</p><p>12.恐惧永远不应该左右你的决定。因为世界上不存在失败。是的，你没有看错：世界上不存在失败。美国脱口秀大师奥普拉·温弗瑞曾经说过：“我不相信失败。因为如果你享受了过程中的乐趣，那这就不是失败。”</p><p>13.“如果你不经常犯错，表明你冒的风险不够，没有付出最大的努力。”</p><hr><h2 id="《财务自由之路-II》博多·舍费尔"><a href="#《财务自由之路-II》博多·舍费尔" class="headerlink" title="《财务自由之路 II》博多·舍费尔"></a>《财务自由之路 II》博多·舍费尔</h2><p>1.正如爱因斯坦（Einstein）所言，我相信“每个孩子都可能是天才”。我们中的每个人，您和我至少在某方面有着特殊的天赋，而我们应该把这些天赋发挥到极致。</p><p>2.对于大多数人来说，薪水其实是给自己的赔偿费。</p><p>3.当您成功时，生活的大门为您敞开。虽然在通向胜利的道路上，您将会常常看到地狱，然而生活就是如此。但是，如果您坚持梦想，就不会被打倒。您将得到想得到的一切，还有很多很多其他的东西。<br>——弗莱明思（J.Flemmings）</p><p>4.一幢房子是一种负债，而非投资。并且，他希望我首先进行投资。他的原则是：“当您攒够一定数量的资金之后，再购置房产。而且，房子的价值不应超出年净收入的4倍，并且您每月分期付款不应超过月收入的25%。”</p><p>5.许多人仅仅从经济角度来考虑他们的主要事业。他们遵循这样的信条：“什么能赚钱，什么就是我的主要事业。”依我看，这是个完全错误的开端。</p><hr><h2 id="《权力》杰弗瑞·菲佛"><a href="#《权力》杰弗瑞·菲佛" class="headerlink" title="《权力》杰弗瑞·菲佛"></a>《权力》杰弗瑞·菲佛</h2><p>1.处在一个权力小、地位低的职位上可能会危害你的健康，相反，拥有权力及相应的控制权则会延长你的寿命。</p><p>2.你要克服自己这个障碍，克服对自我形象的过分关注，或者是特别在意别人对你的看法。无论如何，其他人不会特别关心或惦记你，他们关注的主要是他们自己。如果你不去尝试获得影响力，你也许能够维护良好的形象，但却无法登上权力的顶峰。</p><p>3.雇员的薪酬与他们的年龄和在组织中任期长短的关系，强于薪酬与工作绩效的关系。</p><p>4.掌权者自我感觉良好，最好的方法之一就是恭维他们。</p><p>5.为你的成功负责的人，是你的上司，是有权力提升你或者阻止你在组织中晋升的人。而且不管你的位置在哪里，总会有人在你上面。所以你的工作就是，确保那些有影响力的人有强烈的愿望让你获得成功。这可能需要你做好工作，但也可能需要确保掌权者知道你的工作做得很好，确保他们记得你，对你的评价很高，因为你能让他们自我感觉良好。业绩和职场政治技巧结合在一起，才能帮助你获得晋升。只靠业绩本身是不够的，在某些情况下，业绩甚至可能是无关痛痒的。</p><p>6.一些人晋升到很高的位置并成就了惊人的事业，他们与其他人的不同之处有两点：意愿和技能。意愿是使人愿意承担巨大挑战的驱动力，技能则是把雄心转换为成就的能力。意愿体现在个人素质中，就是雄心、精力和专注。而有助于获得权力的4项技能，则分别是自知之明和反省心态、散发自信的信心和能力、理解他人并懂得换位思考以及化解冲突的能力。在对以上每个特质进行说明之后，我将讨论另一个特质：智力。智力和权力有些关系，但我认为它被严重高估了。</p><p>7.如果你对你的工作值多少回报没有自信，对你想要的东西也不自信，你就不愿意要求或者推动别人，因此，相较于那些比你活跃的人而言，你获得的金钱或影响力就比较少。</p><p>8.引人注意可以帮助你获得你需要的位置和权力。你应该为你想要的东西提出请求，并且在为自己构建权力之路时，不要太在乎别人怎么看你。但是，要获得和行使权力，就需要资源来奖励你的朋友和惩罚你的敌人，需要信息和门路来促进你在组织中的升迁。</p><p>9.事实上人们常犯的一个严重错误是，他们以为在目前的职位上无法建立权力基础和掌握资源，以为需要在更高的职位上才能这样做。其实，如果你把权力基础打好，那么攀升到更高的职位就会变得更简单容易一些，而且你在任何时候都可以这样做，永远都不会太早或太迟。</p><p>10.领导的实质就是：让拥有不同能力和视角的人或部门协作，共同完成一项任务或达成一桩交易。</p><p>11.领导力的秘诀就是要扮演角色，要装模作样，要在这门舞台艺术上富于技巧。</p><p>12.与表达悲伤、内疚或自责的人相比，表达愤怒的人通常被视为更加强大。</p><p>13.领导力的秘诀就是要扮演角色，要装模作样，要在这门舞台艺术上富于技巧。</p><p>14.我们选择了我们行事和说话的方式，这些决定对于获取和保持权力而言非常重要。</p><p>15.“权力之中有20%是被赋予的，有80%是自己获取的。”</p><p>16.一旦人们对某个人形成了印象，他们就不会承认任何与他们最初想法不一致的信息。</p><p>17.行为动力机制倾向于巩固人们的初步印象和声望，并倾向于让这些印象成真，即使它们一开始并不是真的。</p><p>18.这里的建议不是让你在任何一个单一的地方留下良好的印象，而是建议你找到一个可以让你树立辉煌声望的环境，也就是建议你不断尝试不同的环境，直到你成功地发现了这样一个环境为止。</p><p>19.由于人们来自不同的背景，面临的激励机制不同，获得的信息不同，所以他们所看到的世界也各不相同。因此在组织中，分歧是不可避免的。令人遗憾的是，许多人都会尝试避免冲突，他们认为分歧令人不快，因此他们避免让不同的意见浮出水面，也避免与对手进行艰难的交谈。</p><p>20.如果你处在一个权力相当大的位置上，而你觉得自己变得越来越疲倦时，那你还不如离开这个位置。</p><p>21.人们包括公司都容易落入能力陷阱。他们曾以某种方式做某些事，并获得了成功。</p><p>22.有些人以为自己不喜欢或者不可能喜欢玩权力游戏。但他们根本就没有尝试过，又如何知道自己会不喜欢呢？</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;《秒赞》林桂枝&quot;&gt;&lt;a href=&quot;#《秒赞》林桂枝&quot; class=&quot;headerlink&quot; title=&quot;《秒赞》林桂枝&quot;&gt;&lt;/a&gt;《秒赞》林桂枝&lt;/h2&gt;&lt;p&gt;1.你的样子里，有你走过的路，读过的书，看过的风景。&lt;/p&gt;
&lt;p&gt;2.想当垃圾吃垃圾，想当辣椒吃辣椒，想当什么自己要想好吃什么。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建“好东西”文件夹，在里面放好的设计与照片、出色的演讲、有见地的文章、有趣的事物。&lt;/li&gt;
&lt;li&gt;准备一个“好东西”本子，随时记录有趣的对话和文字，补充新词汇，不断丰富自己的储备。&lt;/li&gt;
&lt;li&gt;将自己认为“有感觉”的词汇记下来，接着将这些词汇分给不同的人和不同的事物，想想这些词该给谁，与什么东西结合最有意思。&lt;/li&gt;
&lt;li&gt;读完一本书，写个简短的读书心得；看完一部电影，记录自己的感受。有时间多写，忙的话写几行字也可以。&lt;/li&gt;
&lt;li&gt;你记录的点点滴滴将会成为你个人的宝贵资产，你的缪斯女神，更是让你工作顺利、表现优秀的利器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.人能想象到的一切都是真实的。——毕加索&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://yonghong.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://yonghong.tech/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 04 —— JVM 内存模型：堆和栈是什么？</title>
    <link href="http://yonghong.tech/java-advance/04-jvm-mem/"/>
    <id>http://yonghong.tech/java-advance/04-jvm-mem/</id>
    <published>2021-05-16T13:00:00.000Z</published>
    <updated>2021-05-16T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM-运行时数据区概述"><a href="#JVM-运行时数据区概述" class="headerlink" title="JVM 运行时数据区概述"></a>JVM 运行时数据区概述</h2><p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。结合 JVM 虚拟机规范，来讨论一下经典的 JVM 内存布局。</p><p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。而另外一些则是与线程一一对应的，这些与线对应的数据区域会随着线程开始和结束而创建和销毁。</p><span id="more"></span><h3 id="JVM-整体架构"><a href="#JVM-整体架构" class="headerlink" title="JVM 整体架构"></a>JVM 整体架构</h3><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-19-47-VusNfO-S1kg66.png" alt="JVM 整体架构 - 英文"></p><hr><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-19-46-8oddUR-oMwPkk.png" alt="JVM 整体架构 - 中文"></p><h3 id="JVM-系统线程"><a href="#JVM-系统线程" class="headerlink" title="JVM 系统线程"></a>JVM 系统线程</h3><p>线程是一个程序里的运行单元。JVM 允许一个应用有多个线程并行的执行</p><p>在 HotSpot 虚拟机里，每个线程都与操作系统的本地线程直接映射。当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java 线程执行终止后，本地线程也会回收</p><p>操作系统负责所有的线程的安排调度到任何一个可用的 CPU 上。一旦本地线程初始化成功，它就会调用 Java 线程中的人run() 方法</p><p>如果你使用 jconsole 或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用 public static void main(String[] args) 的 main 线程以及所有这个 main 线程自己创建的线程。</p><p>这些主要的后台系统线程在 HotSpot 虚拟机里主要是以下几个</p><ul><li>虚拟机线程：这种线程的操作是需要 JVM 达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要 JVM 达到安全点，这样堆才不会变化。这种线程的执行类型包括“stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</li><li>GC 线程：这种线程对在 JVM 里不同种类的垃圾收集行为提供了支持</li><li>编译线程：这种线程在运行时会将字节码编译成本地代码</li><li>信号调度线程：这种线程接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理</li></ul><h2 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-39-01-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-OjY1mD.png" alt="JVM内存结构"></p><ul><li>每个线程只能访问自己的线程栈。</li><li>每个线程都不能访问（看不见）其他线程的局部变量。</li><li>所有原生类型的局部变量都存储在线程栈中，因此对其他线程是不可见的。</li><li>线程可以将一个原生变量值的副本传给另一个线程，但不能共享原生局部变量本身。</li><li>堆内存中包含了 Java 代码中创建的所有对象，不管是哪个线程创建的。其中也涵盖了包装类型（例如，Byte，Integer，Long等）。</li><li>不管是创建一个对象并将其值赋值给局部变量，还是赋值给另一个对象的成员变量，创建的对象都会被保存到堆内存中。</li></ul><hr><ul><li>如果是原生数据类型的局部变量，那么它的内容就全部保留在线程栈上。 </li><li>如果是对象引用，则栈中的局部变量槽位中保存着对象的引用地址，而实际的对象内容保存在堆中。</li><li>对象的成员变量与对象本身一起存储在堆上，不管成员变量的类型是原生数据类型，还是对象引用。</li><li>类的静态变量则和类定义一样都保存在堆中。</li></ul><hr><ul><li>总结一下：方法中使用的原生数据类型和对象引用地址在栈上存储；对象、对象成员与类定义、静态变量在堆上。</li><li>堆内存又称为“共享堆”，堆中的所有对象，可以被所有线程访问，只要他们能拿到对象的引用地址。</li><li>如果一个线程可以访问某个对象时，也就可以访问该对象的成员变量。</li><li>如果两个线程同时调用某个对象的同一方法，则它们都可以访问到这个对象的成员变量，但每个线程的局部变量副本是独立的。</li></ul><h2 id="JVM-内存整体结构"><a href="#JVM-内存整体结构" class="headerlink" title="JVM 内存整体结构"></a>JVM 内存整体结构</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-41-01-JVM%E5%86%85%E5%AD%98%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84-eSeqP8.png" alt="JVM内存整体结构"></p><ul><li>每启动一个线程，JVM就会在栈空间栈分配对应的线程栈，比如 1MB 空间（-Xss1m） </li><li>线程栈也叫做 Java 方法栈。如果使用了 JNI 方法，则会分配一个单独的本地方法栈（Native Stack） </li><li>线程执行过程中，一般会有多个方法组成调用栈（Stack Trace），比如 A 调用 B，B 调用 C 。每执行到一个方法，就会创建对应的栈帧（Frame）。</li></ul><h2 id="JVM-栈内存机构"><a href="#JVM-栈内存机构" class="headerlink" title="JVM 栈内存机构"></a>JVM 栈内存机构</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-44-01-JVM%E6%A0%88%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-Z8QlQS.png" alt="JVM栈内存结构"></p><ul><li>栈帧是一个逻辑上的概念，具体的大小在一个方法编写完成后基本上就能确定。 </li><li>比如返回值，需要有一个空间存放吧，每个局部变量都需要对应的地址空间，此外还有给指令使用的操作数栈，以及 Class 指针（标识这个栈帧对应的是哪个类的方法，指向非堆里面的 Class 对象）。</li></ul><h2 id="JVM-堆内存结构"><a href="#JVM-堆内存结构" class="headerlink" title="JVM 堆内存结构"></a>JVM 堆内存结构</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-45-01-JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-0TRoeN.png" alt="JVM堆内存结构"></p><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-46-01-jconsole%E5%86%85%E5%AD%98-KNrKkU.png" alt="jconsole内存"></p><ul><li>堆内存是所有线程共用的内存空间，JVM 将 Heap 内存分为年轻代（Young generation）和老年代（Old generation，也叫 Tenured）两部分。</li><li>年轻代还划分为3个内存池，伊甸园区（Eden space）和存活区（Survivor space），在大部分GC算法中有两个存活区（S0，S1），在我们可以观察到的任何时刻，S0和S1总有一个是空的，但一般很小，也浪费不了多少空间。</li><li>Non-Heap本质上还是Heap，只是一般不归GC管理，里面划分为3个内存区池。</li><li>Metaspace 以前叫持久代（永久代，Permanent generation），Java 换了个名字叫 Metaspace</li><li>CCS Compressed Class Space，存放 class 信息的，和 Metaspace 有交叉</li><li>Code Cache，存放 JIT 编译器编译后的本地机器代码。</li></ul><h2 id="CPU-与内存行为"><a href="#CPU-与内存行为" class="headerlink" title="CPU 与内存行为"></a>CPU 与内存行为</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-47-01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84-3aWMrH.png" alt="计算机硬件架构"></p><ul><li>CPU 乱序执行</li><li>volatile 关键字</li><li>原子性操作</li><li>内存屏障</li></ul><h2 id="Java对象模型"><a href="#Java对象模型" class="headerlink" title="Java对象模型"></a>Java对象模型</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-47-01-Java%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-K1uNvD.png" alt="Java对象模型"></p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-47-01-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-G12dzM.jpg" alt="Java内存模型"></p><p>JMM 规范对应的是 JSR-133 Java Memory Model and Thread Specification 《Java 语言规范》 $17.4 Memory Model 章节</p><p>JMM 规范明确定义了不同的线程之间通过哪些方式，在什么时候可以看见其他线程保存到共享变量中的值；以及在必要时，如何对共享变量的访问进行同步。这样的好处是屏蔽各种硬件平台的操作系统之间的内存访问差异，实现了Java并发程序真正的跨平台。</p><ul><li>所有的对象（包括内部的实例成员变量），static 变量，以及数组，都必须存放到堆内存中。</li><li>局部变量，方法的形参/入参，异常处理语句的入参不允许在线程之间共享，所以不受内存模型的影响。</li><li>多个线程同时对一个变量访问时【读取/写入】，这时候只要有某个线程执行的是写操作，那么这种现象称之为“冲突”。</li><li>可以被其他线程影响或感知的操作，称为线程间的交互行为，可分为：读取、写入、同步操作、外部操作等等。其中同步操作包括：对 volatile 变量的读写，对管程（monitor）的锁定与解锁，线程的起始操作与结尾操作，线程启动和结束等等。外部操作则是指对线程执行环境之外的操作，比如停止其他线程等等。</li><li>JMM 规范的是线程间的交互操作，而不管线程内部对局部变量进行的操作。</li></ul><hr><h2 id="JVM-启动参数"><a href="#JVM-启动参数" class="headerlink" title="JVM 启动参数"></a>JVM 启动参数</h2><ul><li>以 - 开头为标准参数，所有的 JVM 都要实现这些参数，并且向后兼容。例，<code>-server</code></li><li>-D 设置系统属性。例，<code>-Dfile.encoding=UTF-8</code></li><li>以 -X 开头为非标准参数，基本都是传给 JVM 的，默认 JVM 实现这些参数的功能，但是并不保证所有 JVM 实现都满足，且不保证向后兼容。可以使用 <code>java -X</code> 命令来查看当前 JVM 支持的非标准参数。例，<code>-Xmx8g</code></li><li>以 -XX: 开头为非稳定参数，专门用于控制 JVM 的行为，跟具体的 JVM 实现有关，随时可能会在下个版本取消。<ul><li>-XX: +-Flags 形式，+-是对布尔值进行开关。例，<code>-XX:+UseG1GC</code></li><li>-XX: key=value 形式，指定某个选项的值。例，<code>-XX:MaxPermSize=256m</code></li></ul></li></ul><p>1.系统属性参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-Dfile.encoding=UTF-<span class="number">8</span></span><br><span class="line">-Duser.timezone=GMT+08</span><br><span class="line">-Dmaven.test.skip=<span class="keyword">true</span></span><br><span class="line">-Dio.netty.eventLoopThreads=<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以这样</span></span><br><span class="line">System.setProperty(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;A100&quot;</span>);</span><br><span class="line">String a = System.getProperty(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure><p>2.运行模式参数</p><ul><li>-server: 设置 JVM 使用 server 模式，特点是启动速度比较慢，但运行时性能和内存管理效率很高，适用于生产环境。在具有 64 位能力的 JDK 环境下将默认启用该模式，而忽略 -client 参数。</li><li>-client: JDK1.7 之前在32位的 x86 机器上的默认值是 -client 选项。设置 JVM 使用 client 模式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或者 PC 应用开发和调试。此外，我们知道 JVM 加载字节码后，可以解释执行，也可以编译成本地代码再执行，所以可以配置 JVM 对字节码的处理模式。</li><li>-Xint: 在解释模式(interpreted mode)下运行，-Xint 标记会强制 JVM 解释执行所有的字节码，这当然会降低运行速度，通常低10倍或更多。</li><li>-Xcomp: -Xcomp 参数与 -Xint 正好相反，JVM 在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化。【注意预热】</li><li>-Xmixed: -Xmixed 是混合模式，将解释模式和编译模式进行混合使用，有 JVM 自己决定，这是 JVM 的默认模式，也是推荐模式。 我们使用 java -version 可以看到 mixed mode 等信息。</li></ul><p>3.堆内存设置参数</p><ul><li>-Xmx, 指定最大堆内存。 如 -Xmx4g. 这只是限制了 Heap 部分的最大值为4g。这个内存不包括栈内存，也不包括堆外使用的内存。</li><li>-Xms, 指定堆内存空间的初始大小。 如 -Xms4g。 而且指定的内存大小，并不是操作系统实际分配的初始值，而是GC先规划好，用到才分配。专用服务器上需要保持 –Xms 和 –Xmx 一致，否则应用刚启动可能就有好几个 FullGC。 当两者配置不一致时，堆内存扩容可能会导致性能抖动。</li><li>-Xmn, 等价于 -XX:NewSize，使用 G1 垃圾收集器 不应该 设置该选项，在其他的某些业务场景下可以设置。官方建议设置为 -Xmx 的 1/2 ~ 1/4.</li><li>-XX:MaxPermSize=size, 这是 JDK1.7 之前使用的。Java8 默认允许的 Meta空间无限大，此参数无效。</li><li>-XX:MaxMetaspaceSize=size, Java8 默认不限制 Meta 空间, 一般不允许设置该选项。</li><li>-XX:MaxDirectMemorySize=size，系统可以使用的最大堆外内存，这个参数跟 -Dsun.nio.MaxDirectMemorySize 效果相同。</li><li>-Xss, 设置每个线程栈的字节数，影响栈的深度。 例如 -Xss1m 指定线程栈为 1MB，与-XX:ThreadStackSize=1m 等价</li></ul><ol><li>如果什么都不配置会如何?</li><li>Xmx 是否与 Xms 设置相等?</li><li>Xmx 设置为机器内存的什么比例合适?</li><li>作业: 画一下 Xmx、Xms、Xmn、Meta、DirectMemory、Xss 这些内存参数的关系</li></ol><p>4.GC设置参数</p><ul><li>-XX:+UseG1GC:使用 G1 垃圾回收器 </li><li>-XX:+UseConcMarkSweepGC:使用 CMS 垃圾回收器 </li><li>-XX:+UseSerialGC:使用串行垃圾回收器 </li><li>-XX:+UseParallelGC:使用并行垃圾回收器</li><li>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC // Java 11+</li><li>-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC // Java 12+</li></ul><p>各个 JVM 版本的默认 GC 是什么?</p><p>5.分析诊断参数</p><ul><li>-XX:+-HeapDumpOnOutOfMemoryError 选项, 当 OutOfMemoryError 产生，即内存溢出(堆内存或持久代)时，自动 Dump 堆内存。<ul><li>示例用法: java -XX:+HeapDumpOnOutOfMemoryError -Xmx256m ConsumeHeap</li></ul></li><li>-XX:HeapDumpPath 选项, 与 HeapDumpOnOutOfMemoryError 搭配使用, 指定内存溢出时 Dump 文件的目 录。如果没有指定则默认为启动 Java 程序的工作目录。<ul><li>示例用法: java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/ ConsumeHeap </li><li>自动 Dump 的 hprof 文件会存储到 /usr/local/ 目录下</li></ul></li><li>-XX:OnError 选项, 发生致命错误时(fatal error)执行的脚本。<ul><li>例如, 写一个脚本来记录出错时间, 执行一些命令, 或者 curl 一下某个在线报警的 url. 示例用法:java -XX:OnError=”gdb - %p” MyApp</li><li>可以发现有一个 %p 的格式化字符串，表示进程 PID。</li></ul></li><li>-XX:OnOutOfMemoryError 选项, 抛出 OutOfMemoryError 错误时执行的脚本。 </li><li>-XX:ErrorFile=filename 选项, 致命错误的日志文件名,绝对路径或者相对路径。</li><li>-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1506，远程调试</li></ul><p>6.JavaAgent参数</p><p>Agent 是 JVM 中的一项黑科技, 可以通过无侵入方式来做很多事情，比如注入 AOP 代码，执行统计等等，权限非常大。这里简单介绍一下配置选项，详细功能需要专门来讲。</p><p>设置 agent 的语法如下:</p><ul><li>-agentlib:libname[=options] 启用 native 方式的 agent, 参考 LD_LIBRARY_PATH 路径。</li><li>-agentpath:pathname[=options] 启用 native 方式的 agent。</li><li>-javaagent:jarpath[=options] 启用外部的 agent 库, 比如 pinpoint.jar 等等。</li><li>-Xnoagent 则是禁用所有 agent。 以下示例开启 CPU 使用时间抽样分析:<ul><li>JAVA_OPTS=”-agentlib:hprof=cpu=samples,file=cpu.samples.log”</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;JVM-运行时数据区概述&quot;&gt;&lt;a href=&quot;#JVM-运行时数据区概述&quot; class=&quot;headerlink&quot; title=&quot;JVM 运行时数据区概述&quot;&gt;&lt;/a&gt;JVM 运行时数据区概述&lt;/h2&gt;&lt;p&gt;内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。结合 JVM 虚拟机规范，来讨论一下经典的 JVM 内存布局。&lt;/p&gt;
&lt;p&gt;Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。而另外一些则是与线程一一对应的，这些与线对应的数据区域会随着线程开始和结束而创建和销毁。&lt;/p&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 03 —— 类加载器和双亲委派到底是什么？</title>
    <link href="http://yonghong.tech/java-advance/03-jvm-classloader/"/>
    <id>http://yonghong.tech/java-advance/03-jvm-classloader/</id>
    <published>2021-05-15T13:00:00.000Z</published>
    <updated>2021-05-15T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类加载子系统作用"><a href="#类加载子系统作用" class="headerlink" title="类加载子系统作用"></a>类加载子系统作用</h2><ul><li>类加载子系统负责从文件系统或者网络中加载 Class 文件，Class 文件在文件开头有特定的文件标识（cafebabe）</li><li>ClassLoader 只负责 Class 文件的加载，至于它是否能够运行，则由 Execution Engine 决定</li><li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区还存放运行时常量池信息，可能还包含字符串字面值和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）</li></ul><span id="more"></span><h2 id="类加载器的角色"><a href="#类加载器的角色" class="headerlink" title="类加载器的角色"></a>类加载器的角色</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-20-16-U6ND22-TgTnLm.png" alt="类加载器的角色"></p><ul><li>class file 存放于本地硬盘上，可以理解成设计师画在纸上的模板，最终这个模板在执行的时候要加载到 JVM 中来，根据这个文件实例化出 n 个一模一样的实例</li><li>class file 加载到 JVM 中，被称为 DNA 原数据模板，放在方法区</li><li>在 class 文件 -&gt; JVM -&gt; 最终成为原数据模板，此过程需要一个运输工具，即类加载器 Class Loader，扮演一个快递员的角色</li></ul><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-18-01-%E7%B1%BB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%847%E4%B8%AA%E6%AD%A5%E9%AA%A4-r3r8RQ.png" alt="类生命周期的7个步骤"></p><ol><li>加载（Loading）：找Class文件</li><li>验证（Verification）：验证格式、依赖</li><li>准备（Preparation）：静态字段、方法表</li><li>解析（Resolution）：符号解析为引用</li><li>初始化（Initialization）：构造器、静态变量赋值、静态代码块</li><li>使用（Using）</li><li>卸载（Unloading）</li></ol><h3 id="Loading-阶段"><a href="#Loading-阶段" class="headerlink" title="Loading 阶段"></a>Loading 阶段</h3><ol><li><p>通过一个类的全限定名获取定义此类的二进制字节流</p></li><li><p>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据区</p></li><li><p><strong>在内存中生成一个代表这个类的 java.lang.Class 对象</strong>，作为方法区这个类的各种数据的访问入口</p></li></ol><p>补充：加载 class 文件的方式</p><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从 zip 压缩包中读取，成为日后 jar、war 格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP 应用</li><li>从专有数据库中提取 class 文件，比较少见</li><li>从加密文件中获取，典型的防 class 文件被反编译的保护措施</li></ul><h3 id="Linking-阶段"><a href="#Linking-阶段" class="headerlink" title="Linking 阶段"></a>Linking 阶段</h3><p>1.验证（Verify）：</p><ul><li>目的在于确保 class 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机的自身安全</li><li>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证</li></ul><p>2.准备（Prepare）：</p><ul><li>为类变量分配内存并且设置该类变量的默认初始值，即零值</li><li>这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，准备阶段会显示初始化</li><li>这里不会为实例变量分配初始值，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中</li></ul><p>3.解析（Resolve）：</p><ul><li>将常量池内的符号引用转换为直接引用的过程</li><li>事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java 虚拟机规范》的 class 文件格式中。直接引用就是直接指向目标的指针、相对偏移量或者一个间接定位到目标的句柄</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等。</li></ul><h3 id="Initialization-阶段"><a href="#Initialization-阶段" class="headerlink" title="Initialization 阶段"></a>Initialization 阶段</h3><ul><li>初始化阶段就是执行类构造器方法 <code>&lt;clinit&gt;()</code> 的过程</li><li>此方法不需要定义，是 javac 编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来</li><li>构造器方法中指令按语句在源文件中出现的顺序执行</li><li><code>&lt;clinit&gt;()</code> 不同于类的构造器。（关联：构造器是虚拟机视角下的 <code>&lt;init&gt;()</code>）</li><li>若该类具有父类，JVM 会保证子类的 <code>&lt;clinit&gt;()</code> 执行前，父类的 <code>clinit()</code> 已经执行完毕</li><li>虚拟机必须保证一个类的 <code>clinit()</code> 方法在多线程下被同步加载</li></ul><h2 id="类的加载时机"><a href="#类的加载时机" class="headerlink" title="类的加载时机"></a>类的加载时机</h2><ol><li>当虚拟机启动时，初始化用户指定的主类，就是启动执行的main方法所在的类；</li><li>当遇到用一新建目标类实例的new指令时，初始化new指令的目标类，就是new一个类的时候要初始化；</li><li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li><li>当遇到访问静态字段的指令时，初始化该静态字段所在的类；</li><li>子类的初始化会触发父类的初始化；</li><li>如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类初始化，会触发该接口的初始化；</li><li>使用反射API对某个类型进行反射调用时，初始化这个类，其实跟前面一样，反射调用要么是已经有实例了，要么是静态方法，都需要初始化；</li><li>当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类；</li></ol><h3 id="不会初始化（可能会加载）"><a href="#不会初始化（可能会加载）" class="headerlink" title="不会初始化（可能会加载）"></a>不会初始化（可能会加载）</h3><ol><li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化；</li><li>定义对象数组，不会触发该类的初始化；</li><li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类；</li><li>通过类名获取Class对象，不会触发类的初始化，Hello.class不会让Hello类初始化；</li><li>通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化，Class.forName(“jvm.Hello”) 默认会加载Hello类；</li><li>通过ClassLoader默认的loadClass方法，也不会触发初始化动作（加载了，但是不会初始化）；</li></ol><h2 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-23-01-3%E4%B8%AA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-pnd3RO.png" alt="3个类加载器"></p><ul><li>启动类加载器（引导类加载器，Bootstrap ClassLoader）<ul><li>这个类加载器使用 C/C++ 语言实现的，嵌套在 JVM 内部</li><li>它用来加载 Java 的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类</li><li>并不继承自 java.lang.ClassLoader，没有父加载器。</li><li>加载拓展类和应用程序类加载器，并指定为他们的父类加载器</li><li>出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类</li></ul></li><li>拓展类加载器（Extension ClassLoader）<ul><li>Java 语言编写，由 sun.misc.Launcher$ExtClassLoader 实现</li><li>派生于 ClassLoader 类</li><li>父类加载器为启动类加载器</li><li>从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/lib/ext 子目录（拓展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由拓展类加载器加载</li></ul></li><li>应用程序类加载器（系统类加载器，AppClassLoader）<ul><li>java 语言编写，由 sun.misc.Launcher$AppClassLoader 实现</li><li>派生于 ClassLoader 类</li><li>父类加载器为拓展类加载器</li><li>他负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java 应用的类都是由它来完成加载</li><li>通过 ClassLoader$getSystemClassLoader() 方法可以获取到该类加载器</li></ul></li></ul><p>类加载器可以通过getParent获取父加载器，这并不是继承关系，如果直接继承ClassLoader自己实现一个类加载器，且不指定父加载器，他的父加载器就是AppClassLoader</p><p>任何parent为null的加载器，其父加载器为 BootstrapClassLoader</p><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-26-01-%E6%8B%93%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%BA%94%E7%94%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-PRIfeU.png" alt="拓展类加载器和应用类加载器"></p><h2 id="加载器特点"><a href="#加载器特点" class="headerlink" title="加载器特点"></a>加载器特点</h2><h3 id="双亲委托"><a href="#双亲委托" class="headerlink" title="双亲委托"></a>双亲委托</h3><p>Java 虚拟机对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p><ul><li>如果一个类加载器收到了类加载的请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li><li>如果父类加载器还存在其他父类加载器，则进一步向上委托，依次递归请求最终将到达顶层的启动类加载器</li><li>如果父类加载器可以完成类的加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制</li></ul><p><strong>优势</strong></p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心 API 被随意篡改</li></ul><p><strong>沙箱安全机制</strong></p><p>自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载过程中会率先加载 JDK 自带的文件（rt.jar 包中 java/lang/String.class），报错信息说没有 main 方法，就是因为加载的是rt.jar 包中的 String 类。这样可以保证对 Java 核心源代码的保护，这就是沙箱安全机制。</p><p>在 JVM 中表示两个 class 对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名</li><li>加载这个类的 ClassLoader （指 ClassLoader 实例对象）必须相同</li></ul><p>换句话说，在 JVM 中，即使这两个类对象（class 对象）来源于同一个 Class 文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的。</p><p>JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么 JVM 会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。</p><h3 id="负责依赖"><a href="#负责依赖" class="headerlink" title="负责依赖"></a>负责依赖</h3><p>如果一个类依赖了其他的类，那么就需要先加载依赖的类。</p><h3 id="缓存加载"><a href="#缓存加载" class="headerlink" title="缓存加载"></a>缓存加载</h3><p>类加载之后，就把它缓存起来，后续从缓存中获取</p><h2 id="关于-ClassLoader"><a href="#关于-ClassLoader" class="headerlink" title="关于 ClassLoader"></a>关于 ClassLoader</h2><p>ClassLoader 类，它是一个抽象类，其后所有的类加载器都继承自 ClassLoader （不包括启动类加载器）</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>getParent()</td><td>返回该类加载器的超类加载器</td></tr><tr><td>loadClass(String name)</td><td>加载名称为 name 的类，返回结果为 java.lang.Class 类的实例</td></tr><tr><td>findClass(String name)</td><td>查找名称为 name 的类，返回结果为 java.lang.Class 类的实例</td></tr><tr><td>findLoadedClass(String name)</td><td>查找名称为 name 的已经被加载过的类，返回结果为 java.lang.Class 类的实例</td></tr><tr><td>defineClass(String name, byte[] b, int off, int len)</td><td>把字节数组 b 中的内存转换成为一个 Java 类，返回结果为 java.lang.Class 类的实例</td></tr><tr><td>resolveClass(Class&lt;?&gt; c)</td><td>连接指定的一个 Java 类</td></tr></tbody></table><h2 id="获取-ClassLoader-的途径"><a href="#获取-ClassLoader-的途径" class="headerlink" title="获取 ClassLoader 的途径"></a>获取 ClassLoader 的途径</h2><p>方式一：获取当前类的 ClassLoader</p><p>clazz.getClassLoader()</p><p>方式二：获取当前线程上下文的 ClassLoader</p><p>Thread.currentThread().getContextClassLoader()</p><p>方式三：获取系统的ClassLoader</p><p>ClassLoader.getSystemClassLoader()</p><p>方式四：获取调用者的 CLassLoader</p><p>DriverManager.getCallerClassLoader()</p><h2 id="显示当前-ClassLoader-加载了哪些-Jar-？"><a href="#显示当前-ClassLoader-加载了哪些-Jar-？" class="headerlink" title="显示当前 ClassLoader 加载了哪些 Jar ？"></a>显示当前 ClassLoader 加载了哪些 Jar ？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmClassLoaderPrintPath</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动类加载器</span></span><br><span class="line">        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        System.out.println(<span class="string">&quot;启动类加载器&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; ===&gt; &quot;</span> + url.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓展类加载器</span></span><br><span class="line">        printClassLoader(<span class="string">&quot;拓展类加载器&quot;</span>, JvmClassLoaderPrintPath.class.getClassLoader().getParent());</span><br><span class="line">        <span class="comment">// 应用类加载器</span></span><br><span class="line">        printClassLoader(<span class="string">&quot;应用类加载器&quot;</span>, JvmClassLoaderPrintPath.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassLoader</span><span class="params">(String name, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot; ClassLoader -&gt; &quot;</span> + classLoader.toString());</span><br><span class="line">            printUrlForClassLoader(classLoader);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot; ClassLoader -&gt; null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUrlForClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        Object ucp = insightField(classLoader, <span class="string">&quot;ucp&quot;</span>);</span><br><span class="line">        Object path = insightField(ucp, <span class="string">&quot;path&quot;</span>);</span><br><span class="line">        ArrayList ps = (ArrayList) path;</span><br><span class="line">        <span class="keyword">for</span> (Object p : ps) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; ===&gt; &quot;</span> + p.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">insightField</span><span class="params">(Object obj, String fName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> URLClassLoader) &#123;</span><br><span class="line">                f = URLClassLoader.class.getDeclaredField(fName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f = obj.getClass().getDeclaredField(fName);</span><br><span class="line">            &#125;</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> f.get(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">启动类加载器</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/resources.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/rt.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/sunrsasign.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/jsse.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/jce.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/charsets.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/jfr.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/classes</span><br><span class="line">拓展类加载器 ClassLoader -&gt; sun.misc.Launcher$ExtClassLoader@6d06d69c</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/sunec.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/nashorn.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/cldrdata.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/dnsns.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/localedata.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/sunjce_provider.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/sunpkcs11.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/jaccess.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/zipfs.jar</span><br><span class="line"> ===&gt; file:/System/Library/Java/Extensions/MRJToolkit.jar</span><br><span class="line">应用类加载器 ClassLoader -&gt; sun.misc.Launcher$AppClassLoader@659e0bfd</span><br><span class="line"> ===&gt; file:/Users/yq/code/wangyonghong/code-lab/gtu-java/out/production/gtu-java/</span><br></pre></td></tr></table></figure><h2 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h2><ul><li><p>在 Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式</p></li><li><p>为什么要自定义类加载器</p><ul><li>隔离加载类</li><li>修改类加载方式</li><li>拓展加载源</li><li>防止源码泄露</li></ul></li><li><p>开发人员可以通过继承抽象类 java.lang.ClassLoader 类的方式，实现自己的类加载器，以满足一些特殊需求</p></li><li><p>在 JDK 1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载器类，但是在 JDK 1.2 之后已不再建议用户去覆盖 loadClass() 方法，而是建议把自定义的类加载逻辑写在 findClass() 方法中</p></li><li><p>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findClass() 方法以及获取字节码流的方式，使自定义类加载器编写更加简单</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, classLoader!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以下方法拿到 base64</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac Hello.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> base64 Hello.class</span> </span><br><span class="line">yv66vgAAADQAHAoABgAOCQAPABAIABEKABIAEwcAFAcAFQEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAAVoZWxsbwEAClNvdXJjZUZpbGUBAApIZWxsby5qYXZhDAAHAAgHABYMABcAGAEAE0hlbGxvLCBjbGFzc0xvYWRlciEHABkMABoAGwEABUhlbGxvAQAQamF2YS9sYW5nL09iamVjdAEAEGphdmEvbGFuZy9TeXN0ZW0BAANvdXQBABVMamF2YS9pby9QcmludFN0cmVhbTsBABNqYXZhL2lvL1ByaW50U3RyZWFtAQAHcHJpbnRsbgEAFShMamF2YS9sYW5nL1N0cmluZzspVgAhAAUABgAAAAAAAgABAAcACAABAAkAAAAdAAEAAQAAAAUqtwABsQAAAAEACgAAAAYAAQAAAAQAAQALAAgAAQAJAAAAJQACAAEAAAAJsgACEgO2AASxAAAAAQAKAAAACgACAAAABgAIAAcAAQAMAAAAAgAN</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过以下方法可以自定义ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yonghongwang#163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/4/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> HelloClassLoader().findClass(<span class="string">&quot;Hello&quot;</span>).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String helloBase64 = <span class="string">&quot;yv66vgAAADQAHAoABgAOCQAPABAIABEKABIAEwcAFAcAFQEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAAVoZWxsbwEAClNvdXJjZUZpbGUBAApIZWxsby5qYXZhDAAHAAgHABYMABcAGAEAE0hlbGxvLCBjbGFzc0xvYWRlciEHABkMABoAGwEABUhlbGxvAQAQamF2YS9sYW5nL09iamVjdAEAEGphdmEvbGFuZy9TeXN0ZW0BAANvdXQBABVMamF2YS9pby9QcmludFN0cmVhbTsBABNqYXZhL2lvL1ByaW50U3RyZWFtAQAHcHJpbnRsbgEAFShMamF2YS9sYW5nL1N0cmluZzspVgAhAAUABgAAAAAAAgABAAcACAABAAkAAAAdAAEAAQAAAAUqtwABsQAAAAEACgAAAAYAAQAAAAQAAQALAAgAAQAJAAAAJQACAAEAAAAJsgACEgO2AASxAAAAAQAKAAAACgACAAAABgAIAAcAAQAMAAAAAgAN&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = decode(helloBase64);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] decode(String base64) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getDecoder().decode(base64);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加类的几种方式？"><a href="#添加类的几种方式？" class="headerlink" title="添加类的几种方式？"></a>添加类的几种方式？</h2><ol><li>放到 JDK 的 lib/ext 下，或者 -Djava.ext.dirs=path</li><li>java -cp/classpath 或者 class 文件放到当前路径</li><li>自定义 ClassLoader 加载</li><li>拿到当前执行类的 ClassLoader，反射调用 addUrl 方法添加 Jar 或路径（JDK 9 之后平级了，可以使用 <code>Class.forName(&quot;xxx&quot;, new URLClassLoader(&quot;path&quot;));</code>）</li></ol><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>自定义一个 Classloader，加载一个 Hello.xlass 文件，执行 hello 方法， 此文件内容是一个 Hello.class 文件所有字节(x=255-x)处理后的文件。</p><p>题解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yonghongwang#163.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassloader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; helloClass = <span class="keyword">new</span> MyClassloader().findClass(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        Method helloMethod = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            helloMethod = helloClass.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            helloMethod.invoke(helloClass.newInstance());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) &#123;</span><br><span class="line">        String path = <span class="keyword">this</span>.getClass().getResource(<span class="string">&quot;Hello.xlass&quot;</span>).getPath();</span><br><span class="line">        File file;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file = <span class="keyword">new</span> File(URLDecoder.decode(path, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;failed to find path: &quot;</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile() &amp;&amp; file.exists()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (FileChannel channel = <span class="keyword">new</span> FileInputStream(file).getChannel()) &#123;</span><br><span class="line">                ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="keyword">int</span>) channel.size());</span><br><span class="line">                channel.read(byteBuffer);</span><br><span class="line">                bytes = byteBuffer.array();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;failed to find path: &quot;</span> + path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;failed to find path: &quot;</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, decode(bytes), <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * replace each byte with x-&gt;255-x</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] decode(<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line"><span class="comment">//            bytes[i] = (byte) (255 - bytes[i]);</span></span><br><span class="line">            bytes[i] = (<span class="keyword">byte</span>) ~bytes[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;类加载子系统作用&quot;&gt;&lt;a href=&quot;#类加载子系统作用&quot; class=&quot;headerlink&quot; title=&quot;类加载子系统作用&quot;&gt;&lt;/a&gt;类加载子系统作用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;类加载子系统负责从文件系统或者网络中加载 Class 文件，Class 文件在文件开头有特定的文件标识（cafebabe）&lt;/li&gt;
&lt;li&gt;ClassLoader 只负责 Class 文件的加载，至于它是否能够运行，则由 Execution Engine 决定&lt;/li&gt;
&lt;li&gt;加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区还存放运行时常量池信息，可能还包含字符串字面值和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 02 —— 是时候了解一下 Java 字节码了</title>
    <link href="http://yonghong.tech/java-advance/02-jvm-bytecode/"/>
    <id>http://yonghong.tech/java-advance/02-jvm-bytecode/</id>
    <published>2021-05-14T14:00:00.000Z</published>
    <updated>2021-05-14T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是字节码？"><a href="#什么是字节码？" class="headerlink" title="什么是字节码？"></a>什么是字节码？</h2><ul><li><p>我们平时所说的 Java 字节码，指的是用 Java 语言编译成的字节码。准确的说能在 JVM 平台上执行的字节码格式都是一样的。所以应该统称为 JVM 字节码。</p></li><li><p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的 JVM 上运行。</p></li><li><p>Java 虚拟机与 Java 语言并没有必然的联系，它只与特定的二进制文件格式 .class 文件格式所关联，.class 文件中包含了 Java 虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他的辅助信息。</p></li><li><p>Java bytecode 由单字节（byte）的指令组成，理论上最多支持 256 个操作码（opcode）。 实际上 Java 只使用了200左右的操作码，还有一些操作码则保留给调试操作。详情见：</p></li><li><p><a href="https://yonghong.tech/2021/01/jvm-instruction-set/">JVM 指令集对照表</a></p></li></ul><span id="more"></span><p>根据指令的性质，主要分为四个大类：</p><ol><li>栈操作指令，包括与局部变量交互的指令</li><li>程序流程控制指令</li><li>对象操作指令，包括方法调用指令</li><li>算术运算以及类型转换指令</li></ol><p>举个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloByteCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloByteCode obj = <span class="keyword">new</span> HelloByteCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac -g HelloByteCode.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> javap -c -v HelloByteCode</span></span><br><span class="line">Classfile /Users/yonghong/Coding/code-lab/gtu-java/week01/HelloByteCode.class</span><br><span class="line">  Last modified 2021-1-7; size 415 bytes</span><br><span class="line">  MD5 checksum 44dd68d97fffda0bd16a524fb32b983a</span><br><span class="line">  Compiled from &quot;HelloByteCode.java&quot;</span><br><span class="line">public class HelloByteCode</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52   // 52 对应 Java 8</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:        // 常量池</span><br><span class="line"><span class="meta">   #</span><span class="bash">1 = Methodref          <span class="comment">#4.#19         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">2 = Class              <span class="comment">#20            // HelloByteCode</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">3 = Methodref          <span class="comment">#2.#19         // HelloByteCode.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">4 = Class              <span class="comment">#21            // java/lang/Object</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">5 = Utf8               &lt;init&gt;</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">6 = Utf8               ()V</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">7 = Utf8               Code</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">8 = Utf8               LineNumberTable</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">9 = Utf8               LocalVariableTable</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">10 = Utf8               this</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">11 = Utf8               LHelloByteCode;</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">12 = Utf8               main</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">13 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">14 = Utf8               args</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">15 = Utf8               [Ljava/lang/String;</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">16 = Utf8               obj</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">17 = Utf8               SourceFile</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">18 = Utf8               HelloByteCode.java</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">19 = NameAndType        <span class="comment">#5:#6          // &quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash">20 = Utf8               HelloByteCode</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">21 = Utf8               java/lang/Object</span></span><br><span class="line">&#123;</span><br><span class="line">  public HelloByteCode();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   LHelloByteCode;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=1</span><br><span class="line">         0: new           #2                  // class HelloByteCode</span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0   // new 指令在源码的第 3 行</span><br><span class="line">        line 4: 8   // return 指令在源码的第 4 行</span><br><span class="line">      LocalVariableTable:   // 本地变量表</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">      // 起作用的行  生效范围  槽数  变量名称  变量类型签名</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">            8       1     1   obj   LHelloByteCode;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;HelloByteCode.java&quot;</span><br></pre></td></tr></table></figure><h3 id="javac-与-javap"><a href="#javac-与-javap" class="headerlink" title="javac 与 javap"></a>javac 与 javap</h3><p>javac 的用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac -<span class="built_in">help</span></span></span><br><span class="line">用法: javac &lt;options&gt; &lt;source files&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -g                         生成所有调试信息</span><br><span class="line">  -g:none                    不生成任何调试信息</span><br><span class="line">  -g:&#123;lines,vars,source&#125;     只生成某些调试信息</span><br><span class="line">  -nowarn                    不生成任何警告</span><br><span class="line">  -verbose                   输出有关编译器正在执行的操作的消息</span><br><span class="line">  -deprecation               输出使用已过时的 API 的源位置</span><br><span class="line">  -classpath &lt;路径&gt;            指定查找用户类文件和注释处理程序的位置</span><br><span class="line">  -cp &lt;路径&gt;                   指定查找用户类文件和注释处理程序的位置</span><br><span class="line">  -sourcepath &lt;路径&gt;           指定查找输入源文件的位置</span><br><span class="line">  -bootclasspath &lt;路径&gt;        覆盖引导类文件的位置</span><br><span class="line">  -extdirs &lt;目录&gt;              覆盖所安装扩展的位置</span><br><span class="line">  -endorseddirs &lt;目录&gt;         覆盖签名的标准路径的位置</span><br><span class="line">  -proc:&#123;none,only&#125;          控制是否执行注释处理和/或编译。</span><br><span class="line">  -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程</span><br><span class="line">  -processorpath &lt;路径&gt;        指定查找注释处理程序的位置</span><br><span class="line">  -parameters                生成元数据以用于方法参数的反射</span><br><span class="line">  -d &lt;目录&gt;                    指定放置生成的类文件的位置</span><br><span class="line">  -s &lt;目录&gt;                    指定放置生成的源文件的位置</span><br><span class="line">  -h &lt;目录&gt;                    指定放置生成的本机标头文件的位置</span><br><span class="line">  -implicit:&#123;none,class&#125;     指定是否为隐式引用文件生成类文件</span><br><span class="line">  -encoding &lt;编码&gt;             指定源文件使用的字符编码</span><br><span class="line">  -source &lt;发行版&gt;              提供与指定发行版的源兼容性</span><br><span class="line">  -target &lt;发行版&gt;              生成特定 VM 版本的类文件</span><br><span class="line">  -profile &lt;配置文件&gt;            请确保使用的 API 在指定的配置文件中可用</span><br><span class="line">  -version                   版本信息</span><br><span class="line">  -help                      输出标准选项的提要</span><br><span class="line">  -A关键字[=值]                  传递给注释处理程序的选项</span><br><span class="line">  -X                         输出非标准选项的提要</span><br><span class="line">  -J&lt;标记&gt;                     直接将 &lt;标记&gt; 传递给运行时系统</span><br><span class="line">  -Werror                    出现警告时终止编译</span><br><span class="line">  @&lt;文件名&gt;                     从文件读取选项和文件名</span><br></pre></td></tr></table></figure><p>javap 的用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javap -<span class="built_in">help</span></span></span><br><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -help  --help  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -public                  仅显示公共类和成员</span><br><span class="line">  -protected               显示受保护的/公共类和成员</span><br><span class="line">  -package                 显示程序包/受保护的/公共类</span><br><span class="line">                           和成员 (默认)</span><br><span class="line">  -p  -private             显示所有类和成员</span><br><span class="line">  -c                       对代码进行反汇编</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的</span><br><span class="line">                           系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">  -cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure><h2 id="字节码的运行时结构"><a href="#字节码的运行时结构" class="headerlink" title="字节码的运行时结构"></a>字节码的运行时结构</h2><p>JVM 是一台基于栈的计算机器。</p><p>每个线程都有一个独属于自己的线程栈（JVM Stack），用于存储 栈帧（Frame）。 每一次方法调用，JVM 都会自动创建一个栈帧。栈帧由操作数栈，局部变量数组以及一个 Class 引用组成。Class 引用指向当前方法在运行时常量池中对应的 Class。</p><h2 id="从助记符到二进制"><a href="#从助记符到二进制" class="headerlink" title="从助记符到二进制"></a>从助记符到二进制</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-05-%E4%BB%8E%E5%8A%A9%E8%AE%B0%E7%AC%A6%E5%88%B0%E4%BA%8C%E8%BF%9B%E5%88%B6-1rl8Dp.png" alt="从助记符到二进制"></p><h2 id="四则运行的例子"><a href="#四则运行的例子" class="headerlink" title="四则运行的例子"></a>四则运行的例子</h2><p>MovingAverage.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> sum = <span class="number">0.0D</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(<span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">        <span class="keyword">this</span>.sum += value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAvg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="keyword">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sum / <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LocalVaribleTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVaribleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MovingAverage ma = <span class="keyword">new</span> MovingAverage();</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line">        ma.submit(num1);</span><br><span class="line">        ma.submit(num2);</span><br><span class="line">        <span class="keyword">double</span> avg = ma.getAvg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javap -c MovingAverage</span></span><br><span class="line">Compiled from &quot;MovingAverage.java&quot;</span><br><span class="line">public class MovingAverage &#123;</span><br><span class="line">  public MovingAverage();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: aload_0</span><br><span class="line">       5: iconst_0</span><br><span class="line">       6: putfield      #2                  // Field count:I</span><br><span class="line">       9: aload_0</span><br><span class="line">      10: dconst_0</span><br><span class="line">      11: putfield      #3                  // Field sum:D</span><br><span class="line">      14: return</span><br><span class="line"></span><br><span class="line">  public void submit(double);</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: dup</span><br><span class="line">       2: getfield      #2                  // Field count:I</span><br><span class="line">       5: iconst_1</span><br><span class="line">       6: iadd</span><br><span class="line">       7: putfield      #2                  // Field count:I</span><br><span class="line">      10: aload_0</span><br><span class="line">      11: dup</span><br><span class="line">      12: getfield      #3                  // Field sum:D</span><br><span class="line">      15: dload_1</span><br><span class="line">      16: dadd</span><br><span class="line">      17: putfield      #3                  // Field sum:D</span><br><span class="line">      20: return</span><br><span class="line"></span><br><span class="line">  public double getAvg();</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_0</span><br><span class="line">       1: aload_0</span><br><span class="line">       2: getfield      #2                  // Field count:I</span><br><span class="line">       5: if_icmpne     13</span><br><span class="line">       8: aload_0</span><br><span class="line">       9: getfield      #3                  // Field sum:D</span><br><span class="line">      12: dreturn</span><br><span class="line">      13: aload_0</span><br><span class="line">      14: getfield      #3                  // Field sum:D</span><br><span class="line">      17: aload_0</span><br><span class="line">      18: getfield      #2                  // Field count:I</span><br><span class="line">      21: i2d</span><br><span class="line">      22: ddiv</span><br><span class="line">      23: dreturn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> javap -c LocalVaribleTest</span></span><br><span class="line">Compiled from &quot;LocalVaribleTest.java&quot;</span><br><span class="line">public class LocalVaribleTest &#123;</span><br><span class="line">  public LocalVaribleTest();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class MovingAverage</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #3                  // Method MovingAverage.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: iconst_1</span><br><span class="line">       9: istore_2</span><br><span class="line">      10: iconst_2</span><br><span class="line">      11: istore_3</span><br><span class="line">      12: aload_1</span><br><span class="line">      13: iload_2</span><br><span class="line">      14: i2d   // int 转成 double 隐式转换</span><br><span class="line">      15: invokevirtual #4                  // Method MovingAverage.submit:(D)V</span><br><span class="line">      18: aload_1</span><br><span class="line">      19: iload_3</span><br><span class="line">      20: i2d</span><br><span class="line">      21: invokevirtual #4                  // Method MovingAverage.submit:(D)V</span><br><span class="line">      24: aload_1</span><br><span class="line">      25: invokevirtual #5                  // Method MovingAverage.getAvg:()D</span><br><span class="line">      28: dstore        4</span><br><span class="line">      30: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算数操作与类型转换"><a href="#算数操作与类型转换" class="headerlink" title="算数操作与类型转换"></a>算数操作与类型转换</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-09-01-%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-D45qpJ.png" alt="算数操作与类型转换"></p><h2 id="一个完整的循环控制"><a href="#一个完整的循环控制" class="headerlink" title="一个完整的循环控制"></a>一个完整的循环控制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForLoopTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MovingAverage ma = <span class="keyword">new</span> MovingAverage();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            ma.submit(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> avg = ma.getAvg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javap -c ForLoopTest</span></span><br><span class="line">Compiled from &quot;ForLoopTest.java&quot;</span><br><span class="line">public class ForLoopTest &#123;</span><br><span class="line">  public ForLoopTest();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class MovingAverage</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #3                  // Method MovingAverage.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: getstatic     #4                  // Field nums:[I</span><br><span class="line">      11: astore_2</span><br><span class="line">      12: aload_2</span><br><span class="line">      13: arraylength</span><br><span class="line">      14: istore_3</span><br><span class="line">      15: iconst_0                // 初始化变量 0</span><br><span class="line">      16: istore        4         // 存储到本地变量表 4 槽位</span><br><span class="line">      18: iload         4         // 加载 4 槽位 到操作数栈</span><br><span class="line">      20: iload_3                 // 加载 int 3 到操作数栈</span><br><span class="line">      21: if_icmpge     43        // 比较，如果大于等于跳转到 43 行指令</span><br><span class="line">      24: aload_2</span><br><span class="line">      25: iload         4</span><br><span class="line">      27: iaload</span><br><span class="line">      28: istore        5</span><br><span class="line">      30: aload_1</span><br><span class="line">      31: iload         5</span><br><span class="line">      33: i2d</span><br><span class="line">      34: invokevirtual #5                  // Method MovingAverage.submit:(D)V</span><br><span class="line">      37: iinc          4, 1      // 4 槽位上加 1</span><br><span class="line">      40: goto          18        // goto 18 行指令</span><br><span class="line">      43: aload_1</span><br><span class="line">      44: invokevirtual #6                  // Method MovingAverage.getAvg:()D</span><br><span class="line">      47: dstore_2</span><br><span class="line">      48: return</span><br><span class="line"></span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_3</span><br><span class="line">       1: newarray       int</span><br><span class="line">       3: dup</span><br><span class="line">       4: iconst_0</span><br><span class="line">       5: iconst_1</span><br><span class="line">       6: iastore</span><br><span class="line">       7: dup</span><br><span class="line">       8: iconst_1</span><br><span class="line">       9: bipush        6</span><br><span class="line">      11: iastore</span><br><span class="line">      12: dup</span><br><span class="line">      13: iconst_2</span><br><span class="line">      14: bipush        8</span><br><span class="line">      16: iastore</span><br><span class="line">      17: putstatic     #4                  // Field nums:[I</span><br><span class="line">      20: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法调用的指令"><a href="#方法调用的指令" class="headerlink" title="方法调用的指令"></a>方法调用的指令</h2><ul><li>invokestatic，顾名思义，这个指令用于调用某个类的静态方法，这是方法调用指令中最快的一个。</li><li>invokespecial, 用来调用构造函数，但也可以用于调用同一个类中的 private 方法, 以及可见的超类方法。</li><li>invokevirtual，如果是具体类型的目标对象，invokevirtual 用于调用公共，受保护和 package 级的私有方法。</li><li>invokeinterface，当通过接口引用来调用方法时，将会编译为 invokeinterface 指令。</li><li>invokedynamic，JDK7 新增加的指令，是实现“动态类型语言”（Dynamically Typed Language）支持而进行的升级改进，同时也是 JDK8 以后支持 lambda 表达式的实现基础。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是字节码？&quot;&gt;&lt;a href=&quot;#什么是字节码？&quot; class=&quot;headerlink&quot; title=&quot;什么是字节码？&quot;&gt;&lt;/a&gt;什么是字节码？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我们平时所说的 Java 字节码，指的是用 Java 语言编译成的字节码。准确的说能在 JVM 平台上执行的字节码格式都是一样的。所以应该统称为 JVM 字节码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的 JVM 上运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java 虚拟机与 Java 语言并没有必然的联系，它只与特定的二进制文件格式 .class 文件格式所关联，.class 文件中包含了 Java 虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他的辅助信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java bytecode 由单字节（byte）的指令组成，理论上最多支持 256 个操作码（opcode）。 实际上 Java 只使用了200左右的操作码，还有一些操作码则保留给调试操作。详情见：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://yonghong.tech/2021/01/jvm-instruction-set/&quot;&gt;JVM 指令集对照表&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 01 —— 5 分钟回顾一下 Java 基础知识</title>
    <link href="http://yonghong.tech/java-advance/01-jvm-basic/"/>
    <id>http://yonghong.tech/java-advance/01-jvm-basic/</id>
    <published>2021-05-14T13:00:00.000Z</published>
    <updated>2021-05-14T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-生态圈"><a href="#Java-生态圈" class="headerlink" title="Java 生态圈"></a>Java 生态圈</h2><p>Java 是目前应用最为广泛的软件开发平台之一。随着 Java 以及 Java 社区的不断壮大，Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p><ul><li>作为一个平台：Java 虚拟机扮演着举足轻重的作用。<ul><li>Groovy、Scala、JRuby、Kotlin 等都是 Java 平台的一部分。</li></ul></li><li>作为一种文化：Java 几乎成为了开源的代名词<ul><li>第三方开源软件和框架，如，Tomcat、Struts、MyBatis、Spring 等</li><li>就连 JDK 和 JVM 自身也有不少开源的实现，如 OpenJDK、Harmony</li></ul></li><li>作为一个社区，Java 拥有全世界最多的技术拥护者和开源社区的支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到 Java 的身影。其应用形式之复杂、参与人数之众也令人咋舌。</li></ul><span id="more"></span><h2 id="Java-跨平台的语言"><a href="#Java-跨平台的语言" class="headerlink" title="Java 跨平台的语言"></a>Java 跨平台的语言</h2><h3 id="Java-虚拟机规范"><a href="#Java-虚拟机规范" class="headerlink" title="Java 虚拟机规范"></a>Java 虚拟机规范</h3><p>The Java Virtual Machine is the cornerstone of the Java platform. <strong>It is the component of the technology responsible for its hardware- and operating system-independence</strong>, the small size of its compiled code, and its ability to protect users from malicious programs.</p><p>The Java Virtual Machine is an abstract computing machine. Like a real computing machine, it has an instruction set and manipulates various memory areas at run time. It is reasonably common to implement a programming language using a virtual machine; the best-known virtual machine may be the P-Code machine of UCSD Pascal.</p><h3 id="JVM-跨语言的平台"><a href="#JVM-跨语言的平台" class="headerlink" title="JVM 跨语言的平台"></a>JVM 跨语言的平台</h3><p>随着 Java 7 的正式发布，Java 虚拟机的设计者们通过 JSR-292 规范基本实现在 Java 虚拟机平台上运行非 Java 语言编写的程序。</p><p>Java 虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说，Java 虚拟机拥有语言无关性，并不会单纯地与 Java 语言“终身绑定”，只要其他编程语言的编译结果满足并包含 Java 虚拟机的内部指令集，符号表以及其他的辅助信息，他就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-19-34-orUTHy-CAZ1Zb.png" alt="Java 跨平台的语言"></p><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-19-40-%E6%BA%90%E7%A0%81%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%B7%A8%E5%B9%B3%E5%8F%B0-R6Uzxy.png" alt="源码跨平台和二进制跨平台"></p><ul><li>Java、C++、Rust 的区别<ul><li>C/C++ 完全相信而且惯着程序员，让大家自行管理内存，可以编写很自由的代码，但一 不小心就会造成内存泄漏等问题，导致程序崩溃。</li><li>Java/Golang 完全不相信程序员，但也惯着程序员。所有的内存生命周期都由 JVM 运行 时统一管理。 在绝大部分场景下，你可以非常自由的写代码，而且不用关心内存到底是 什么情况。 内存使用有问题的时候，我们可以通过 JVM 来进行信息相关的分析诊断和 调整。 这也是本课程的目标。</li><li>Rust 语言选择既不相信程序员，也不惯着程序员。 让你在写代码的时候，必须清楚明白 的用 Rust 的规则管理好你的变量，好让机器能明白高效地分析和管理内存。 但是这样 会导致代码不利于人的理解，写代码很不自由，学习成本也很高。</li></ul></li></ul><h3 id="多语言混合编程"><a href="#多语言混合编程" class="headerlink" title="多语言混合编程"></a>多语言混合编程</h3><p>Java 平台上的多语言混合编程正在成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</p><p>试想一下，在一个项目之中，并行处理使用 Clojure 语言编写，展示层使用 JRuby/Rails，中间层则是 Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生 API 一样方便，因为他们最终都运行在一个虚拟机之上。</p><p>对于这些运行在虚拟机之上、Java 语言之外的语言，来自系统级的、底层的支持正在迅速增强，以 JSR-292 为核心的一系列项目和功能改进（如，Davinci Machine 项目、Nashorn 引擎、InvokeDynamic 指令、java.lang.invoke 包等），推动 Java 虚拟机从 Java 语言的虚拟机向多语言虚拟机发展。</p><h3 id="两种架构"><a href="#两种架构" class="headerlink" title="两种架构"></a>两种架构</h3><p>Java 编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。</p><p>具体来说两种架构之间的区别：</p><ul><li>基于栈式架构的特点<ul><li>设计和实现更简单，适用于资源受限的系统；</li><li>避开了寄存器的分配难题：使用零地址指令方式分配；</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作数。指令集更小，编译器容易实现；</li><li>不需要硬件支持，可移植性更好，更好实现跨平台。</li></ul></li><li>基于寄存器架构的特点<ul><li>典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机；</li><li>指令集架构则完全依赖硬件，可移植性差；</li><li>性能优秀和执行更高效；</li><li>花费更少的指令去完成一项操作；</li><li>在大部分情况下，基于寄存器架构的指令集往往都是一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。</li></ul></li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>同样执行 2+3 这种逻辑操作，其指令分别如下：</p><p>基于栈的计算流程（以 Java 虚拟机为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iconst_2 <span class="comment">// 常量 2 入栈</span></span><br><span class="line">istore_1</span><br><span class="line">iconst_3 <span class="comment">// 常量 3 入栈</span></span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd     <span class="comment">// 常量 2、3 出栈，执行相加</span></span><br><span class="line">istore_0 <span class="comment">// 结果 5 入栈</span></span><br></pre></td></tr></table></figure><p>而基于寄存器的计算流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,<span class="number">2</span>  <span class="comment">// 将 eax 寄存器的值设置为 2</span></span><br><span class="line">mov eax,<span class="number">3</span>  <span class="comment">// 使 eax 寄存器的值加 3</span></span><br></pre></td></tr></table></figure><p>代码演示一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackStruTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">cd chapter_01</span><br><span class="line">javac StackStruTest.java</span><br><span class="line">javap -v StackStruTest</span><br><span class="line">Classfile /Users/yonghong/Coding/jvm/song/chapter_01/StackStruTest.class</span><br><span class="line">  Last modified 2020-11-17; size 277 bytes</span><br><span class="line">  MD5 checksum 9a7da6f68b8101238c5ab826d90154c5</span><br><span class="line">  Compiled from &quot;StackStruTest.java&quot;</span><br><span class="line">public class StackStruTest</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line"><span class="meta">   #</span><span class="bash">1 = Methodref          <span class="comment">#3.#12         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">2 = Class              <span class="comment">#13            // StackStruTest</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">3 = Class              <span class="comment">#14            // java/lang/Object</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">4 = Utf8               &lt;init&gt;</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">5 = Utf8               ()V</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">6 = Utf8               Code</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">7 = Utf8               LineNumberTable</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">8 = Utf8               main</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">9 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">10 = Utf8               SourceFile</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">11 = Utf8               StackStruTest.java</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">12 = NameAndType        <span class="comment">#4:#5          // &quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash">13 = Utf8               StackStruTest</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">14 = Utf8               java/lang/Object</span></span><br><span class="line">&#123;</span><br><span class="line">  public StackStruTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 2: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=2, args_size=1</span><br><span class="line">         0: iconst_5 // 直接返回了 5</span><br><span class="line">         1: istore_1</span><br><span class="line">         2: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 4: 0</span><br><span class="line">        line 5: 2</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;StackStruTest.java&quot;</span><br></pre></td></tr></table></figure><p>由于跨平台的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的。优点是跨平台、指令集小，编译器容易实现；缺点是性能下降，实现同样的功能需要更多的指令。</p><p>时至今日，尽管嵌入式平台已经不是 Java 程序的主流运行平台了（准确来说是 HotSpot 虚拟机的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p><p>答：基于栈式架构的虚拟机跨平台、指令集小，编译器容易实现，在非资源受限的场景中也是可以使用的。</p><h2 id="JVM-的生命周期"><a href="#JVM-的生命周期" class="headerlink" title="JVM 的生命周期"></a>JVM 的生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java 虚拟机的启动时通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ul><li>一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序；</li><li>程序开始执行时他才运行，程序结束时他就停止；</li><li>执行一个所谓的 Java 程序的时候，真真正正在执行的是一个叫做 Java 虚拟机的进程。</li></ul><h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p>有如下的几种情况：</p><ul><li>程序正常执行结束；</li><li>程序在执行过程中遇到了异常或错误而异常终止；</li><li>由于操作系统出现错误而导致 Java 虚拟机进程终止；</li><li>某线程调用 Runtime 类或 System 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或者 halt 操作；</li><li>除此之外，JNI（Java Native Interface）规范中描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时 Java 虚拟机的退出情况。</li></ul><h2 id="JVM-发展历程"><a href="#JVM-发展历程" class="headerlink" title="JVM 发展历程"></a>JVM 发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ul><li>早在 1996 年 Java 1.0 版本的时候，Sun 公司发布了一款名为 Sun Classic VM 的 Java 虚拟机，它同时也是世界上第一款商用 Java 虚拟机，JDK 1.4 时完全被淘汰。</li><li>这款虚拟机内部只提供解释器。</li><li>如果使用 JIT 编译器，就需要进行外挂。但是一旦使用了 JIT 编译器，JIT 就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li><li>现在 HotSpot 内置了此虚拟机。</li></ul><h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><ul><li>为了解决上一个虚拟机问题，JDK 1.2 时，Sun 提供了此虚拟机；</li><li>Exact Memory Management: 准确式内存管理；<ul><li>也可以叫 Non-Conservative/Accurate Memory Management</li><li>虚拟机可以知道内存中某个位置的数据具体是什么类型</li></ul></li><li>具备现代高性能虚拟机的雏形<ul><li>热点探测</li><li>编译器与解释器混合工作模式</li></ul></li><li>只在 Solaris 平台短暂使用，其他平台上还是 Classic VM<ul><li>英雄气短，终被 HotSpot 虚拟机替换</li></ul></li></ul><h3 id="HotSpot"><a href="#HotSpot" class="headerlink" title="HotSpot"></a>HotSpot</h3><ul><li>HotSpot 历史<ul><li>最初由一家名为 Longview Technologies 的小公司设计</li><li>1997 年，此公司被 Sun 收购；2009 年，Sun 公司被 Oracle 收购</li><li>JDK 1.3 时，HotSpot VM 成为默认虚拟机</li></ul></li><li>目前 HotSpot 占有绝对的市场地位，称霸武林<ul><li>现在使用比较多的 JDK 8、JDK 11中默认的虚拟机是 HotSpot</li><li>Sun/Oracle JDk 和 OpenJDK 的默认虚拟机</li></ul></li><li>从服务端、桌面端、嵌入式都有应用</li><li>名称中的 HotSpot 指的就是它的热点代码探测技术<ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li><li>通过编译器与解释器协同工作，在最优的程序响应时间与最佳执行性能中取得平衡</li></ul></li></ul><h3 id="BEA-的-JRockit"><a href="#BEA-的-JRockit" class="headerlink" title="BEA 的 JRockit"></a>BEA 的 JRockit</h3><ul><li>专注于服务器应用<ul><li>它可以不太关注程序启动速度，因此 JRockit 内部不包含解释器实现，全部代码都是靠即时编译器编译后执行</li></ul></li><li>大量的行业基准测试显示，JRockit JVM 是世界上最快的 JVM。<ul><li>使用 JRockit 产品，客户已经体验带了显著的性能提高（一些超过了 70%）和硬件成本的减少（达50%）。</li></ul></li><li>优势：全面的 Java 运行时解决方案组合<ul><li>JRockit 面向延迟敏感型应用的解决方案 JRockit Real Time 提供以毫秒或微秒级的 JVM 响应时间，适合财务，军事指挥，电信网络的需要。</li><li>MissionControl 服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li></ul></li><li>2008年，BEA 被 Oracle 收购</li></ul><h3 id="IBM-的-J9"><a href="#IBM-的-J9" class="headerlink" title="IBM 的 J9"></a>IBM 的 J9</h3><ul><li>全称：IBM Technology for Java Virtual Machine，简称 IT4J，内部代号 J9</li><li>市场定位与 HotSpot 接近，服务端、桌面应用、嵌入式等多用途 VM</li><li>广泛应用于 IBM 的各种 Java 产品</li><li>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的虚拟机。</li><li>2017左右，IBM 发布了开源 J9 VM，命名为 OpenJ9，交给 Eclipse 基金会管理，也称为 Eclipse OpenJ9</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Java-生态圈&quot;&gt;&lt;a href=&quot;#Java-生态圈&quot; class=&quot;headerlink&quot; title=&quot;Java 生态圈&quot;&gt;&lt;/a&gt;Java 生态圈&lt;/h2&gt;&lt;p&gt;Java 是目前应用最为广泛的软件开发平台之一。随着 Java 以及 Java 社区的不断壮大，Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为一个平台：Java 虚拟机扮演着举足轻重的作用。&lt;ul&gt;
&lt;li&gt;Groovy、Scala、JRuby、Kotlin 等都是 Java 平台的一部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作为一种文化：Java 几乎成为了开源的代名词&lt;ul&gt;
&lt;li&gt;第三方开源软件和框架，如，Tomcat、Struts、MyBatis、Spring 等&lt;/li&gt;
&lt;li&gt;就连 JDK 和 JVM 自身也有不少开源的实现，如 OpenJDK、Harmony&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作为一个社区，Java 拥有全世界最多的技术拥护者和开源社区的支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到 Java 的身影。其应用形式之复杂、参与人数之众也令人咋舌。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JDK 16 正式发布！</title>
    <link href="http://yonghong.tech/release/jdk-16/"/>
    <id>http://yonghong.tech/release/jdk-16/</id>
    <published>2021-04-03T02:00:00.000Z</published>
    <updated>2021-04-03T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>JDK 16 在 2021 年 3 月 16 日正式发布了，这次发布的主要功能有：</p><ul><li>JEP 338: Vector API (Incubator)</li><li>JEP 347: Enable C++14 Language Features</li><li>JEP 357: Migrate from Mercurial to Git</li><li>JEP 369: Migrate to GitHub</li><li>JEP 376: ZGC: Concurrent Thread-Stack Processing</li><li>JEP 380: Unix-Domain Socket Channels</li><li>JEP 386: Alpine Linux Port</li><li>JEP 387: Elastic Metaspace</li><li>JEP 388: Windows/AArch64 Port</li><li>JEP 389: Foreign Linker API (Incubator)</li><li>JEP 390: Warnings for Value-Based Classes</li><li>JEP 392: Packaging Tool</li><li>JEP 393: Foreign-Memory Access API (Third Incubator)</li><li>JEP 394: Pattern Matching for instanceof</li><li>JEP 395: Records</li><li>JEP 396: Strongly Encapsulate JDK Internals by Default</li><li>JEP 397: Sealed Classes (Second Preview)</li></ul><span id="more"></span><hr><h3 id="JEP-338-Vector-API-Incubator"><a href="#JEP-338-Vector-API-Incubator" class="headerlink" title="JEP 338: Vector API (Incubator)"></a>JEP 338: Vector API (Incubator)</h3><p>Vector API 这是一个新的初始迭代孵化器模块，模块包：<code>jdk.incubator.vector</code>，用于表示在运行时可靠地编译到支持的 CPU 架构上的最佳矢量硬件指令的矢量计算。</p><h3 id="JEP-347-Enable-C-14-Language-Features"><a href="#JEP-347-Enable-C-14-Language-Features" class="headerlink" title="JEP 347: Enable C++14 Language Features"></a>JEP 347: Enable C++14 Language Features</h3><p>允许在 JDK 底层的 C ++ 源代码中使用 C ++ 14 的新语言特性，并且提供了在 HotSpot 虚拟机代码中，哪些代码使用了这些新特性的指南。</p><h3 id="JEP-357-Migrate-from-Mercurial-to-Git"><a href="#JEP-357-Migrate-from-Mercurial-to-Git" class="headerlink" title="JEP 357: Migrate from Mercurial to Git"></a>JEP 357: Migrate from Mercurial to Git</h3><p>将 OpenJDK 社区的源代码存储库从 Mercurial（hg）迁移到 Git。</p><h3 id="JEP-369-Migrate-to-GitHub"><a href="#JEP-369-Migrate-to-GitHub" class="headerlink" title="JEP 369: Migrate to GitHub"></a>JEP 369: Migrate to GitHub</h3><p>在 GitHub 上托管 OpenJDK 社区的 Git 存储库。</p><h3 id="JEP-376-ZGC-Concurrent-Thread-Stack-Processing"><a href="#JEP-376-ZGC-Concurrent-Thread-Stack-Processing" class="headerlink" title="JEP 376: ZGC: Concurrent Thread-Stack Processing"></a>JEP 376: ZGC: Concurrent Thread-Stack Processing</h3><p>ZGC 是一种较新的垃圾回收器，指在解决 HotSpot 虚拟机中的 GC 停顿及可伸缩问题。</p><p>ZGC 最早是在 JDK 11 中集成进来的，在 <a href="https://yonghong.tech/release/jdk-15/">JDK 15</a> 中正式转正。</p><p>这个版本则是为了让 ZGC 支持并发栈处理，解决了最后一个重大瓶颈，把 ZGC 中的线程栈处理从安全点移到了并发阶段。并且还提供了一种机制，使得其他 HotSpot 子系统可以通过该机制延迟处理线程栈。</p><h3 id="JEP-380-Unix-Domain-Socket-Channels"><a href="#JEP-380-Unix-Domain-Socket-Channels" class="headerlink" title="JEP 380: Unix-Domain Socket Channels"></a>JEP 380: Unix-Domain Socket Channels</h3><p>UNIX 域套接字通道，为 <code>java.nio.channels</code> 包中的套接字通道和服务端套接字通道 APIs 增加 Unix 域套接字通道所有特性支持。</p><p>UNIX 域套接字主要用于同一主机上的进程间通信（IPC），大部分方面与 TCP/IP套接字类似，不同的是 UNIX 域套接字是通过文件系统路径名寻址，而不是通过 IP 地址和端口号。</p><h3 id="JEP-386-Alpine-Linux-Port"><a href="#JEP-386-Alpine-Linux-Port" class="headerlink" title="JEP 386: Alpine Linux Port"></a>JEP 386: Alpine Linux Port</h3><p>在 x64 和 AArch64 平台体系结构上，将 JDK 移植到 Alpine Linux 以及使用 musl 作为其主要 C 语言库的其他 Linux 发行版中。</p><h3 id="JEP-387-Elastic-Metaspace"><a href="#JEP-387-Elastic-Metaspace" class="headerlink" title="JEP 387: Elastic Metaspace"></a>JEP 387: Elastic Metaspace</h3><p>弹性的元空间，可以帮助 HotSpot 虚拟机，将元空间中未使用的 class 元数据内存更及时地返回给操作系统，以减少元空间的内存占用空间。</p><p>另外，还简化了元空间的代码，以降低维护成本。</p><h3 id="JEP-388-Windows-AArch64-Port"><a href="#JEP-388-Windows-AArch64-Port" class="headerlink" title="JEP 388: Windows/AArch64 Port"></a>JEP 388: Windows/AArch64 Port</h3><p>将 JDK 移植到 Windows/ AArch64 平台系列。</p><h3 id="JEP-389-Foreign-Linker-API-Incubator"><a href="#JEP-389-Foreign-Linker-API-Incubator" class="headerlink" title="JEP 389: Foreign Linker API (Incubator)"></a>JEP 389: Foreign Linker API (Incubator)</h3><p>引入了一个新的 API，该 API 提供了对本地 native 代码的静态类型访问支持。</p><h3 id="JEP-390-Warnings-for-Value-Based-Classes"><a href="#JEP-390-Warnings-for-Value-Based-Classes" class="headerlink" title="JEP 390: Warnings for Value-Based Classes"></a>JEP 390: Warnings for Value-Based Classes</h3><p>基于值的类的警告，将基础类型包装类指定为基于值的类，废除其构造函数以进行删除，从而提示新的弃用警告。并且提供了在任何基于值的类的实例上不正常进行同步的警告。</p><h3 id="JEP-392-Packaging-Tool"><a href="#JEP-392-Packaging-Tool" class="headerlink" title="JEP 392: Packaging Tool"></a>JEP 392: Packaging Tool</h3><p>提供了 jpackage 打包工具，可用于打包独立的 Java 应用程序。</p><p>jpackage 打包工具是在 JDK 14 中首次作为孵化工具引入的新特性，到了 JDK 15 它仍然还在孵化中，现在它终于转正了。</p><h3 id="JEP-393-Foreign-Memory-Access-API-Third-Incubator"><a href="#JEP-393-Foreign-Memory-Access-API-Third-Incubator" class="headerlink" title="JEP 393: Foreign-Memory Access API (Third Incubator)"></a>JEP 393: Foreign-Memory Access API (Third Incubator)</h3><p>外部内存访问 API（三次孵化中），引入了一个新的 API，可以帮助 Java 应用程序更安全、有效地访问 Java 堆之外的外部内存。</p><p>这个最早在 JDK 14 中成为孵化特性，JDK 15/ JDK 16 中继续二、三次孵化并对其 API 有了一些更新，这个可以在 JDK 17 中好好期待一下转正。</p><h3 id="JEP-394-Pattern-Matching-for-instanceof"><a href="#JEP-394-Pattern-Matching-for-instanceof" class="headerlink" title="JEP 394: Pattern Matching for instanceof"></a>JEP 394: Pattern Matching for instanceof</h3><p>模式匹配 for instanceof，相当于是增强的 instanceof，在 JDK 14 中首次成为预览特性，在 JDK 16 中正式转正。</p><p>模式匹配的到来将使得 instanceof 变得更简洁、更安全，为什么这么说，请看下面的示例。</p><p>正常的 instanceof 写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> IPad) &#123;</span><br><span class="line">    IPad iPad = (IPad) object;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> IPhone) &#123;</span><br><span class="line">    IPhone iPhone = (IPhone) object;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模式匹配的 instanceof 写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> IPad iPad) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> IPhone iPhone) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断、赋值一步到位。</p><h3 id="JEP-395-Records"><a href="#JEP-395-Records" class="headerlink" title="JEP 395: Records"></a>JEP 395: Records</h3><p>简单来说，Records 就是一种新的语法糖，目的还是为了简化代码，在 JDK 14 中首次成为预览特性，在 JDK 16 中正式转正。</p><p>Records 可以在一定程度上避免低级冗余的代码，比如：constructors, getters, equals(), hashCode(), toString() 方法等，相当于 Lombok 的 @Data 注解，但又不能完全替代。</p><h3 id="JEP-396-Strongly-Encapsulate-JDK-Internals-by-Default"><a href="#JEP-396-Strongly-Encapsulate-JDK-Internals-by-Default" class="headerlink" title="JEP 396: Strongly Encapsulate JDK Internals by Default"></a>JEP 396: Strongly Encapsulate JDK Internals by Default</h3><p>JDK 内部默认强封装，JDK 16 开始对 JDK 内部大部分元素默认进行强封装，sun.misc.Unsafe 之类的关键内部 API 除外，从而限制对它们的访问。</p><p>此外，用户仍然可以选择自 JDK 9 以来的默认的宽松的强封装，这样可以帮助用户毫不费力地升级到未来的 Java 版本。</p><h3 id="JEP-397-Sealed-Classes-Second-Preview"><a href="#JEP-397-Sealed-Classes-Second-Preview" class="headerlink" title="JEP 397: Sealed Classes (Second Preview)"></a>JEP 397: Sealed Classes (Second Preview)</h3><p>封闭类（二次预览），可以是封闭类和或者封闭接口，用来增强 Java 编程语言，防止其他类或接口扩展或实现它们。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>官方日志：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L3Byb2plY3RzL2pkay8xNi8=">https://openjdk.java.net/projects/jdk/16/<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qZGsuamF2YS5uZXQvMTYvcmVsZWFzZS1ub3Rlcw==">https://jdk.java.net/16/release-notes<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;JDK 16 在 2021 年 3 月 16 日正式发布了，这次发布的主要功能有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JEP 338: Vector API (Incubator)&lt;/li&gt;
&lt;li&gt;JEP 347: Enable C++14 Language Features&lt;/li&gt;
&lt;li&gt;JEP 357: Migrate from Mercurial to Git&lt;/li&gt;
&lt;li&gt;JEP 369: Migrate to GitHub&lt;/li&gt;
&lt;li&gt;JEP 376: ZGC: Concurrent Thread-Stack Processing&lt;/li&gt;
&lt;li&gt;JEP 380: Unix-Domain Socket Channels&lt;/li&gt;
&lt;li&gt;JEP 386: Alpine Linux Port&lt;/li&gt;
&lt;li&gt;JEP 387: Elastic Metaspace&lt;/li&gt;
&lt;li&gt;JEP 388: Windows/AArch64 Port&lt;/li&gt;
&lt;li&gt;JEP 389: Foreign Linker API (Incubator)&lt;/li&gt;
&lt;li&gt;JEP 390: Warnings for Value-Based Classes&lt;/li&gt;
&lt;li&gt;JEP 392: Packaging Tool&lt;/li&gt;
&lt;li&gt;JEP 393: Foreign-Memory Access API (Third Incubator)&lt;/li&gt;
&lt;li&gt;JEP 394: Pattern Matching for instanceof&lt;/li&gt;
&lt;li&gt;JEP 395: Records&lt;/li&gt;
&lt;li&gt;JEP 396: Strongly Encapsulate JDK Internals by Default&lt;/li&gt;
&lt;li&gt;JEP 397: Sealed Classes (Second Preview)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="release" scheme="http://yonghong.tech/categories/release/"/>
    
    
    <category term="JDK" scheme="http://yonghong.tech/tags/JDK/"/>
    
    <category term="Java" scheme="http://yonghong.tech/tags/Java/"/>
    
    <category term="release" scheme="http://yonghong.tech/tags/release/"/>
    
    <category term="ZGC" scheme="http://yonghong.tech/tags/ZGC/"/>
    
    <category term="GitHub" scheme="http://yonghong.tech/tags/GitHub/"/>
    
    <category term="Vector" scheme="http://yonghong.tech/tags/Vector/"/>
    
    <category term="Metaspace" scheme="http://yonghong.tech/tags/Metaspace/"/>
    
    <category term="Sealed" scheme="http://yonghong.tech/tags/Sealed/"/>
    
    <category term="instanceof" scheme="http://yonghong.tech/tags/instanceof/"/>
    
  </entry>
  
  <entry>
    <title>【macOS 命令】scutil</title>
    <link href="http://yonghong.tech/macos-command/scutil/"/>
    <id>http://yonghong.tech/macos-command/scutil/</id>
    <published>2021-03-29T12:00:00.000Z</published>
    <updated>2021-03-29T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>管理系统配置参数。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>对系统的用户名和主机名进行修改</p><ul><li>ComputerName 就是电脑名称，给人看的（在下图中，电脑名称）</li><li>HostName 主机名，但通常不会设置这个值</li><li>LocalHostName 主机名，和 Linux 系统的 hostname 一样（在下图中，本地网络中电脑名称）</li></ul><span id="more"></span><p><img src="https://up-img.yonghong.tech/pic/2021/03/29-20-27-%E6%88%AA%E5%B1%8F2021-03-29%20%E4%B8%8B%E5%8D%888.27.22-EnugWj.png" alt="电脑名称、主机名设置"></p><p>hostname 命令取值的顺序：</p><ul><li>hostname 命令设置的值</li><li>HostName 属性值</li><li>LocalHostName 属性值（通常系统都会设置此属性）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看系统主机名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scutil --get ComputerName</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scutil --get HostName</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scutil --get LocalHostName</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改系统主机名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scutil --<span class="built_in">set</span> ComputerName xxx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scutil --<span class="built_in">set</span> HostName xxx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scutil --<span class="built_in">set</span> LocalHostName xxx</span></span><br></pre></td></tr></table></figure><p>查看 DNS 配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scutil --dns</span></span><br></pre></td></tr></table></figure><p>查看代理信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scutil --proxy</span></span><br></pre></td></tr></table></figure><p>查看网络信息（ipv4/ipv6）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scutil --nwi</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;管理系统配置参数。&lt;/p&gt;
&lt;h2 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot; title=&quot;用法&quot;&gt;&lt;/a&gt;用法&lt;/h2&gt;&lt;p&gt;对系统的用户名和主机名进行修改&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ComputerName 就是电脑名称，给人看的（在下图中，电脑名称）&lt;/li&gt;
&lt;li&gt;HostName 主机名，但通常不会设置这个值&lt;/li&gt;
&lt;li&gt;LocalHostName 主机名，和 Linux 系统的 hostname 一样（在下图中，本地网络中电脑名称）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="macOS 命令" scheme="http://yonghong.tech/categories/macOS-%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="macOS 命令" scheme="http://yonghong.tech/tags/macOS-%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>MySQL update 语句 set 顺序</title>
    <link href="http://yonghong.tech/2021/03/mysql-update-set-order/"/>
    <id>http://yonghong.tech/2021/03/mysql-update-set-order/</id>
    <published>2021-03-01T14:24:00.000Z</published>
    <updated>2021-03-01T14:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>绝大多数数据库，在执行 update 语句时，update t set a = b, b = a 便可实现 a、b 列值互换，赋值表达式右侧的值取的都是原始值。MySQL 则是例外，其单表更新是自左到右依次完成，即先完成 a = b，然后在完成 b = a (此时 a = b），所以执行结果变成 a、b 列都是 b，然后多表更新则又不尊从该更新法则。</p><p>这个问题源于业务中一次对券有效期进行延期的操作，需求是对优惠券有效期延期 35 天。</p><ul><li>一部分券在生效中，直接修改过期时间即可；</li><li>一部分券已经过期，修改过期时间后，需要判断一下是否仍然是过期的还是生效中的，修改券的状态</li></ul><span id="more"></span><p>所以 SQL 语句大致如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPDATE coupon </span><br><span class="line"><span class="keyword">SET</span> end_time <span class="operator">=</span> DATE_ADD(end_time, <span class="type">INTERVAL</span> <span class="number">35</span> <span class="keyword">DAY</span>), </span><br><span class="line">status <span class="operator">=</span> (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> end_time <span class="operator">&gt;</span> NOW() <span class="keyword">THEN</span> <span class="string">&#x27;生效中&#x27;</span> <span class="keyword">ELSE</span> <span class="string">&#x27;已过期&#x27;</span> <span class="keyword">END</span>), </span><br><span class="line">gmt_modify <span class="operator">=</span> NOW() </span><br><span class="line"><span class="keyword">WHERE</span> ... ;</span><br></pre></td></tr></table></figure><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>这个地方就有个问题，当修改 status 的时候 end_time 到底是原始数据，还是修改后的数据。经过测试，是使用的修改后的数据，接下来去 MySQL 官网中求证一下。</p><h2 id="MySQL-官方文档的说明"><a href="#MySQL-官方文档的说明" class="headerlink" title="MySQL 官方文档的说明"></a>MySQL 官方文档的说明</h2><p>MySQL 官网文档中是这样描述的，当你要更新一个列的时候，UPDATE 语句使用的是这列值的当前值。举个例子：下面这个语句从左到右顺序执行，先执行 col1 = col + 1，此时 col1 已经是加 1 后的值了，执行 col2 = col1 的时候，也是加 1 后的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE t1 <span class="keyword">SET</span> col1 <span class="operator">=</span> col1 <span class="operator">+</span> <span class="number">1</span>, col2 <span class="operator">=</span> col1;</span><br></pre></td></tr></table></figure><p><strong>但是，这个规则只适用于单表的 UPDATE，多表就不适用于这个规则了，多表更新，赋值语句不确保任何给定的顺序执行，可能是原值，也可能是新值。</strong></p><h2 id="MySQL-如何实现两列互换"><a href="#MySQL-如何实现两列互换" class="headerlink" title="MySQL 如何实现两列互换"></a>MySQL 如何实现两列互换</h2><p>编程语言中，实现两个变量互换很简单：引入临时变量 tmp，tmp = a，a = b，b = tmp 即可实现 a、b 互换，但是 SQL 中没有临时变量，又如何实现变量互换呢？解决方案还是使用临时变量（只不过临时变量是某数据列的值，然后后面再覆盖该数据列的值），假设有 a b 列，a = 100，b = 1，实现 a b 互换，我们可以使用通用手法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">=</span> a <span class="operator">+</span> b, <span class="number">101</span></span><br><span class="line">b <span class="operator">=</span> a <span class="operator">-</span> b, <span class="number">100</span></span><br><span class="line">a <span class="operator">=</span> a <span class="operator">-</span> b, <span class="number">1</span></span><br></pre></td></tr></table></figure><p>至此，a = 1, b = 100，实现 a、b 值互换，SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update t <span class="keyword">set</span> a <span class="operator">=</span> a <span class="operator">+</span> b, b <span class="operator">=</span> a <span class="operator">-</span> b, a <span class="operator">=</span> a <span class="operator">-</span> b;</span><br></pre></td></tr></table></figure><h2 id="MySQL-多表更新的例子"><a href="#MySQL-多表更新的例子" class="headerlink" title="MySQL 多表更新的例子"></a>MySQL 多表更新的例子</h2><p>两张表：pur_po_bill_detail（采购单细表），wm_sh_bill_detail（收货单细表），采购后，先根据采购单细表创建收货单，然后根据收货单入库。</p><p><strong>pur_po_bill_detail（采购单细表）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `pur_po_bill_detail` (</span><br><span class="line">  `sid` <span class="type">int</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `bill_id` <span class="type">bigint</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;po单号id&#x27;</span>,</span><br><span class="line">  `bill_no` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单号&#x27;</span>,</span><br><span class="line">  `pw_count` <span class="type">decimal</span>(<span class="number">20</span>,<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;已入库数量&#x27;</span>,</span><br><span class="line">  `th_count` <span class="type">decimal</span>(<span class="number">20</span>,<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;不合格数量&#x27;</span>,</span><br><span class="line">  `bill_status` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`sid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;采购订单细表&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>wm_sh_bill_detail（收货单细表）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `wm_sh_bill_detail` (</span><br><span class="line">  `sid` <span class="type">int</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `bill_id` <span class="type">bigint</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;收货单id&#x27;</span>,</span><br><span class="line">  `bill_no` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ref_number` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> <span class="string">&#x27;采购单号&#x27;</span>,</span><br><span class="line">  `ref_detail_sid` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> <span class="string">&#x27;采购单行项目sid&#x27;</span>,</span><br><span class="line">  `sh_count` <span class="type">decimal</span>(<span class="number">20</span>,<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `in_count` <span class="type">decimal</span>(<span class="number">20</span>,<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `left_count` <span class="type">decimal</span>(<span class="number">20</span>,<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  ...</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY (`sid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;收货单细表&#x27;</span></span><br></pre></td></tr></table></figure><p>下述sql是在收货单入库时反写采购单细表入库数量、状态。</p><p>当采购单行项目：入库数量 + 不合格退货数量 &gt;= 订单数量，状态变成已入库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPDATE pur_po_bill_detail t0, wm_sh_bill_detail t1</span><br><span class="line"><span class="keyword">set</span> t0.pw_count <span class="operator">=</span> <span class="built_in">coalesce</span>(t0.pw_count,<span class="number">0</span>) <span class="operator">+</span> t1.in_count, </span><br><span class="line">t0.th_count <span class="operator">=</span> <span class="built_in">coalesce</span>(t0.th_count,<span class="number">0</span>) <span class="operator">+</span> <span class="built_in">coalesce</span>(t1.left_count,<span class="number">0</span>),</span><br><span class="line">t0.bill_status <span class="operator">=</span> <span class="keyword">case</span> <span class="keyword">when</span> t0.pw_count <span class="operator">+</span> t0.th_count <span class="operator">&gt;=</span> t0.goods_count <span class="keyword">then</span> <span class="string">&#x27;已入库&#x27;</span> <span class="keyword">else</span> t0.bill_status <span class="keyword">end</span></span><br><span class="line"><span class="keyword">WHERE</span> t0.sid <span class="operator">=</span> t1.ref_detail_sid <span class="keyword">and</span> t1.bill_no <span class="operator">=</span> <span class="string">&#x27;SH20180001&#x27;</span>;</span><br></pre></td></tr></table></figure><p>sql执行结果失败，系mysql多表更新，在case判断时，t0.pw_count, t0.th_count取到的是原值。所以mysql多表更新需要注意：</p><p>赋值语句、case语句尽量避免依赖引用，如本案case使用了赋值语句pw_count,th_count列，所以判断就出问题啦；可通过update语句拆分来实现多表复杂更新目标。</p><p>上述update语句拆分，先更新数量，然后更新状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UPDATE pur_po_bill_detail t0, wm_sh_bill_detail t1</span><br><span class="line"><span class="keyword">set</span> t0.pw_count <span class="operator">=</span> <span class="built_in">coalesce</span>(t0.pw_count,<span class="number">0</span>) <span class="operator">+</span> t1.in_count, </span><br><span class="line">t0.th_count <span class="operator">=</span> <span class="built_in">coalesce</span>(t0.th_count,<span class="number">0</span>) <span class="operator">+</span> <span class="built_in">coalesce</span>(t1.left_count,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">WHERE</span> t0.sid <span class="operator">=</span> t1.ref_detail_sid <span class="keyword">and</span> t1.bill_no <span class="operator">=</span> <span class="string">&#x27;SH20180001&#x27;</span>;</span><br><span class="line"></span><br><span class="line">UPDATE pur_po_bill_detail t0, wm_sh_bill_detail t1</span><br><span class="line"><span class="keyword">set</span> t0.bill_status <span class="operator">=</span> <span class="keyword">case</span> <span class="keyword">when</span> t0.pw_count <span class="operator">+</span> t0.th_count <span class="operator">&gt;=</span> t0.goods_count <span class="keyword">then</span> <span class="string">&#x27;已入库&#x27;</span> <span class="keyword">else</span> t0.bill_status <span class="keyword">end</span></span><br><span class="line"><span class="keyword">WHERE</span> t0.sid <span class="operator">=</span> t1.ref_detail_sid <span class="keyword">and</span> t1.bill_no <span class="operator">=</span> <span class="string">&#x27;SH20180001&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="再次回到业务中来"><a href="#再次回到业务中来" class="headerlink" title="再次回到业务中来"></a>再次回到业务中来</h2><p>再次回到业务场景中来，如果采用券的过期时间全部更新这种方式的话，先执行 end_time 延期，再去判断是否过期，这个时候使用的 end_time 已经是修改过的了。</p><p>其实这种更新方式也没有必要，如果券延期后还是过期的，那么其实也可以不更新券的有效期，那么 SQL 就变成了下面这样的。先过滤出延期后是生效状态的券，在进行更新。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UPDATE coupon </span><br><span class="line"><span class="keyword">SET</span> end_time <span class="operator">=</span> DATE_ADD(end_time, <span class="type">INTERVAL</span> <span class="number">35</span> <span class="keyword">DAY</span>), </span><br><span class="line">status <span class="operator">=</span> <span class="string">&#x27;生效中&#x27;</span>, </span><br><span class="line">gmt_modify <span class="operator">=</span> NOW() </span><br><span class="line"><span class="keyword">WHERE</span> ... </span><br><span class="line"><span class="keyword">AND</span> DATE_ADD(end_time, <span class="type">INTERVAL</span> <span class="number">35</span> <span class="keyword">DAY</span>) <span class="operator">&gt;</span> NOW() ;</span><br></pre></td></tr></table></figure><h2 id="MySQL-官方文档原文"><a href="#MySQL-官方文档原文" class="headerlink" title="MySQL 官方文档原文"></a>MySQL 官方文档原文</h2><p>If you access a column from the table to be updated in an expression, <a href="https://dev.mysql.com/doc/refman/8.0/en/update.html"><code>UPDATE</code></a> uses the current value of the column. For example, the following statement sets <code>col1</code> to one more than its current value:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE t1 <span class="keyword">SET</span> col1 <span class="operator">=</span> col1 <span class="operator">+</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>The second assignment in the following statement sets <code>col2</code> to the current (updated) <code>col1</code> value, not the original <code>col1</code> value. The result is that <code>col1</code> and <code>col2</code> have the same value. This behavior differs from standard SQL.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE t1 <span class="keyword">SET</span> col1 <span class="operator">=</span> col1 <span class="operator">+</span> <span class="number">1</span>, col2 <span class="operator">=</span> col1;</span><br></pre></td></tr></table></figure><p>Single-table <a href="https://dev.mysql.com/doc/refman/8.0/en/update.html"><code>UPDATE</code></a> assignments are generally evaluated from left to right. For multiple-table updates, there is no guarantee that assignments are carried out in any particular order.</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NodWFuZ3hpbi9hcnRpY2xlL2RldGFpbHMvODQ1NTgwNTA=">谈谈mysql update语句 set顺序问题、列交换sql实现及多表更新注意事项<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vNS43L2VuL3VwZGF0ZS5odG1s">https://dev.mysql.com/doc/refman/5.7/en/update.html<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL3VwZGF0ZS5odG1s">https://dev.mysql.com/doc/refman/8.0/en/update.html<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;绝大多数数据库，在执行 update 语句时，update t set a = b, b = a 便可实现 a、b 列值互换，赋值表达式右侧的值取的都是原始值。MySQL 则是例外，其单表更新是自左到右依次完成，即先完成 a = b，然后在完成 b = a (此时 a = b），所以执行结果变成 a、b 列都是 b，然后多表更新则又不尊从该更新法则。&lt;/p&gt;
&lt;p&gt;这个问题源于业务中一次对券有效期进行延期的操作，需求是对优惠券有效期延期 35 天。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一部分券在生效中，直接修改过期时间即可；&lt;/li&gt;
&lt;li&gt;一部分券已经过期，修改过期时间后，需要判断一下是否仍然是过期的还是生效中的，修改券的状态&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://yonghong.tech/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://yonghong.tech/tags/MySQL/"/>
    
    <category term="UPDATE" scheme="http://yonghong.tech/tags/UPDATE/"/>
    
    <category term="数据库" scheme="http://yonghong.tech/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>如何在macOS根目录创建文件夹</title>
    <link href="http://yonghong.tech/2021/02/create-folder-in-macos-root/"/>
    <id>http://yonghong.tech/2021/02/create-folder-in-macos-root/</id>
    <published>2021-02-27T02:24:00.000Z</published>
    <updated>2021-02-27T02:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在短短的两个月里，已经遇到了 2 次这个问题，第 1 次是 macOS@Catalina 版本，第 2 次是升级后的 macOS@Big Sur 版本，在这里记录一下解决办法。</p><h2 id="macOS-Catalina-版本"><a href="#macOS-Catalina-版本" class="headerlink" title="macOS@Catalina 版本"></a>macOS@Catalina 版本</h2><p>重启系统进入恢复模式，关闭 SIP，重启后命令行执行下面这行代码，再创建文件夹就能成功了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -uw /</span><br></pre></td></tr></table></figure><h2 id="macOS-Big-Sur-版本"><a href="#macOS-Big-Sur-版本" class="headerlink" title="macOS@Big Sur 版本"></a>macOS@Big Sur 版本</h2><p>重启系统进入恢复模式，关闭 SIP（不确定有没有这个步骤，如果有人尝试可以评论一下），接下来稍稍麻烦一点，修改 /etc/synthetic.conf 文件</p><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/synthetic.conf</span><br></pre></td></tr></table></figure><p>输入如下内容，data 换成你要创建的文件夹，后面是映射目录，注意，中间是 Tab，不是空格</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data    /private/data</span><br></pre></td></tr></table></figure><p>重启系统后，系统根目录出现了对应的文件夹，这个文件夹是一个软链接，链接到了前面写的映射目录中。</p><p>如图，我在我电脑根目录下创建了一个 home 文件夹的软链接，实际存储在 /private/home 这个文件夹中。</p><p><img src="https://up-img.yonghong.tech/pic/2021/02/27-12-28-%E6%88%AA%E5%B1%8F2021-02-26%20%E4%B8%8B%E5%8D%888.41.34-ovojux.png" alt="根目录下的home文件夹"></p><p>这是我的 /etc/synthetic.conf 文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cat /etc/synthetic.conf</span><br><span class="line">home/private/home</span><br></pre></td></tr></table></figure><h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9uZXdzbi5uZXQvc2F5L21hYy1iaWctc3VyLXJvb3QtcmVhZG9ubHkuaHRtbA==">Mac升级到big sur之后，根目录无法写入文件如何解决？<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zc3BhaS5jb20vcG9zdC81NTA2Ng==">macOS 开启或关闭 SIP<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zdXBwb3J0LmFwcGxlLmNvbS96aC1jbi9IVDIwMTMxNA==">关于基于 Intel 的 Mac 电脑上的 macOS 恢复功能<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在短短的两个月里，已经遇到了 2 次这个问题，第 1 次是 macOS@Catalina 版本，第 2 次是升级后的 macOS@Big Sur 版本，在这里记录一下解决办法。&lt;/p&gt;
&lt;h2 id=&quot;macOS-Catalina-版本&quot;&gt;&lt;a href=&quot;#macOS-Catalina-版本&quot; class=&quot;headerlink&quot; title=&quot;macOS@Catalina 版本&quot;&gt;&lt;/a&gt;macOS@Catalina 版本&lt;/h2&gt;&lt;p&gt;重启系统进入恢复模式，关闭 SIP，重启后命令行执行下面这行代码，再创建文件夹就能成功了。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo mount -uw /&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;macOS-Big-Sur-版本&quot;&gt;&lt;a href=&quot;#macOS-Big-Sur-版本&quot; class=&quot;headerlink&quot; title=&quot;macOS@Big Sur 版本&quot;&gt;&lt;/a&gt;macOS@Big Sur 版本&lt;/h2&gt;&lt;p&gt;重启系统进入恢复模式，关闭 SIP（不确定有没有这个步骤，如果有人尝试可以评论一下），接下来稍稍麻烦一点，修改 /etc/synthetic.conf 文件&lt;/p&gt;</summary>
    
    
    
    <category term="macOS" scheme="http://yonghong.tech/categories/macOS/"/>
    
    
    <category term="macOS" scheme="http://yonghong.tech/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>JVM 指令集对照表</title>
    <link href="http://yonghong.tech/2021/01/jvm-instruction-set/"/>
    <id>http://yonghong.tech/2021/01/jvm-instruction-set/</id>
    <published>2021-01-07T02:24:00.000Z</published>
    <updated>2021-01-07T02:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java Virtual Machine Specification 中，有对 JVM 指令集的详细描述，可以打开链接查看：</p><ul><li>Java 11：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2UxMS9odG1sL2p2bXMtNi5odG1s">https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html<i class="fa fa-external-link-alt"></i></span></li><li>Java 8：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWw=">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html<i class="fa fa-external-link-alt"></i></span></li></ul><p>也有人整理了一个对照表，记录在下面</p><span id="more"></span><table><thead><tr><th align="center">字节码</th><th align="center">助记符</th><th>指令含义</th></tr></thead><tbody><tr><td align="center">0x00</td><td align="center">nop</td><td>None</td></tr><tr><td align="center">0x01</td><td align="center">aconst_null</td><td>将null推送至栈顶</td></tr><tr><td align="center">0x02</td><td align="center">iconst_m1</td><td>将int型-1推送至栈顶</td></tr><tr><td align="center">0x03</td><td align="center">iconst_0</td><td>将int型0推送至栈顶</td></tr><tr><td align="center">0x04</td><td align="center">iconst_1</td><td>将int型1推送至栈顶</td></tr><tr><td align="center">0x05</td><td align="center">iconst_2</td><td>将int型2推送至栈顶</td></tr><tr><td align="center">0x06</td><td align="center">iconst_3</td><td>将int型3推送至栈顶</td></tr><tr><td align="center">0x07</td><td align="center">iconst_4</td><td>将int型4推送至栈顶</td></tr><tr><td align="center">0x08</td><td align="center">iconst_5</td><td>将int型5推送至栈顶</td></tr><tr><td align="center">0x09</td><td align="center">lconst_0</td><td>将long型0推送至栈顶</td></tr><tr><td align="center">0x0a</td><td align="center">lconst_1</td><td>将long型1推送至栈顶</td></tr><tr><td align="center">0x0b</td><td align="center">fconst_0</td><td>将float型0推送至栈顶</td></tr><tr><td align="center">0x0c</td><td align="center">fconst_1</td><td>将float型1推送至栈顶</td></tr><tr><td align="center">0x0d</td><td align="center">fconst_2</td><td>将float型2推送至栈顶</td></tr><tr><td align="center">0x0e</td><td align="center">dconst_0</td><td>将double型0推送至栈顶</td></tr><tr><td align="center">0x0f</td><td align="center">dconst_1</td><td>将double型1推送至栈顶</td></tr><tr><td align="center">0x10</td><td align="center">bipush</td><td>将单字节的常量值(-128~127)推送至栈顶</td></tr><tr><td align="center">0x11</td><td align="center">sipush</td><td>将一个短整型常量(-32768~32767)推送至栈顶</td></tr><tr><td align="center">0x12</td><td align="center">ldc</td><td>将int,float或String型常量值从常量池中推送至栈顶</td></tr><tr><td align="center">0x13</td><td align="center">ldc_w</td><td>将int,float或String型常量值从常量池中推送至栈顶(宽索引)</td></tr><tr><td align="center">0x14</td><td align="center">ldc2_w</td><td>将long或double型常量值从常量池中推送至栈顶(宽索引)</td></tr><tr><td align="center">0x15</td><td align="center">iload</td><td>将指定的int型本地变量推送至栈顶</td></tr><tr><td align="center">0x16</td><td align="center">lload</td><td>将指定的long型本地变量推送至栈顶</td></tr><tr><td align="center">0x17</td><td align="center">fload</td><td>将指定的float型本地变量推送至栈顶</td></tr><tr><td align="center">0x18</td><td align="center">dload</td><td>将指定的double型本地变量推送至栈顶</td></tr><tr><td align="center">0x19</td><td align="center">aload</td><td>将指定的引用类型本地变量推送至栈顶</td></tr><tr><td align="center">0x1a</td><td align="center">iload_0</td><td>将第一个int型本地变量推送至栈顶</td></tr><tr><td align="center">0x1b</td><td align="center">iload_1</td><td>将第二个int型本地变量推送至栈顶</td></tr><tr><td align="center">0x1c</td><td align="center">iload_2</td><td>将第三个int型本地变量推送至栈顶</td></tr><tr><td align="center">0x1d</td><td align="center">iload_3</td><td>将第四个int型本地变量推送至栈顶</td></tr><tr><td align="center">0x1e</td><td align="center">lload_0</td><td>将第一个long型本地变量推送至栈顶</td></tr><tr><td align="center">0x1f</td><td align="center">lload_1</td><td>将第二个long型本地变量推送至栈顶</td></tr><tr><td align="center">0x20</td><td align="center">lload_2</td><td>将第三个long型本地变量推送至栈顶</td></tr><tr><td align="center">0x21</td><td align="center">lload_3</td><td>将第四个long型本地变量推送至栈顶</td></tr><tr><td align="center">0x22</td><td align="center">fload_0</td><td>将第一个float型本地变量推送至栈顶</td></tr><tr><td align="center">0x23</td><td align="center">fload_1</td><td>将第二个float型本地变量推送至栈顶</td></tr><tr><td align="center">0x24</td><td align="center">fload_2</td><td>将第三个float型本地变量推送至栈顶</td></tr><tr><td align="center">0x25</td><td align="center">fload_3</td><td>将第四个float型本地变量推送至栈顶</td></tr><tr><td align="center">0x26</td><td align="center">dload_0</td><td>将第一个double型本地变量推送至栈顶</td></tr><tr><td align="center">0x27</td><td align="center">dload_1</td><td>将第二个double型本地变量推送至栈顶</td></tr><tr><td align="center">0x28</td><td align="center">dload_2</td><td>将第三个double型本地变量推送至栈顶</td></tr><tr><td align="center">0x29</td><td align="center">dload_3</td><td>将第四个double型本地变量推送至栈顶</td></tr><tr><td align="center">0x2a</td><td align="center">aload_0</td><td>将第一个引用类型本地变量推送至栈顶</td></tr><tr><td align="center">0x2b</td><td align="center">aload_1</td><td>将第二个引用类型本地变量推送至栈顶</td></tr><tr><td align="center">0x2c</td><td align="center">aload_2</td><td>将第三个引用类型本地变量推送至栈顶</td></tr><tr><td align="center">0x2d</td><td align="center">aload_3</td><td>将第四个引用类型本地变量推送至栈顶</td></tr><tr><td align="center">0x2e</td><td align="center">iaload</td><td>将int型数组指定索引的值推送至栈顶</td></tr><tr><td align="center">0x2f</td><td align="center">laload</td><td>将long型数组指定索引的值推送至栈顶</td></tr><tr><td align="center">0x30</td><td align="center">faload</td><td>将float型数组指定索引的值推送至栈顶</td></tr><tr><td align="center">0x31</td><td align="center">daload</td><td>将double型数组指定索引的值推送至栈顶</td></tr><tr><td align="center">0x32</td><td align="center">aaload</td><td>将引用类型数组指定索引的值推送至栈顶</td></tr><tr><td align="center">0x33</td><td align="center">baload</td><td>将boolean或byte型数组指定索引的值推送至栈顶</td></tr><tr><td align="center">0x34</td><td align="center">caload</td><td>将char型数组指定索引的值推送至栈顶</td></tr><tr><td align="center">0x35</td><td align="center">saload</td><td>将short型数组指定索引的值推送至栈顶</td></tr><tr><td align="center">0x36</td><td align="center">istore</td><td>将栈顶int型数值存入指定本地变量</td></tr><tr><td align="center">0x37</td><td align="center">lstore</td><td>将栈顶long型数值存入指定本地变量</td></tr><tr><td align="center">0x38</td><td align="center">fstore</td><td>将栈顶float型数值存入指定本地变量</td></tr><tr><td align="center">0x39</td><td align="center">dstore</td><td>将栈顶double型数值存入指定本地变量</td></tr><tr><td align="center">0x3a</td><td align="center">astore</td><td>将栈顶引用类型数值存入指定本地变量</td></tr><tr><td align="center">0x3b</td><td align="center">istore_0</td><td>将栈顶int型数值存入第一个本地变量</td></tr><tr><td align="center">0x3c</td><td align="center">istore_1</td><td>将栈顶int型数值存入第二个本地变量</td></tr><tr><td align="center">0x3d</td><td align="center">istore_2</td><td>将栈顶int型数值存入第三个本地变量</td></tr><tr><td align="center">0x3e</td><td align="center">istore_3</td><td>将栈顶int型数值存入第四个本地变量</td></tr><tr><td align="center">0x3f</td><td align="center">lstore_0</td><td>将栈顶long型数值存入第一个本地变量</td></tr><tr><td align="center">0x40</td><td align="center">lstore_1</td><td>将栈顶long型数值存入第二个本地变量</td></tr><tr><td align="center">0x41</td><td align="center">lstore_2</td><td>将栈顶long型数值存入第三个本地变量</td></tr><tr><td align="center">0x42</td><td align="center">lstore_3</td><td>将栈顶long型数值存入第四个本地变量</td></tr><tr><td align="center">0x43</td><td align="center">fstore_0</td><td>将栈顶float型数值存入第一个本地变量</td></tr><tr><td align="center">0x44</td><td align="center">fstore_1</td><td>将栈顶float型数值存入第二个本地变量</td></tr><tr><td align="center">0x45</td><td align="center">fstore_2</td><td>将栈顶float型数值存入第三个本地变量</td></tr><tr><td align="center">0x46</td><td align="center">fstore_3</td><td>将栈顶float型数值存入第四个本地变量</td></tr><tr><td align="center">0x47</td><td align="center">dstore_0</td><td>将栈顶double型数值存入第一个本地变量</td></tr><tr><td align="center">0x48</td><td align="center">dstore_1</td><td>将栈顶double型数值存入第二个本地变量</td></tr><tr><td align="center">0x49</td><td align="center">dstore_2</td><td>将栈顶double型数值存入第三个本地变量</td></tr><tr><td align="center">0x4a</td><td align="center">dstore_3</td><td>将栈顶double型数值存入第四个本地变量</td></tr><tr><td align="center">0x4b</td><td align="center">astore_0</td><td>将栈顶引用型数值存入第一个本地变量</td></tr><tr><td align="center">0x4c</td><td align="center">astore_1</td><td>将栈顶引用型数值存入第二个本地变量</td></tr><tr><td align="center">0x4d</td><td align="center">astore_2</td><td>将栈顶引用型数值存入第三个本地变量</td></tr><tr><td align="center">0x4e</td><td align="center">astore_3</td><td>将栈顶引用型数值存入第四个本地变量</td></tr><tr><td align="center">0x4f</td><td align="center">iastore</td><td>将栈顶int型数值存入指定数组的指定索引位置</td></tr><tr><td align="center">0x50</td><td align="center">lastore</td><td>将栈顶long型数值存入指定数组的指定索引位置</td></tr><tr><td align="center">0x51</td><td align="center">fastore</td><td>将栈顶float型数值存入指定数组的指定索引位置</td></tr><tr><td align="center">0x52</td><td align="center">dastore</td><td>将栈顶double型数值存入指定数组的指定索引位置</td></tr><tr><td align="center">0x53</td><td align="center">aastore</td><td>将栈顶引用型数值存入指定数组的指定索引位置</td></tr><tr><td align="center">0x54</td><td align="center">bastore</td><td>将栈顶boolean或byte型数值存入指定数组的指定索引位置</td></tr><tr><td align="center">0x55</td><td align="center">castore</td><td>将栈顶char型数值存入指定数组的指定索引位置</td></tr><tr><td align="center">0x56</td><td align="center">sastore</td><td>将栈顶short型数值存入指定数组的指定索引位置</td></tr><tr><td align="center">0x57</td><td align="center">pop</td><td>将栈顶数值弹出(数值不能是long或double类型的)</td></tr><tr><td align="center">0x58</td><td align="center">pop2</td><td>将栈顶的一个(对于非long或double类型)或两个数值(对于非long或double的其他类型)弹出</td></tr><tr><td align="center">0x59</td><td align="center">dup</td><td>复制栈顶数值并将复制值压入栈顶</td></tr><tr><td align="center">0x5a</td><td align="center">dup_x1</td><td>复制栈顶数值并将两个复制值压入栈顶</td></tr><tr><td align="center">0x5b</td><td align="center">dup_x2</td><td>复制栈顶数值并将三个(或两个)复制值压入栈顶</td></tr><tr><td align="center">0x5c</td><td align="center">dup2</td><td>复制栈顶一个(对于long或double类型)或两个(对于非long或double的其他类型)数值并将复制值压入栈顶</td></tr><tr><td align="center">0x5d</td><td align="center">dup2_x1</td><td>dup_x1指令的双倍版本</td></tr><tr><td align="center">0x5e</td><td align="center">dup2_x2</td><td>dup_x2指令的双倍版本</td></tr><tr><td align="center">0x5f</td><td align="center">swap</td><td>将栈顶最顶端的两个数值互换(数值不能是long或double类型)</td></tr><tr><td align="center">0x60</td><td align="center">iadd</td><td>将栈顶两int型数值相加并将结果压入栈顶</td></tr><tr><td align="center">0x61</td><td align="center">ladd</td><td>将栈顶两long型数值相加并将结果压入栈顶</td></tr><tr><td align="center">0x62</td><td align="center">fadd</td><td>将栈顶两float型数值相加并将结果压入栈顶</td></tr><tr><td align="center">0x63</td><td align="center">dadd</td><td>将栈顶两double型数值相加并将结果压入栈顶</td></tr><tr><td align="center">0x64</td><td align="center">isub</td><td>将栈顶两int型数值相减并将结果压入栈顶</td></tr><tr><td align="center">0x65</td><td align="center">lsub</td><td>将栈顶两long型数值相减并将结果压入栈顶</td></tr><tr><td align="center">0x66</td><td align="center">fsub</td><td>将栈顶两float型数值相减并将结果压入栈顶</td></tr><tr><td align="center">0x67</td><td align="center">dsub</td><td>将栈顶两double型数值相减并将结果压入栈顶</td></tr><tr><td align="center">0x68</td><td align="center">imul</td><td>将栈顶两int型数值相乘并将结果压入栈顶</td></tr><tr><td align="center">0x69</td><td align="center">lmul</td><td>将栈顶两long型数值相乘并将结果压入栈顶</td></tr><tr><td align="center">0x6a</td><td align="center">fmul</td><td>将栈顶两float型数值相乘并将结果压入栈顶</td></tr><tr><td align="center">0x6b</td><td align="center">dmul</td><td>将栈顶两double型数值相乘并将结果压入栈顶</td></tr><tr><td align="center">0x6c</td><td align="center">idiv</td><td>将栈顶两int型数值相除并将结果压入栈顶</td></tr><tr><td align="center">0x6d</td><td align="center">ldiv</td><td>将栈顶两long型数值相除并将结果压入栈顶</td></tr><tr><td align="center">0x6e</td><td align="center">fdiv</td><td>将栈顶两float型数值相除并将结果压入栈顶</td></tr><tr><td align="center">0x6f</td><td align="center">ddiv</td><td>将栈顶两double型数值相除并将结果压入栈顶</td></tr><tr><td align="center">0x70</td><td align="center">irem</td><td>将栈顶两int型数值作取模运算并将结果压入栈顶</td></tr><tr><td align="center">0x71</td><td align="center">lrem</td><td>将栈顶两long型数值作取模运算并将结果压入栈顶</td></tr><tr><td align="center">0x72</td><td align="center">frem</td><td>将栈顶两float型数值作取模运算并将结果压入栈顶</td></tr><tr><td align="center">0x73</td><td align="center">drem</td><td>将栈顶两double型数值作取模运算并将结果压入栈顶</td></tr><tr><td align="center">0x74</td><td align="center">ineg</td><td>将栈顶int型数值取负并将结果压入栈顶</td></tr><tr><td align="center">0x75</td><td align="center">lneg</td><td>将栈顶long型数值取负并将结果压入栈顶</td></tr><tr><td align="center">0x76</td><td align="center">fneg</td><td>将栈顶float型数值取负并将结果压入栈顶</td></tr><tr><td align="center">0x77</td><td align="center">dneg</td><td>将栈顶double型数值取负并将结果压入栈顶</td></tr><tr><td align="center">0x78</td><td align="center">ishl</td><td>将int型数值左移指定位数并将结果压入栈顶</td></tr><tr><td align="center">0x79</td><td align="center">lshl</td><td>将long型数值左移指定位数并将结果压入栈顶</td></tr><tr><td align="center">0x7a</td><td align="center">ishr</td><td>将int型数值右(带符号)移指定位数并将结果压入栈顶</td></tr><tr><td align="center">0x7b</td><td align="center">lshr</td><td>将long型数值右(带符号)移指定位数并将结果压入栈顶</td></tr><tr><td align="center">0x7c</td><td align="center">iushr</td><td>将int型数值右(无符号)移指定位数并将结果压入栈顶</td></tr><tr><td align="center">0x7d</td><td align="center">lushr</td><td>将long型数值右(无符号)移指定位数并将结果压入栈顶</td></tr><tr><td align="center">0x7e</td><td align="center">iand</td><td>将栈顶两int型数值”按位与”并将结果压入栈顶</td></tr><tr><td align="center">0x7f</td><td align="center">land</td><td>将栈顶两long型数值”按位与”并将结果压入栈顶</td></tr><tr><td align="center">0x80</td><td align="center">ior</td><td>将栈顶两int型数值”按位或”并将结果压入栈顶</td></tr><tr><td align="center">0x81</td><td align="center">lor</td><td>将栈顶两long型数值”按位或”并将结果压入栈顶</td></tr><tr><td align="center">0x82</td><td align="center">ixor</td><td>将栈顶两int型数值”按位异或”并将结果压入栈顶</td></tr><tr><td align="center">0x83</td><td align="center">lxor</td><td>将栈顶两long型数值”按位异或”并将结果压入栈顶</td></tr><tr><td align="center">0x84</td><td align="center">iinc</td><td>将指定int型变量增加指定值(如i++, i–, i+=2等)</td></tr><tr><td align="center">0x85</td><td align="center">i2l</td><td>将栈顶int型数值强制转换为long型数值并将结果压入栈顶</td></tr><tr><td align="center">0x86</td><td align="center">i2f</td><td>将栈顶int型数值强制转换为float型数值并将结果压入栈顶</td></tr><tr><td align="center">0x87</td><td align="center">i2d</td><td>将栈顶int型数值强制转换为double型数值并将结果压入栈顶</td></tr><tr><td align="center">0x88</td><td align="center">l2i</td><td>将栈顶long型数值强制转换为int型数值并将结果压入栈顶</td></tr><tr><td align="center">0x89</td><td align="center">l2f</td><td>将栈顶long型数值强制转换为float型数值并将结果压入栈顶</td></tr><tr><td align="center">0x8a</td><td align="center">l2d</td><td>将栈顶long型数值强制转换为double型数值并将结果压入栈顶</td></tr><tr><td align="center">0x8b</td><td align="center">f2i</td><td>将栈顶float型数值强制转换为int型数值并将结果压入栈顶</td></tr><tr><td align="center">0x8c</td><td align="center">f2l</td><td>将栈顶float型数值强制转换为long型数值并将结果压入栈顶</td></tr><tr><td align="center">0x8d</td><td align="center">f2d</td><td>将栈顶float型数值强制转换为double型数值并将结果压入栈顶</td></tr><tr><td align="center">0x8e</td><td align="center">d2i</td><td>将栈顶double型数值强制转换为int型数值并将结果压入栈顶</td></tr><tr><td align="center">0x8f</td><td align="center">d2l</td><td>将栈顶double型数值强制转换为long型数值并将结果压入栈顶</td></tr><tr><td align="center">0x90</td><td align="center">d2f</td><td>将栈顶double型数值强制转换为float型数值并将结果压入栈顶</td></tr><tr><td align="center">0x91</td><td align="center">i2b</td><td>将栈顶int型数值强制转换为byte型数值并将结果压入栈顶</td></tr><tr><td align="center">0x92</td><td align="center">i2c</td><td>将栈顶int型数值强制转换为char型数值并将结果压入栈顶</td></tr><tr><td align="center">0x93</td><td align="center">i2s</td><td>将栈顶int型数值强制转换为short型数值并将结果压入栈顶</td></tr><tr><td align="center">0x94</td><td align="center">lcmp</td><td>比较栈顶两long型数值大小, 并将结果(1, 0或-1)压入栈顶</td></tr><tr><td align="center">0x95</td><td align="center">fcmpl</td><td>比较栈顶两float型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为NaN时, 将-1压入栈顶</td></tr><tr><td align="center">0x96</td><td align="center">fcmpg</td><td>比较栈顶两float型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为NaN时, 将1压入栈顶</td></tr><tr><td align="center">0x97</td><td align="center">dcmpl</td><td>比较栈顶两double型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为NaN时, 将-1压入栈顶</td></tr><tr><td align="center">0x98</td><td align="center">dcmpg</td><td>比较栈顶两double型数值大小, 并将结果(1, 0或-1)压入栈顶; 当其中一个数值为NaN时, 将1压入栈顶</td></tr><tr><td align="center">0x99</td><td align="center">ifeq</td><td>当栈顶int型数值等于0时跳转</td></tr><tr><td align="center">0x9a</td><td align="center">ifne</td><td>当栈顶int型数值不等于0时跳转</td></tr><tr><td align="center">0x9b</td><td align="center">iflt</td><td>当栈顶int型数值小于0时跳转</td></tr><tr><td align="center">0x9c</td><td align="center">ifge</td><td>当栈顶int型数值大于等于0时跳转</td></tr><tr><td align="center">0x9d</td><td align="center">ifgt</td><td>当栈顶int型数值大于0时跳转</td></tr><tr><td align="center">0x9e</td><td align="center">ifle</td><td>当栈顶int型数值小于等于0时跳转</td></tr><tr><td align="center">0x9f</td><td align="center">if_icmpeq</td><td>比较栈顶两int型数值大小, 当结果等于0时跳转</td></tr><tr><td align="center">0xa0</td><td align="center">if_icmpne</td><td>比较栈顶两int型数值大小, 当结果不等于0时跳转</td></tr><tr><td align="center">0xa1</td><td align="center">if_icmplt</td><td>比较栈顶两int型数值大小, 当结果小于0时跳转</td></tr><tr><td align="center">0xa2</td><td align="center">if_icmpge</td><td>比较栈顶两int型数值大小, 当结果大于等于0时跳转</td></tr><tr><td align="center">0xa3</td><td align="center">if_icmpgt</td><td>比较栈顶两int型数值大小, 当结果大于0时跳转</td></tr><tr><td align="center">0xa4</td><td align="center">if_icmple</td><td>比较栈顶两int型数值大小, 当结果小于等于0时跳转</td></tr><tr><td align="center">0xa5</td><td align="center">if_acmpeq</td><td>比较栈顶两引用型数值, 当结果相等时跳转</td></tr><tr><td align="center">0xa6</td><td align="center">if_acmpne</td><td>比较栈顶两引用型数值, 当结果不相等时跳转</td></tr><tr><td align="center">0xa7</td><td align="center">goto</td><td>无条件跳转</td></tr><tr><td align="center">0xa8</td><td align="center">jsr</td><td>跳转至指定的16位offset位置, 并将jsr的下一条指令地址压入栈顶</td></tr><tr><td align="center">0xa9</td><td align="center">ret</td><td>返回至本地变量指定的index的指令位置(一般与jsr或jsr_w联合使用)</td></tr><tr><td align="center">0xaa</td><td align="center">tableswitch</td><td>用于switch条件跳转, case值连续(可变长度指令)</td></tr><tr><td align="center">0xab</td><td align="center">lookupswitch</td><td>用于switch条件跳转, case值不连续(可变长度指令)</td></tr><tr><td align="center">0xac</td><td align="center">ireturn</td><td>从当前方法返回int</td></tr><tr><td align="center">0xad</td><td align="center">lreturn</td><td>从当前方法返回long</td></tr><tr><td align="center">0xae</td><td align="center">freturn</td><td>从当前方法返回float</td></tr><tr><td align="center">0xaf</td><td align="center">dreturn</td><td>从当前方法返回double</td></tr><tr><td align="center">0xb0</td><td align="center">areturn</td><td>从当前方法返回对象引用</td></tr><tr><td align="center">0xb1</td><td align="center">return</td><td>从当前方法返回void</td></tr><tr><td align="center">0xb2</td><td align="center">getstatic</td><td>获取指定类的静态域, 并将其压入栈顶</td></tr><tr><td align="center">0xb3</td><td align="center">putstatic</td><td>为指定类的静态域赋值</td></tr><tr><td align="center">0xb4</td><td align="center">getfield</td><td>获取指定类的实例域, 并将其压入栈顶</td></tr><tr><td align="center">0xb5</td><td align="center">putfield</td><td>为指定类的实例域赋值</td></tr><tr><td align="center">0xb6</td><td align="center">invokevirtual</td><td>调用实例方法</td></tr><tr><td align="center">0xb7</td><td align="center">invokespecial</td><td>调用超类构建方法, 实例初始化方法, 私有方法</td></tr><tr><td align="center">0xb8</td><td align="center">invokestatic</td><td>调用静态方法</td></tr><tr><td align="center">0xb9</td><td align="center">invokeinterface</td><td>调用接口方法</td></tr><tr><td align="center">0xba</td><td align="center">invokedynamic</td><td>调用动态方法</td></tr><tr><td align="center">0xbb</td><td align="center">new</td><td>创建一个对象, 并将其引用引用值压入栈顶</td></tr><tr><td align="center">0xbc</td><td align="center">newarray</td><td>创建一个指定的原始类型(如int, float, char等)的数组, 并将其引用值压入栈顶</td></tr><tr><td align="center">0xbd</td><td align="center">anewarray</td><td>创建一个引用型(如类, 接口, 数组)的数组, 并将其引用值压入栈顶</td></tr><tr><td align="center">0xbe</td><td align="center">arraylength</td><td>获取数组的长度值并压入栈顶</td></tr><tr><td align="center">0xbf</td><td align="center">athrow</td><td>将栈顶的异常抛出</td></tr><tr><td align="center">0xc0</td><td align="center">checkcast</td><td>检验类型转换, 检验未通过将抛出 ClassCastException</td></tr><tr><td align="center">0xc1</td><td align="center">instanceof</td><td>检验对象是否是指定类的实际, 如果是将1压入栈顶, 否则将0压入栈顶</td></tr><tr><td align="center">0xc2</td><td align="center">monitorenter</td><td>获得对象的锁, 用于同步方法或同步块</td></tr><tr><td align="center">0xc3</td><td align="center">monitorexit</td><td>释放对象的锁, 用于同步方法或同步块</td></tr><tr><td align="center">0xc4</td><td align="center">wide</td><td>扩展本地变量的宽度</td></tr><tr><td align="center">0xc5</td><td align="center">multianewarray</td><td>创建指定类型和指定维度的多维数组(执行该指令时, 操作栈中必须包含各维度的长度值), 并将其引用压入栈顶</td></tr><tr><td align="center">0xc6</td><td align="center">ifnull</td><td>为null时跳转</td></tr><tr><td align="center">0xc7</td><td align="center">ifnonnull</td><td>不为null时跳转</td></tr><tr><td align="center">0xc8</td><td align="center">goto_w</td><td>无条件跳转(宽索引)</td></tr><tr><td align="center">0xc9</td><td align="center">jsr_w</td><td>跳转至指定的32位offset位置, 并将jsr_w的下一条指令地址压入栈顶</td></tr></tbody></table><p>推荐阅读：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTkvMDkvMDUvamF2YS1ieXRlY29kZS1lbmhhbmNlbWVudC5odG1s">字节码增强技术探索 - 美团技术团队<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Java Virtual Machine Specification 中，有对 JVM 指令集的详细描述，可以打开链接查看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 11：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2UxMS9odG1sL2p2bXMtNi5odG1s&quot;&gt;https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Java 8：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy02Lmh0bWw=&quot;&gt;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也有人整理了一个对照表，记录在下面&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://yonghong.tech/categories/Java/"/>
    
    
    <category term="Java" scheme="http://yonghong.tech/tags/Java/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
    <category term="指令集" scheme="http://yonghong.tech/tags/%E6%8C%87%E4%BB%A4%E9%9B%86/"/>
    
    <category term="Instruction" scheme="http://yonghong.tech/tags/Instruction/"/>
    
  </entry>
  
  <entry>
    <title>hg clone 与 Mercurial</title>
    <link href="http://yonghong.tech/2021/01/mercurial/"/>
    <id>http://yonghong.tech/2021/01/mercurial/</id>
    <published>2021-01-06T14:24:00.000Z</published>
    <updated>2021-01-06T14:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mercurial是跨平台的分布式版本控制软件，主要由Python语言实现，但也包含用C语言实现的二进制比较工具。Mercurial一开始的主要运行平台是Linux，现在Mercurial已经移植到Windows、Mac OS X和大多数的类Unix系统中。Mercurial主要由命令行程序组成，现在也有了图形用户界面。对Mercurial的所有操作都由用不同的关键字作为参数调用程序“hg”来实现，Hg是参考水银的化学符号而取的名字。</p><p>Mercurial的主要设计目标包括高性能、可扩展性、分散性、完全分布式合作开发、能同时高效地处理纯文本和二进制文件，以及分支和合并功能，以此同时保持系统的简洁性[1]。Mercurial也包括一个集成的Web界面。</p><p>Mercurial的创建者和主要开发人员是Matt Mackal。其源代码采用GNU通用公共许可证第二版为授权，确保了Mercurial是一个自由软件。</p><span id="more"></span><h2 id="获取-Mercurial"><a href="#获取-Mercurial" class="headerlink" title="获取 Mercurial"></a>获取 Mercurial</h2><p>Mercurial 官方网站：<span class="exturl" data-url="aHR0cHM6Ly93d3cubWVyY3VyaWFsLXNjbS5vcmcv">https://www.mercurial-scm.org/<i class="fa fa-external-link-alt"></i></span></p><p>我们可以从官方网站上获取到软件安装包：<span class="exturl" data-url="aHR0cHM6Ly93d3cubWVyY3VyaWFsLXNjbS5vcmcvZG93bmxvYWRz">https://www.mercurial-scm.org/downloads<i class="fa fa-external-link-alt"></i></span></p><p>还可以根据系统选择合适安装方式安装命令行工具：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Debian/Ubuntu</span></span><br><span class="line"><span class="variable">$</span> apt<span class="literal">-get</span> install mercurial</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fedora</span></span><br><span class="line"><span class="variable">$</span> dnf install mercurial</span><br><span class="line"></span><br><span class="line"><span class="comment"># Gentoo</span></span><br><span class="line"><span class="variable">$</span> emerge mercurial</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mac OS (homebrew)</span></span><br><span class="line"><span class="variable">$</span> brew install mercurial</span><br><span class="line"></span><br><span class="line"><span class="comment"># FreeBSD</span></span><br><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> /usr/ports/devel/mercurial</span><br><span class="line"><span class="variable">$</span> make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># Solaris 11 Express</span></span><br><span class="line"><span class="variable">$</span> pkg install SUNWmercurial</span><br></pre></td></tr></table></figure><h2 id="使用-hg-命令行工具-clone-软件仓库"><a href="#使用-hg-命令行工具-clone-软件仓库" class="headerlink" title="使用 hg 命令行工具 clone 软件仓库"></a>使用 hg 命令行工具 clone 软件仓库</h2><p>比如 OpenJDK 的软件仓库：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hg clone https:<span class="regexp">//</span>hg.openjdk.java.net<span class="regexp">/jdk/</span>jdk11</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mercurial是跨平台的分布式版本控制软件，主要由Python语言实现，但也包含用C语言实现的二进制比较工具。Mercurial一开始的主要运行平台是Linux，现在Mercurial已经移植到Windows、Mac OS X和大多数的类Unix系统中。Mercurial主要由命令行程序组成，现在也有了图形用户界面。对Mercurial的所有操作都由用不同的关键字作为参数调用程序“hg”来实现，Hg是参考水银的化学符号而取的名字。&lt;/p&gt;
&lt;p&gt;Mercurial的主要设计目标包括高性能、可扩展性、分散性、完全分布式合作开发、能同时高效地处理纯文本和二进制文件，以及分支和合并功能，以此同时保持系统的简洁性[1]。Mercurial也包括一个集成的Web界面。&lt;/p&gt;
&lt;p&gt;Mercurial的创建者和主要开发人员是Matt Mackal。其源代码采用GNU通用公共许可证第二版为授权，确保了Mercurial是一个自由软件。&lt;/p&gt;</summary>
    
    
    
    <category term="版本控制" scheme="http://yonghong.tech/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
    <category term="hg" scheme="http://yonghong.tech/tags/hg/"/>
    
    <category term="Mercurial" scheme="http://yonghong.tech/tags/Mercurial/"/>
    
  </entry>
  
  <entry>
    <title>技术爱好者周刊 第11期 | 2020年12月14日</title>
    <link href="http://yonghong.tech/weekly-011/"/>
    <id>http://yonghong.tech/weekly-011/</id>
    <published>2020-12-14T02:24:00.000Z</published>
    <updated>2020-12-14T02:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>技术爱好者周刊，每周一发布，欢迎提<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dhbmd5b25naG9uZy95b25naG9uZy1tZS9pc3N1ZXM=">issue<i class="fa fa-external-link-alt"></i></span>贡献内容。</p></blockquote><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMTIvMTAvYXBhY2hlLWt5bGluLXByYWN0aWNlLWluLW1laXR1YW4uaHRtbA==">C++服务编译耗时优化原理及实践<i class="fa fa-external-link-alt"></i></span><br>大型C++工程项目，都会面临编译耗时较长的问题。不管是开发调试迭代、准入测试，亦或是持续集成阶段，编译行为无处不在，降低编译时间对提高研发效率来说具有非常重要意义。</li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvMnNvTHIxRjBYN3JjOGZaLTJmVEU2QQ==">爱奇艺微服务标准技术架构实践<i class="fa fa-external-link-alt"></i></span><br>为数以亿计的用户提供优质的视频服务的爱奇艺技术产品团队，为了适应业务的快速迭代和创新，并支撑海量的用户请求，很多团队都对各自的业务系统自发地进行了微服务架构的改造。</li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvbEhHQzlKZUtiM29rVnV1UXkzekNXZw==">步入超高清视频时代视频编码技术的机遇与挑战——AV1时代要来了<i class="fa fa-external-link-alt"></i></span><br>近些年随着视频行业的迅猛发展，尤其像短视频、点播、直播、VR等领域的爆发，人们对于高清、超高清视频体验的追求越来越强烈，流媒体平台如何在提升观众观看体验，同时降低播放成本，利用技术降低带宽消耗的同时又能最大化的还原视频的画质和质量，成为了重要的课题。</li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvTGtDb2FVRTVzbDg4SjkwaVZ3bG45QQ==">一文彻底理解 I/O 多路复用<i class="fa fa-external-link-alt"></i></span><br>这里的关键点在于，我们事先并不知道一个文件描述对应的I/O设备是否是可读的、是否是可写的，在外设的不可读或不可写的状态下进行I/O只会导致进程阻塞被暂停运行。</li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvVmlIS2Y5Y0Izbl9JalM0TFVIeXpLUQ==">10 张图告诉你，Kafka 是怎么做到支持百万级 TPS 的？<i class="fa fa-external-link-alt"></i></span><br>谈到大数据传输都会想到 Kafka，Kafka 号称大数据的杀手锏，在业界有很多成熟的应用场景并且被主流公司认可。这款为大数据而生的消息中间件，以其百万级TPS的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。在业界已经有很多成熟的消息中间件如：RabbitMQ, RocketMQ, ActiveMQ, ZeroMQ，为什么 Kafka 在众多的敌手中依然能有一席之地，当然靠的是其强悍的吞吐量。下面带领大家来揭秘。</li></ul><span id="more"></span><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLmlwYWxmaXNoLmNvbS9ibG9nLzIwMjAvMTIvMDgvYXBhY2hlX2Fycm93X3N1bW1hcnkv">Apache Arrow：一种适合异构大数据系统的内存列存数据格式标准<i class="fa fa-external-link-alt"></i></span><br>本文介绍一种内存列存数据格式：Apache Arrow，它有一个非常大的愿景：提供内存数据分析 (in-memory analytics) 的开发平台，让数据在异构大数据系统间移动、处理地更快。同时，比较特别的是这个项目的启动形式与其他项目也不相同，Arrow 项目的草台班子由 5 个 Apache Members、6 个 PMC Chairs 和一些其它项目的 PMC 及 committer 构成，他们直接找到 ASF 董事会，征得同意后直接以顶级 Apache 项目身份启动。</li></ul><h2 id="近期会议"><a href="#近期会议" class="headerlink" title="近期会议"></a>近期会议</h2><h3 id="第十一届中国数据库技术大会（DTCC2020）"><a href="#第十一届中国数据库技术大会（DTCC2020）" class="headerlink" title="第十一届中国数据库技术大会（DTCC2020）"></a>第十一届中国数据库技术大会（DTCC2020）</h3><p>报名链接：<span class="exturl" data-url="aHR0cDovL2R0Y2MuaXQxNjguY29tLw==">http://dtcc.it168.com/<i class="fa fa-external-link-alt"></i></span></p><p>会议时间：2020年12月21日 ~ 1010年12月23日</p><p>2020年12月21日~12月23日，由 IT168 旗下 ITPUB 企业社区平台主办的第十一届中国数据库技术大会（DTCC2020），将在北京隆重召开。大会以“架构革新 高效可控”为主题，设置2大主会场，20+技术专场，将邀请超百位行业专家，重点围绕数据架构、AI与大数据、传统企业数据库实践和国产开源数据库等内容展开分享和探讨，为广大数据领域从业人士提供一场年度盛会和交流平台。</p><p>为了帮助更多企业落地数据项目实施方案，今年将继续开设多门深度培训课程，内容涵盖数据中台、去IOE实践、区块链技术、内核开发实践等。3天传统技术演讲+1天深度主题，将汇聚各行业精英、技术领袖、行业专家和数据英雄，带来超过100场主题演讲和超5场培训课程的头脑风暴，诚邀您的加入。</p><p>历经十年的积累与沉淀，如今的DTCC已然成为国内数据库领域的技术风向标，见证了整个行业的发展与演变。作为顶级的数据领域技术盛会，DTCC2020将继续秉承一贯的干货分享和实践指导原则，期待大家的热情参与！</p><h3 id="第十届PostgreSQL中国技术大会"><a href="#第十届PostgreSQL中国技术大会" class="headerlink" title="第十届PostgreSQL中国技术大会"></a>第十届PostgreSQL中国技术大会</h3><p>报名链接：<span class="exturl" data-url="aHR0cDovL3BnY29uZjIwMjAucG9zdGdyZXMuY24v">http://pgconf2020.postgres.cn/<i class="fa fa-external-link-alt"></i></span></p><p>会议时间：2021年1月15日 ~ 2021年1月16日</p><p>2021年1月15～1月16日，由 PostgreSQL 中文社区主办的第十届《PostgreSQL 中国技术大会》将在南京索菲特银河大酒店现场隆重举办。</p><p>PostgreSQL 作为功能最强的的开源关系型数据库之一，得到了越来越多企业的推广和运用，也越来越受到广大技术爱好者的欢迎和重视。</p><p>本次大会以“开源，自研，新机遇”为主题。除了设立一个主会场外，还设立了多个分会场。大会汇聚了来自互联网、电商、教育，金融等各行业领域的专家，这将是 PostgreSQL 发展史上的又一次交流盛会。</p><h2 id="其他周报"><a href="#其他周报" class="headerlink" title="其他周报"></a>其他周报</h2><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1YW55Zi93ZWVrbHkvYmxvYi9tYXN0ZXIvZG9jcy9pc3N1ZS0xMzcubWQ=">科技爱好者周刊（第 137 期）：Slack 被收购，以及企业的技术选型<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BvbGFyaXMxMTE5L2dvbGFuZ3dlZWtseS9ibG9iL21hc3Rlci9kb2NzL2lzc3VlLTA3My5tZA==">Go语言爱好者周刊：第 73 期<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3plbmFueS93ZWVrbHkvYmxvYi9tYXN0ZXIvc29mdHdhcmUvMjAyMC8xMjA3Lm1k">2020.12.07 - Flying the Nest: WebThings Gateway 1.0<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N3aWZ0T2xkRHJpdmVyL2lPUy1XZWVrbHkvYmxvYi9tYXN0ZXIvUmVwb3J0cy8yMDIwLyUyMzEzNy0yMDIwLjEyLjE0Lm1k">老司机 iOS 周报 #139 | 2020-12-14<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9yd2Vla2x5Lm9yZy8yMDIwLTQ5Lmh0bWw=">R Weekly 2020-49 ggplot2, static code analysis, visual CV<i class="fa fa-external-link-alt"></i></span></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;技术爱好者周刊，每周一发布，欢迎提&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL3dhbmd5b25naG9uZy95b25naG9uZy1tZS9pc3N1ZXM=&quot;&gt;issue&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;贡献内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;后端&quot;&gt;&lt;a href=&quot;#后端&quot; class=&quot;headerlink&quot; title=&quot;后端&quot;&gt;&lt;/a&gt;后端&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMTIvMTAvYXBhY2hlLWt5bGluLXByYWN0aWNlLWluLW1laXR1YW4uaHRtbA==&quot;&gt;C++服务编译耗时优化原理及实践&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;大型C++工程项目，都会面临编译耗时较长的问题。不管是开发调试迭代、准入测试，亦或是持续集成阶段，编译行为无处不在，降低编译时间对提高研发效率来说具有非常重要意义。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvMnNvTHIxRjBYN3JjOGZaLTJmVEU2QQ==&quot;&gt;爱奇艺微服务标准技术架构实践&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;为数以亿计的用户提供优质的视频服务的爱奇艺技术产品团队，为了适应业务的快速迭代和创新，并支撑海量的用户请求，很多团队都对各自的业务系统自发地进行了微服务架构的改造。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvbEhHQzlKZUtiM29rVnV1UXkzekNXZw==&quot;&gt;步入超高清视频时代视频编码技术的机遇与挑战——AV1时代要来了&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;近些年随着视频行业的迅猛发展，尤其像短视频、点播、直播、VR等领域的爆发，人们对于高清、超高清视频体验的追求越来越强烈，流媒体平台如何在提升观众观看体验，同时降低播放成本，利用技术降低带宽消耗的同时又能最大化的还原视频的画质和质量，成为了重要的课题。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvTGtDb2FVRTVzbDg4SjkwaVZ3bG45QQ==&quot;&gt;一文彻底理解 I/O 多路复用&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;这里的关键点在于，我们事先并不知道一个文件描述对应的I/O设备是否是可读的、是否是可写的，在外设的不可读或不可写的状态下进行I/O只会导致进程阻塞被暂停运行。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvVmlIS2Y5Y0Izbl9JalM0TFVIeXpLUQ==&quot;&gt;10 张图告诉你，Kafka 是怎么做到支持百万级 TPS 的？&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;谈到大数据传输都会想到 Kafka，Kafka 号称大数据的杀手锏，在业界有很多成熟的应用场景并且被主流公司认可。这款为大数据而生的消息中间件，以其百万级TPS的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。在业界已经有很多成熟的消息中间件如：RabbitMQ, RocketMQ, ActiveMQ, ZeroMQ，为什么 Kafka 在众多的敌手中依然能有一席之地，当然靠的是其强悍的吞吐量。下面带领大家来揭秘。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术爱好者周刊" scheme="http://yonghong.tech/categories/%E6%8A%80%E6%9C%AF%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A/"/>
    
    
    <category term="技术爱好者周刊" scheme="http://yonghong.tech/tags/%E6%8A%80%E6%9C%AF%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>JDK 15来袭，带你深入掌握 Java 15 新特性</title>
    <link href="http://yonghong.tech/2020/12/jdk-15-new-feature/"/>
    <id>http://yonghong.tech/2020/12/jdk-15-new-feature/</id>
    <published>2020-12-10T02:24:00.000Z</published>
    <updated>2020-12-10T02:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>视频来源：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXZmNHkxQjd0dA==">https://www.bilibili.com/video/BV1vf4y1B7tt<i class="fa fa-external-link-alt"></i></span></p><h2 id="大背景"><a href="#大背景" class="headerlink" title="大背景"></a>大背景</h2><h3 id="25-岁的-Java"><a href="#25-岁的-Java" class="headerlink" title="25 岁的 Java"></a>25 岁的 Java</h3><h4 id="Java-的现状"><a href="#Java-的现状" class="headerlink" title="Java 的现状"></a>Java 的现状</h4><p>2020 年是 Java 诞生的第 25 个年头，Oracle 表示，目前 Java 仍然流行是流行的编程语言，广泛使用在企业中。目前全世界有超过 69% 的专职开发人员使用 Java，全世界有 510 亿台活动 Java 虚拟机（JVM）在部署中，目前 Java 主要被用于分析、数据管理、大数据、DevOps、移动、持续开发工具和聊天机器人等服务。</p><h4 id="历史版本的主要新特性"><a href="#历史版本的主要新特性" class="headerlink" title="历史版本的主要新特性"></a>历史版本的主要新特性</h4><p>在过去的这些年中，Java 在过去增强功能的推动下为用户提供了超过二十年的创新。例如：</p><ul><li>JDK 5：enum、泛型、自动装箱与拆箱、可变参数、增强循环等</li><li>JDK 6：支持脚本语言、JDBC 4.0 API</li><li>JDK 7：支持 try-with-resources、switch 语句块增加 String 支持、NIO 2.0 包</li><li>JDK 8：lambda 表达式、Stream API、新的日期时间的 API、方法引用、构造器引用</li><li>JDK 9：模块化系统、jshell</li><li>JDK 10：局部变量的类型推断</li><li>JDK 11：ZGC 的引入、Epsilon GC</li><li>JDK 12：switch 表达式、Shenandoah GC、增强 G1</li><li>JDK 13：switch 表达式引入 yield、文本块</li><li>JDK 14：instanceof 模式识别、Records、弃用 Parallel Scavenge + Serial GC 组合、删除 CMS GC</li></ul><span id="more"></span><h4 id="近期版本发布及维护时间"><a href="#近期版本发布及维护时间" class="headerlink" title="近期版本发布及维护时间"></a>近期版本发布及维护时间</h4><p>OpenJDK 发版本路线图：</p><p><img src="https://up-img.yonghong.tech/pic/2020/12/10-09-20-lKGMjQBUu1XzDeP-96MbI6.jpg" alt="OpenJDK 发版本路线图"></p><p>Oracle Java SE 支持路线图：<span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9qYXZhL3RlY2hub2xvZ2llcy9qYXZhLXNlLXN1cHBvcnQtcm9hZG1hcC5odG1s">https://www.oracle.com/java/technologies/java-se-support-roadmap.html<i class="fa fa-external-link-alt"></i></span></p><p><img src="https://up-img.yonghong.tech/pic/2020/12/10-09-20-Oracle-Java-SE-%E6%94%AF%E6%8C%81%E8%B7%AF%E7%BA%BF%E5%9B%BE-Bwu1zb.png" alt="Oracle Java SE 支持路线图"></p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>因为是小步快跑、快速迭代，因此此处解释下这两个词：孵化器模块（Incubator）和预览特性（Preview）。</p><h4 id="孵化器模块（Incubator-孵化版-实验版）"><a href="#孵化器模块（Incubator-孵化版-实验版）" class="headerlink" title="孵化器模块（Incubator/孵化版/实验版）"></a>孵化器模块（Incubator/孵化版/实验版）</h4><p>尚未确定的 API/工具，主要用于从 Java 社区收集使用反馈，稳定性无保障，后期有较大可能性移除。</p><h4 id="预览特性（Preview-预览版）"><a href="#预览特性（Preview-预览版）" class="headerlink" title="预览特性（Preview/预览版）"></a>预览特性（Preview/预览版）</h4><p>规格已成型，实现已确定，但还未最终定稿。这些特性还是存在被移除的可能性，但一般来说最后都会被固定下来。</p><h3 id="新特性关注点"><a href="#新特性关注点" class="headerlink" title="新特性关注点"></a>新特性关注点</h3><p>角度一：语法层面</p><p>lambda 表达式、switch、自动装箱和拆箱、enum、接口中的静态方法、默认方法、私有方法</p><p>角度二：API 层面</p><p>Stream API、新的日期时间的 API、Optional、String、集合框架</p><p>角度三：底层优化</p><p>JVM 优化、元空间、GC、GC 的组合、GC 的参数、js 的执行引擎、集合底层实现等</p><h2 id="新特性概述"><a href="#新特性概述" class="headerlink" title="新特性概述"></a>新特性概述</h2><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><p>这次发布的主要功能有：</p><p>Java 15 为用户提供了 14 项主要的增强/更改,包括一个孵化器模块、三个预览功能、两个不推荐使用的功能以及两个删除功能。</p><p><span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L3Byb2plY3RzL2pkay8xNS8=">https://openjdk.java.net/projects/jdk/15/<i class="fa fa-external-link-alt"></i></span></p><p><strong>Features</strong></p><ul><li>339:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzM5">Edwards-Curve Digital Signature Algorithm (EdDSA)<i class="fa fa-external-link-alt"></i></span> </li><li>360:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzYw">Sealed Classes (Preview)<i class="fa fa-external-link-alt"></i></span> </li><li>371:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzcx">Hidden Classes<i class="fa fa-external-link-alt"></i></span>          </li><li>372:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzcy">Remove the Nashorn JavaScript Engine<i class="fa fa-external-link-alt"></i></span> </li><li>373:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzcz">Reimplement the Legacy DatagramSocket API<i class="fa fa-external-link-alt"></i></span> </li><li>374:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzc0">Disable and Deprecate Biased Locking<i class="fa fa-external-link-alt"></i></span> </li><li>375:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzc1">Pattern Matching for instanceof (Second Preview)<i class="fa fa-external-link-alt"></i></span> </li><li>377:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzc3">ZGC: A Scalable Low-Latency Garbage Collector<i class="fa fa-external-link-alt"></i></span> </li><li>378:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzc4">Text Blocks<i class="fa fa-external-link-alt"></i></span>             </li><li>379:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzc5">Shenandoah: A Low-Pause-Time Garbage Collector<i class="fa fa-external-link-alt"></i></span> </li><li>381:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzgx">Remove the Solaris and SPARC Ports<i class="fa fa-external-link-alt"></i></span> </li><li>383:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzgz">Foreign-Memory Access API (Second Incubator)<i class="fa fa-external-link-alt"></i></span> </li><li>384:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzg0">Records (Second Preview)<i class="fa fa-external-link-alt"></i></span> </li><li>385:  <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzg1">Deprecate RMI Activation for Removal<i class="fa fa-external-link-alt"></i></span> </li></ul><p>对应中文特性：（JEP：JDK Enhancement Proposals，JDK 增强建议，也就是 JDK 的特性新增和改进提案。）</p><ul><li>JEP 339：EdDSA 数字签名算法</li><li>JEP 360：密封类（预览）</li><li>JEP 371：隐藏类</li><li>JEP 372：删除 Nashorn JavaScript 引擎</li><li>JEP 373：重新实现 Legacy DatagramSocket API</li><li>JEP 374：禁用偏向锁</li><li>JEP 375：instanceof 模式匹配（第二次预览）</li><li>JEP 377：ZGC：一个可扩展的低延迟垃圾收集器</li><li>JEP 378：文本块</li><li>JEP 379：Shenandoah：低暂停时间垃圾收集器</li><li>JEP 381：移除 Solaris 和 SPARC 端口</li><li>JEP 383：外部存储器访问 API（第二个孵化版）</li><li>JEP 384：Records（第二次预览）</li><li>JEP 385：废弃 RMI 激活机制</li></ul><p>总结：</p><ul><li>JDK 15 整体来看新特性方面并不算很亮眼，它主要是对之前版本预览特性的功能做了确定，如文本块、ZGC 等，这么一来我们就可以放心大胆的使用了。</li><li>你发任你发，我用 Java 8。</li></ul><h3 id="做出贡献的企业"><a href="#做出贡献的企业" class="headerlink" title="做出贡献的企业"></a>做出贡献的企业</h3><p>通过 Oracle 的官方博文中看到，虽然主力军 Oracle 干了 79.68% 的工作量，其次是开源巨头红帽。但还是有不少企业参与其中。国内企业贡献最多的居然是腾讯公司，被 Oracle 点名感谢。阿里巴巴和华为也做出了不可磨灭的贡献。Java 有中国科技力量的贡献能大大提升中国 IT 的硬实力。</p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>支持 Java 15 的开发工具</p><p>目前，官方博文说支持 Java 15 的工具，就下面这三款：</p><ul><li>JetBrains IDEA</li><li>Apache NetBeans</li><li>Eclipse Marketplace</li></ul><p>运行 JDK 15 需要 IDEA 2020.2 才能支持。（JDK 14 要求 2020.1）</p><p>JDK 15 下载路径：</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9qYXZhL3RlY2hub2xvZ2llcy9qYXZhc2UvamRrMTUtYXJjaGl2ZS1kb3dubG9hZHMuaHRtbA==">https://www.oracle.com/java/technologies/javase/jdk15-archive-downloads.html<i class="fa fa-external-link-alt"></i></span></p><p>如果使用 IDEA 需要设置 Project Structure -&gt; Project -&gt; Project language level 为 15 （Preview …）</p><p>如果使用 Gradle，还需配置 build.gradle</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启预览特性</span></span><br><span class="line">tasks.withType(JavaCompile) &#123;</span><br><span class="line">    <span class="keyword">options</span>.compilerArgs += <span class="string">&quot;--enable-preview&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新特性（主菜）"><a href="#新特性（主菜）" class="headerlink" title="新特性（主菜）"></a>新特性（主菜）</h2><h3 id="01-密封类"><a href="#01-密封类" class="headerlink" title="01-密封类"></a>01-密封类</h3><p><strong>JEP 360: Sealed Classes(Preview) 密封的类和接口（预览）</strong></p><p>通过密封的类和接口来增强 Java 编程语言，这是新的预览特性。</p><p>用于限制超类的使用，密封的类和接口限制其它可能继承或实现它们的其他类或接口。</p><p>这个特性的目标包括——允许类或接口的开发者来控制哪些代码负责实现，提供了比限制使用超类的访问修饰符声明方式更多的选择，并通过支持对模式的详尽分析而支持模式匹配的未来发展。</p><p>在 Java 中，类层次结构通过继承实现代码的重用，父类的方法可以被许多子类继承。</p><p>但是，类层次结构的目的并不总是重用代码。有时，其目的是对域中存在的各种可能性进行建模，例如图形库支持的形状类型或金融应用程序支持的贷款类型。当以这种方式使用类层次结构时，我们可能需要限制子类集从而来简化建模。</p><p>具体使用：</p><p>因为我们引入了 sealed class 或 interface。这些 class 或者 interface 只允许被指定的类或者 interface 进行拓展和实现。</p><p>使用修饰符 sealed class 或 interface，这些 class 或者 interface 只允许被指定的类或者 interface 进行拓展和实现。</p><p>使用修饰符 sealed，您可以将一个类声明为密封类。密封类使用 reserved 关键字 permits 列出可以直接拓展它的类。子类可以是最终的，非密封的或密封的。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">permits</span> <span class="title">Teacher</span>, <span class="title">Student</span>, <span class="title">Worker</span> </span>&#123; <span class="comment">// 人</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123; <span class="comment">// 教师</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sealed <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="title">permits</span> <span class="title">MiddleSchoolStudent</span>, <span class="title">GraduateStudent</span> </span>&#123; <span class="comment">// 学生</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MiddleSchoolStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123; <span class="comment">// 中学生</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GraduateStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123; <span class="comment">// 研究生</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">non-sealed <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123; <span class="comment">// 工人</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RailWayWorker</span> <span class="keyword">extends</span> <span class="title">Worker</span> </span>&#123; <span class="comment">// 铁路工人</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="02-隐藏类"><a href="#02-隐藏类" class="headerlink" title="02-隐藏类"></a>02-隐藏类</h3><p><strong>JEP 371: Hidden Classes（隐藏类）</strong></p><p>该提案通过启用标准 API 来定义<strong>无法发现</strong>且<strong>具有有限生命周期</strong>的隐藏类，从而提高 JVM 上所有语言的效率。JDK 内部和外部的框架将能够动态生成类，而这些类可以定义隐藏类。通常来说基于 JVM 的很多语言都有动态生成类的机制，这样可以提高语言的灵活性和效率。</p><ul><li>隐藏类天生为框架设计的，在运行时生成内部的 class。</li><li>隐藏类只能通过反射访问，不能直接被其他类的字节码访问。</li><li>隐藏类可以独立于其他类加载、卸载，这可以减少框架的内存占用。</li></ul><p><strong>Hidden Classes 是什么呢？</strong><br>Hidden Classes 就是不能直接被其他 class 的二进制代码使用的 class。Hidden Classes 主要被一些框架用来生成运行时类，但是这些类不是用来直接使用的，而是通过反射机制来调用。</p><p>比如在 JDK 8 中引入的 lambda 表达式，JVM 并不会在编译的时候将 lambda 表达式转换成为专门的类，而是在运行时将相应的字节码动态生成相应的类对象。</p><p>另外使用动态代理也可以为某些类生成新的动态类。</p><p><strong>那么我们希望这些动态生成的类需要具有什么特性呢？</strong></p><ul><li><strong>不可发现性。</strong>因为我们是为某些静态的类动态生成的动态类，所以我们希望把这个动态生成的类看做是静态类的一部分。所以我们不希望除了该静态类之外的其他机制发现。</li><li><strong>访问控制。</strong>我们希望在访问控制静态类的同时，也能控制到动态生成的类。</li><li><strong>生命周期。</strong>动态生成类的生命周期一般都比较短，我们并不需要将其保存和静态类的生命周期一致。</li></ul><p><strong>API 的支持</strong><br>所以我们需要一些 API 来定义无法发现的且具有有限生命周期的隐藏类。这将提高所有基于 JVM 的语言实现的效率。比如：</p><ul><li>java.lang.reflect.Proxy 可以定义隐藏类作为实现代理接口的代理类。</li><li>java.lang.invoke.StringConcatFactory 可以生成隐藏类来保存常量连接的方法。</li><li>java.lang.invoke.LambdaMetaFactory 可以生成隐藏的 nestmate 类，以容纳访问封闭变量的 lambda 主体。</li></ul><p>普通类是通过调用 ClassLoader::defineClass 创建的，而隐藏来是通过调用 Lookup::defineHiddenClass 创建的。这使 JVM 从提供的字节中派生一个隐藏类，链接该隐藏类，并返回提供对隐藏类的反射访问的查找对象。调用程序可以通过返回的查找对象来获取隐藏类的 Class 对象。</p><h3 id="03-instanceof-模式匹配"><a href="#03-instanceof-模式匹配" class="headerlink" title="03-instanceof 模式匹配"></a>03-instanceof 模式匹配</h3><p><strong>JEP 375: Pattern Matching for instanceof(Second Preview) instanceof 自动匹配模式</strong></p><p>在 Java 14 中作为预览语言功能引入的 instanceof 模式匹配，在 Java 15 中处于第二次预览，而没有任何更改。</p><p>模式匹配允许程序中的通用逻辑（主要是从对象中的条件提取组件）可以更简洁地表达，Haskell 和 C# 等语言已采用模式匹配来实现简洁和安全性。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceofTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String str = (String) obj;</span><br><span class="line">            System.out.println(str.contains(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Not String Type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String str) &#123;</span><br><span class="line">            System.out.println(str.contains(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Not String Type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test1(<span class="string">&quot;Hello, Java&quot;</span>);</span><br><span class="line">        test2(<span class="string">&quot;Hello, Java&quot;</span>);</span><br><span class="line">        test1(<span class="keyword">null</span>);</span><br><span class="line">        test2(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="04-ZGC-功能转正"><a href="#04-ZGC-功能转正" class="headerlink" title="04-ZGC 功能转正"></a>04-ZGC 功能转正</h3><p><strong>JEP 377: ZGC: A Scalable Low-Latency Garbage Collector(Production) ZGC 功能转正</strong></p><p>ZGC 是 Java 11 引入的新的垃圾收集器（JDK 9 以后默认的垃圾收集器是 G1），经过了多个实验阶段，自此终于成为正式特性。</p><p>自 2018 年以来，ZGC 已增加了许多改进，从并发类卸载、取消使用未使用的内存、对类数据共享的支持到改进的 NUMA 感知。此外，最大堆大小从 4 TB 增加到 16 TB。支持的平台包括 Linux、Windows 和 macOS。</p><p>ZGC 是一个重新设计的并发的垃圾回收器，通过减少 GC 停顿时间来提高性能。</p><p>但这并不是替换默认的 GC，默认的 GC 仍然还是 G1；之前需要通过 <code>-XX:+UnlockExperimentalVMOptions</code>, <code>-XX:+UseZGC</code> 来启用 ZGC，现在只需要 <code>-XX:+UseZGC</code> 就可以。相信不久的将来它必将成为默认的垃圾回收器。</p><p>相关的参数有 ZAllocationSpikeTolerance、ZCollectionInterval、ZFragmentationLimit、ZMarkStackSpaceLimit、ZProactive、ZUncommit、ZUncommitDelay、ZAllocationStall、ZPageAllocation、ZPageCacheFlush、ZRelocationSet、ZRelocationSetGroup、ZUncommit。</p><h3 id="05-文本块功能转正"><a href="#05-文本块功能转正" class="headerlink" title="05-文本块功能转正"></a>05-文本块功能转正</h3><p><strong>JEP 378: 文本块功能转正</strong></p><p>Text Blocks 首次是在 JDK 13 中以预览功能出现的，然后在 JDK 14 中又预览了一次，终于在 JDK 15 中被确定下来，可以放心使用了。</p><p>文本块是一种多行字符串文字，它避免了大多数转义序列的需要，以一种可预测的方式自动设置字符串的格式，并在需要时使开发人员可以控制格式，简化编写 Java 程序的任务。</p><p>文本块建议的目标是提高 Java 程序中的字符串的可读性，这些字符串便是以非 Java 语言编写的代码。另一个目标是支持从字符串文本迁移，规定任何新构造都可以表达与字符串文本相同的字符串集，解释相同的转义序列，并且以与字符串文本相同的方式进行操作。OpenJDK 开发人员希望添加转义序列来管理显式空白和换行控件。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextBlockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String text = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                The Sound of Silence</span></span><br><span class="line"><span class="string">                寂静之声</span></span><br><span class="line"><span class="string">                Hello darkness, my old friend</span></span><br><span class="line"><span class="string">                你好 黑暗 我的老朋友</span></span><br><span class="line"><span class="string">                I&#x27;ve come to talk with you again</span></span><br><span class="line"><span class="string">                我又来和你交谈</span></span><br><span class="line"><span class="string">                Because a vision softly creeping</span></span><br><span class="line"><span class="string">                因为有一种幻觉正向悄悄地向我袭来</span></span><br><span class="line"><span class="string">                Left its seeds while I was sleeping</span></span><br><span class="line"><span class="string">                在我熟睡的时候留下了它的种子</span></span><br><span class="line"><span class="string">                And the vision that was planted in my brain</span></span><br><span class="line"><span class="string">                这种幻觉在我的脑海里生根发芽</span></span><br><span class="line"><span class="string">                Still remains</span></span><br><span class="line"><span class="string">                缠绕着我</span></span><br><span class="line"><span class="string">                Within the sound of silence 取消换行 \</span></span><br><span class="line"><span class="string">                伴随着寂静的声音\s空格</span></span><br><span class="line"><span class="string">                &quot;</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="06-Records"><a href="#06-Records" class="headerlink" title="06-Records"></a>06-Records</h3><p><strong>JEP 384: Records Class（预览）</strong></p><p>Records Class 也是第二次出现的预览功能，它在 JDK 14 中也出现过一次了，使用 Record 可以更方便的创建一个常量类，使用的前后代码对比如下。</p><ul><li>当你用 Record 声明一个类时，该类将自动拥有以下功能：<ul><li>获取成员变量的简单方法，以上面的代码为例 name() 和 partner()。注意区分于我们平常 getter 的写法。</li><li>一个 equals 方法的实现，执行比较时会比较该类的所有成员属性。</li><li>重写 equals 当然要重写 hashCode。</li><li>一个可以打印该类所有成员属性的 toString 方法。</li><li>请注意只会有一个构造方法。</li></ul></li></ul><h2 id="新特性（配菜）"><a href="#新特性（配菜）" class="headerlink" title="新特性（配菜）"></a>新特性（配菜）</h2><h3 id="01-EdDSA-数字签名算法"><a href="#01-EdDSA-数字签名算法" class="headerlink" title="01-EdDSA 数字签名算法"></a>01-EdDSA 数字签名算法</h3><p><strong>JEP 339: Edwards-Curve Digital Signature Algorithm（EdDSA 数字签名算法）</strong></p><p>这是一个新的功能。新加入基于 Edwards-Curve 数字签名算法（Edwards-Curve Digital Signature Algorithm）的加密签名，即爱德华兹曲线数字签名算法。</p><p>与 JDK 中的现有签名方案相比，EdDSA 具有更高的安全性和性能，因此备受关注。它已经在 OpenSSL 和 BoringSSL 等加密库中得到支持，在区块链领域用的比较多。</p><p>EdDSA 是一种现代的椭圆曲线方案，具有 JDK 中现有签名方案的优点。</p><h3 id="02-重新实现-DatagramSocket-API"><a href="#02-重新实现-DatagramSocket-API" class="headerlink" title="02-重新实现 DatagramSocket API"></a>02-重新实现 DatagramSocket API</h3><p><strong>JEP 373: Reimplement the Legacy DatagramSocket API（重新实现 DatagramSocket API）</strong></p><p>新的计划是 JEP 353 的后续，该方案重新实现了遗留的套接字 API。</p><p>java.net.datagram.Socket 和 java.net.MulticastSocket 的当前实现可以追溯到 JDK 1.0，那时 IPv6 还在开发中。因此，当前的多播套接字实现尝试调和 IPv4 和 IPv6 难以维护的方式。</p><ul><li>通过替换 java.net.datagram 的基础实现，重新实现旧版 DatagramSocket API。</li><li>更改 java.net.DatagramSocket 和 java.net.MulticastSocket 为更加简单、现代化的底层实现。提高了 JDK 的可维护性和稳定性。</li></ul><p>新的实现：</p><ul><li>易于调试和维护</li><li>与 Project Loom 中正在探索的虚拟线程协同</li></ul><h3 id="03-禁用偏向锁"><a href="#03-禁用偏向锁" class="headerlink" title="03-禁用偏向锁"></a>03-禁用偏向锁</h3><p><strong>JEP 374: Disable and Deprecate Biased Locking 禁用偏向锁定</strong></p><p>在默认情况下禁用偏向锁定，并弃用所有相关命令行选项。目标是确定是否需要继续支持偏置锁定的高维护成本的遗留同步优化，<strong>HotSpot 虚拟机使用该优化来减少非竞争锁定的开销</strong>。尽管某些 Java 应用程序在禁用偏向锁后可能会出现性能下降，但偏向锁的性能提高通常不像以前那么明显。</p><h3 id="04-Shenandoah-GC-转正"><a href="#04-Shenandoah-GC-转正" class="headerlink" title="04-Shenandoah GC 转正"></a>04-Shenandoah GC 转正</h3><p>Shenandoah 垃圾回收算法终于从实验特性转变为产品特性，这是一个从 JDK 12 引入的回收算法，该算法通过与正在运行的 Java 线程同时进行疏散工作来减少 GC 暂停时间。Shenandoah 的暂停时间与堆大小无关，无论堆大小是 200 MB 还是 200 GB，都具有相同的一致暂停时间。</p><p>怎么形容 Shenandoah GC 和 ZGC 的关系呢？异同点大概如下：</p><ul><li>相同点：性能几乎可以认为是相同的。</li><li>不同的：ZGC 是 Oracle JDK 的，根正苗红。而 Shenandoah 只存在于 OpenJDK 中，因此使用时需要注意你的 JDK 版本。</li></ul><p>打开方式：使用 <code>-XX:+UseShenandoahGC</code> 命令行参数打开。</p><h3 id="05-外部存储器访问-API"><a href="#05-外部存储器访问-API" class="headerlink" title="05-外部存储器访问 API"></a>05-外部存储器访问 API</h3><p><strong>JEP 383: Foreign-Memory Access API(Second Incubator) 外部存储器访问 API（孵化器版）</strong></p><p>目的是引入一个 API，以允许 Java 程序安全、有效地访问 Java 堆之外的外部存储器。如本机、持久和托管堆。</p><p>有许多 Java 程序是访问外部内存的，比如 Ignite 和 MapDB。该 API 将有助于避免与垃圾收集相关的成本以及与跨进程共享内存以及通过将文件映射到内存来序列化和反序列化内存内容相关的不可预测性。该 Java API 目前没有为访问外部存储内存提供令人满意的解决方案。但是在新的提议中，API 不应该破化 JVM 的安全性。</p><p>Foreign-Memory Access API 在 JDK 14 被作为 Incubator API 引入，在 JDK 15 处于 Second Incubator，提供了改进。</p><h3 id="06-移除-Solaris-和-SPARC-端口"><a href="#06-移除-Solaris-和-SPARC-端口" class="headerlink" title="06-移除 Solaris 和 SPARC 端口"></a>06-移除 Solaris 和 SPARC 端口</h3><p><strong>JEP 381: Remove the Solaris and SPARC Ports（移除 Solaris 和 SPARC 端口）</strong></p><p>删除对 Solaris/SPARC、Solaris/x64 和 Linux/SPARC 端口的源代码和构建支持，在 JDK 14 中被标记为废弃，在 JDK 15 版本正式移除。</p><p>许多正在开发的项目和功能（如 Valhalla、Loom 和 Panama）需要进行重大更改以适应 CPU 架构和操作系统特定代码。</p><p>近年来，Solaris 和 SPARC 都已被 Linux 操作系统和英特尔处理器取代。放弃对 Solaris 和 SPARC 端口的支持将使 OpenJDK 社区的贡献者能够加速开发新功能，从而推动平台向前发展。</p><h3 id="07-移除-the-Nashorn-JS-引擎"><a href="#07-移除-the-Nashorn-JS-引擎" class="headerlink" title="07-移除 the Nashorn JS 引擎"></a>07-移除 the Nashorn JS 引擎</h3><p><strong>JEP 372: Remove the Nashorn JavaScript Engine</strong></p><p>Nashorn 是在 JDK 提出的脚本执行引擎，该功能是 2014 年 3 月发布的 JDK 8 的新特性。在 JDK 11 就已经把它标记为废弃了，JDK 15 完全移除。</p><p>在 JDK 11 中取以代之的是 GraalVM。GraalVM 是一个运行时平台，它支持 Java 和其他基于 Java 字节码的语言，但也支持其他语言，如 JavaScript，Ruby，Python 或 LLVM。性能是 Nashorn 的 2 倍以上。</p><p>JDK 15 移除了 Nashorn JavaScript Engine 及 jjs 命令行工具。具体就是 jdk.scripting.nashorn 及 jdk.scripting.nashorn.shell 这两个模块被移除了。</p><p>补充：</p><p><img src="https://up-img.yonghong.tech/pic/2020/12/10-09-20-graalvm-e6kACA.png" alt="Graal VM"></p><p>Graal VM 在 HotSpot VM 基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin、C、C++、JavaScript、Ruby、Python、R等</p><h3 id="08-废弃-RMI-激活机制"><a href="#08-废弃-RMI-激活机制" class="headerlink" title="08-废弃 RMI 激活机制"></a>08-废弃 RMI 激活机制</h3><p><strong>JEP: Deprecate RMI Activation for Removal</strong></p><p>RMI Activation 被标记为 Deprecate，将会在未来的版本中删除。RMI 激活机制是 RMI 中一个过时的部分，自 Java 8 以来一直是可选的而非必选项。RMI 激活机制增加了持续的维护负担。RMI 的其他部分暂时不会被弃用。</p><p>在 RMI 系统中，我们使用延迟激活。延迟激活将激活对象推迟到客户第一次使用（即第一次方法调用）之前。</p><p>既然 RMI Activation 这么好用，为什么要废弃呢？</p><p>因为对于现代应用程序来说，分布式系统大部分都是基于 Web 的，Web 服务器已经解决了穿越防火墙，过滤请求，身份验证和安全性的问题，并且也提供了很多延迟加载的技术。</p><p>所以在现代应用程序中，RMI Activation 已经很少被使用到了。并且在各种开源代码库中，也基本上找不到 RMI Activation 的使用代码了。</p><p>为了减少 RMI Activation 的维护成本，在 JDK 8 中，RMI Activation 被置为可选的。现在在 JDK 15，终于可以废弃了。</p><h2 id="新特性（饭后甜点）"><a href="#新特性（饭后甜点）" class="headerlink" title="新特性（饭后甜点）"></a>新特性（饭后甜点）</h2><h3 id="01-添加项"><a href="#01-添加项" class="headerlink" title="01-添加项"></a>01-添加项</h3><ul><li>升级了 Unicode，支持 Unicode 13</li><li>给 CharSequence 新增了 isEmpty 方法</li><li>JDK 15 对 TreeMap 提供了 putIfAbsent、computeIfAbsent、computeIfPresent、compute、merge 方法提供了 overriding 实现</li><li>jcmd 的 GC.heap_dump 命令现在支持 gz 选项，以 dump 出 gzip 压缩版的 heap。压缩等级从 1（压缩快） 到 9（压缩慢），默认为1。</li><li>jdk.net.ExtendedSocketOptions 新增 SO_INCOMING_NAPI_ID 选项</li><li>新增 jdk.tls.client.SignatureSchemes 及 jdk.tls.server.SignatureSchemes 用于配置 TLS Signature Schemes</li><li>支持 certificate_authorities</li></ul><h3 id="02-移除项-amp-废弃项"><a href="#02-移除项-amp-废弃项" class="headerlink" title="02-移除项&amp;废弃项"></a>02-移除项&amp;废弃项</h3><ul><li>淘汰了 <code>-XX:UseAdaptiveGCBoundary</code></li><li>废弃了 ForceNUMA 选项</li><li>默认禁用了 Native SunEC Implementation</li></ul><h3 id="03-其他事项"><a href="#03-其他事项" class="headerlink" title="03-其他事项"></a>03-其他事项</h3><p>已知问题：</p><ul><li>HttpClient 现在没有覆盖在 SSLContext Default Parameters 中指定的 Protocols</li></ul><p>其他事项：</p><ul><li>当 DatagramPacket 没有设置 port 的时候，其 getPort 方法返回 0</li><li>优化了默认 G1 Heap Region Size 的计算</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;视频来源：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXZmNHkxQjd0dA==&quot;&gt;https://www.bilibili.com/video/BV1vf4y1B7tt&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;大背景&quot;&gt;&lt;a href=&quot;#大背景&quot; class=&quot;headerlink&quot; title=&quot;大背景&quot;&gt;&lt;/a&gt;大背景&lt;/h2&gt;&lt;h3 id=&quot;25-岁的-Java&quot;&gt;&lt;a href=&quot;#25-岁的-Java&quot; class=&quot;headerlink&quot; title=&quot;25 岁的 Java&quot;&gt;&lt;/a&gt;25 岁的 Java&lt;/h3&gt;&lt;h4 id=&quot;Java-的现状&quot;&gt;&lt;a href=&quot;#Java-的现状&quot; class=&quot;headerlink&quot; title=&quot;Java 的现状&quot;&gt;&lt;/a&gt;Java 的现状&lt;/h4&gt;&lt;p&gt;2020 年是 Java 诞生的第 25 个年头，Oracle 表示，目前 Java 仍然流行是流行的编程语言，广泛使用在企业中。目前全世界有超过 69% 的专职开发人员使用 Java，全世界有 510 亿台活动 Java 虚拟机（JVM）在部署中，目前 Java 主要被用于分析、数据管理、大数据、DevOps、移动、持续开发工具和聊天机器人等服务。&lt;/p&gt;
&lt;h4 id=&quot;历史版本的主要新特性&quot;&gt;&lt;a href=&quot;#历史版本的主要新特性&quot; class=&quot;headerlink&quot; title=&quot;历史版本的主要新特性&quot;&gt;&lt;/a&gt;历史版本的主要新特性&lt;/h4&gt;&lt;p&gt;在过去的这些年中，Java 在过去增强功能的推动下为用户提供了超过二十年的创新。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK 5：enum、泛型、自动装箱与拆箱、可变参数、增强循环等&lt;/li&gt;
&lt;li&gt;JDK 6：支持脚本语言、JDBC 4.0 API&lt;/li&gt;
&lt;li&gt;JDK 7：支持 try-with-resources、switch 语句块增加 String 支持、NIO 2.0 包&lt;/li&gt;
&lt;li&gt;JDK 8：lambda 表达式、Stream API、新的日期时间的 API、方法引用、构造器引用&lt;/li&gt;
&lt;li&gt;JDK 9：模块化系统、jshell&lt;/li&gt;
&lt;li&gt;JDK 10：局部变量的类型推断&lt;/li&gt;
&lt;li&gt;JDK 11：ZGC 的引入、Epsilon GC&lt;/li&gt;
&lt;li&gt;JDK 12：switch 表达式、Shenandoah GC、增强 G1&lt;/li&gt;
&lt;li&gt;JDK 13：switch 表达式引入 yield、文本块&lt;/li&gt;
&lt;li&gt;JDK 14：instanceof 模式识别、Records、弃用 Parallel Scavenge + Serial GC 组合、删除 CMS GC&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java" scheme="http://yonghong.tech/categories/Java/"/>
    
    
    <category term="JDK" scheme="http://yonghong.tech/tags/JDK/"/>
    
    <category term="Java" scheme="http://yonghong.tech/tags/Java/"/>
    
    <category term="15" scheme="http://yonghong.tech/tags/15/"/>
    
  </entry>
  
  <entry>
    <title>技术爱好者周刊 第10期 | 2020年12月07日</title>
    <link href="http://yonghong.tech/weekly-010/"/>
    <id>http://yonghong.tech/weekly-010/</id>
    <published>2020-12-07T02:24:00.000Z</published>
    <updated>2020-12-07T02:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>技术爱好者周刊，每周一发布，欢迎提<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dhbmd5b25naG9uZy95b25naG9uZy1tZS9pc3N1ZXM=">issue<i class="fa fa-external-link-alt"></i></span>贡献内容。</p></blockquote><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9uaW9jb2Rlci5jb20vMjAyMC8xMS8yOC9DbGlja0hvdXNlJUU5JTlCJTg2JUU3JUJFJUE0JUU2JTkwJUFEJUU1JUJCJUJBMS8=">ClickHouse集群搭建（一）<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9uaW9jb2Rlci5jb20vMjAyMC8xMS8yOS9DbGlja0hvdXNlJUU5JTlCJTg2JUU3JUJFJUE0JUU2JTkwJUFEJUU1JUJCJUJBMi8=">ClickHouse集群搭建（二）<i class="fa fa-external-link-alt"></i></span><br>ClickHouse 是俄罗斯的Yandex于2016年开源的列式存储数据库（DBMS），主要用于在线分析处理查询（OLAP），能够使用SQL查询实时生成分析数据报告。</li><li><span class="exturl" data-url="aHR0cDovL2dlbmVyYWx0aGluay5naXRodWIuaW8vMjAyMC8xMS8yMy9hYm91dC1SZWVudHJhbnRMb2NrLXByb2JsZW1zLw==">ReentrantLock 的这几个问题，你都知道吗？<i class="fa fa-external-link-alt"></i></span><br>之前分析 AQS 的时候，了解到 AQS 依赖于内部的两个 FIFO 队列来完成同步状态的管理，当线程获取锁失败的时候，会将当前线程以及等待状态等信息构造成 Node 对象并将其加入同步队列中，同时会阻塞当前线程。当释放锁的时候，会将首节点的 next 节点唤醒 (head 节点是虚拟节点)，使其再次尝试获取锁。</li><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMTIvMDMvc2VydmljZS1tZXNoLWluLW1laXR1YW4uaHRtbA==">复杂环境下落地Service Mesh的挑战与实践<i class="fa fa-external-link-alt"></i></span><br>在私有云集群环境下建设 Service Mesh ，往往需要对现有技术架构做较大范围的改造，同时会面临诸如兼容困难、规模化支撑技术挑战大、推广困境多等一系列复杂性问题。本文会系统性地讲解在美团在落地 Service Mesh 过程中，我们面临的一些挑战及实践经验，希望能对大家有所启发或者帮助。</li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTAxNDc5MTkwMjQ0MDk4MDYy">CDN工作原理及其在淘宝图片业务中的应用<i class="fa fa-external-link-alt"></i></span><br>淘宝的图片访问，有98%的流量都走了CDN缓存，只有2%会回源到源站，节省了大量的服务器资源。但是，如果在用户访问高峰期，图片内容大批量发生变化，大量用户的访问就会穿透cdn，对源站造成巨大的压力。今年双11，淘宝鹿班的主图价格表达升级项目，就面临了这种挑战，让我们看看是如何解决的吧。<span id="more"></span></li></ul><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMTIvMDMvY2lrbS0yMDIwLW5scC5odG1s">CIKM 2020 | 一文详解美团6篇精选论文<i class="fa fa-external-link-alt"></i></span><br>AI平台/搜索与NLP部/NLP中心/知识图谱组共有六篇论文（其中4篇长文，2篇短文）被国际会议CIKM2020接收，这些论文是知识图谱组在多模态知识图谱、MT-BERT、Graph Embedding和图谱可解释性等方向上的技术沉淀和应用。</li></ul><h2 id="近期会议"><a href="#近期会议" class="headerlink" title="近期会议"></a>近期会议</h2><h3 id="第十一届中国数据库技术大会（DTCC2020）"><a href="#第十一届中国数据库技术大会（DTCC2020）" class="headerlink" title="第十一届中国数据库技术大会（DTCC2020）"></a>第十一届中国数据库技术大会（DTCC2020）</h3><p>报名链接：<span class="exturl" data-url="aHR0cDovL2R0Y2MuaXQxNjguY29tLw==">http://dtcc.it168.com/<i class="fa fa-external-link-alt"></i></span></p><p>会议时间：2020年12月21日 ~ 1010年12月23日</p><p>2020年12月21日~12月23日，由 IT168 旗下 ITPUB 企业社区平台主办的第十一届中国数据库技术大会（DTCC2020），将在北京隆重召开。大会以“架构革新 高效可控”为主题，设置2大主会场，20+技术专场，将邀请超百位行业专家，重点围绕数据架构、AI与大数据、传统企业数据库实践和国产开源数据库等内容展开分享和探讨，为广大数据领域从业人士提供一场年度盛会和交流平台。</p><p>为了帮助更多企业落地数据项目实施方案，今年将继续开设多门深度培训课程，内容涵盖数据中台、去IOE实践、区块链技术、内核开发实践等。3天传统技术演讲+1天深度主题，将汇聚各行业精英、技术领袖、行业专家和数据英雄，带来超过100场主题演讲和超5场培训课程的头脑风暴，诚邀您的加入。</p><p>历经十年的积累与沉淀，如今的DTCC已然成为国内数据库领域的技术风向标，见证了整个行业的发展与演变。作为顶级的数据领域技术盛会，DTCC2020将继续秉承一贯的干货分享和实践指导原则，期待大家的热情参与！</p><h3 id="第十届PostgreSQL中国技术大会"><a href="#第十届PostgreSQL中国技术大会" class="headerlink" title="第十届PostgreSQL中国技术大会"></a>第十届PostgreSQL中国技术大会</h3><p>报名链接：<span class="exturl" data-url="aHR0cDovL3BnY29uZjIwMjAucG9zdGdyZXMuY24v">http://pgconf2020.postgres.cn/<i class="fa fa-external-link-alt"></i></span></p><p>会议时间：2021年1月15日 ~ 2021年1月16日</p><p>2021年1月15～1月16日，由 PostgreSQL 中文社区主办的第十届《PostgreSQL 中国技术大会》将在南京索菲特银河大酒店现场隆重举办。</p><p>PostgreSQL 作为功能最强的的开源关系型数据库之一，得到了越来越多企业的推广和运用，也越来越受到广大技术爱好者的欢迎和重视。</p><p>本次大会以“开源，自研，新机遇”为主题。除了设立一个主会场外，还设立了多个分会场。大会汇聚了来自互联网、电商、教育，金融等各行业领域的专家，这将是 PostgreSQL 发展史上的又一次交流盛会。</p><h2 id="其他周报"><a href="#其他周报" class="headerlink" title="其他周报"></a>其他周报</h2><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1YW55Zi93ZWVrbHkvYmxvYi9tYXN0ZXIvZG9jcy9pc3N1ZS0xMzYubWQ=">科技爱好者周刊（第 136 期）：利特伍德奇迹定律<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BvbGFyaXMxMTE5L2dvbGFuZ3dlZWtseS9ibG9iL21hc3Rlci9kb2NzL2lzc3VlLTA3Mi5tZA==">Go语言爱好者周刊：第 72 期<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3plbmFueS93ZWVrbHkvYmxvYi9tYXN0ZXIvc29mdHdhcmUvMjAyMC8xMTMwLm1k">2020.11.30 - FrontPage: The Good, The Bad, and The Ugly<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N3aWZ0T2xkRHJpdmVyL2lPUy1XZWVrbHkvYmxvYi9tYXN0ZXIvUmVwb3J0cy8yMDIwLyUyMzEzNy0yMDIwLjEyLjA3Lm1k">老司机 iOS 周报 #138 | 2020-12-07<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9yd2Vla2x5Lm9yZy8yMDIwLTQ4Lmh0bWw=">R Weekly 2020-48 Your first R package, magrittr, engineering Shiny<i class="fa fa-external-link-alt"></i></span></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;技术爱好者周刊，每周一发布，欢迎提&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL3dhbmd5b25naG9uZy95b25naG9uZy1tZS9pc3N1ZXM=&quot;&gt;issue&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;贡献内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;后端&quot;&gt;&lt;a href=&quot;#后端&quot; class=&quot;headerlink&quot; title=&quot;后端&quot;&gt;&lt;/a&gt;后端&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9uaW9jb2Rlci5jb20vMjAyMC8xMS8yOC9DbGlja0hvdXNlJUU5JTlCJTg2JUU3JUJFJUE0JUU2JTkwJUFEJUU1JUJCJUJBMS8=&quot;&gt;ClickHouse集群搭建（一）&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9uaW9jb2Rlci5jb20vMjAyMC8xMS8yOS9DbGlja0hvdXNlJUU5JTlCJTg2JUU3JUJFJUE0JUU2JTkwJUFEJUU1JUJCJUJBMi8=&quot;&gt;ClickHouse集群搭建（二）&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;ClickHouse 是俄罗斯的Yandex于2016年开源的列式存储数据库（DBMS），主要用于在线分析处理查询（OLAP），能够使用SQL查询实时生成分析数据报告。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2dlbmVyYWx0aGluay5naXRodWIuaW8vMjAyMC8xMS8yMy9hYm91dC1SZWVudHJhbnRMb2NrLXByb2JsZW1zLw==&quot;&gt;ReentrantLock 的这几个问题，你都知道吗？&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;之前分析 AQS 的时候，了解到 AQS 依赖于内部的两个 FIFO 队列来完成同步状态的管理，当线程获取锁失败的时候，会将当前线程以及等待状态等信息构造成 Node 对象并将其加入同步队列中，同时会阻塞当前线程。当释放锁的时候，会将首节点的 next 节点唤醒 (head 节点是虚拟节点)，使其再次尝试获取锁。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMTIvMDMvc2VydmljZS1tZXNoLWluLW1laXR1YW4uaHRtbA==&quot;&gt;复杂环境下落地Service Mesh的挑战与实践&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;在私有云集群环境下建设 Service Mesh ，往往需要对现有技术架构做较大范围的改造，同时会面临诸如兼容困难、规模化支撑技术挑战大、推广困境多等一系列复杂性问题。本文会系统性地讲解在美团在落地 Service Mesh 过程中，我们面临的一些挑战及实践经验，希望能对大家有所启发或者帮助。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTAxNDc5MTkwMjQ0MDk4MDYy&quot;&gt;CDN工作原理及其在淘宝图片业务中的应用&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;淘宝的图片访问，有98%的流量都走了CDN缓存，只有2%会回源到源站，节省了大量的服务器资源。但是，如果在用户访问高峰期，图片内容大批量发生变化，大量用户的访问就会穿透cdn，对源站造成巨大的压力。今年双11，淘宝鹿班的主图价格表达升级项目，就面临了这种挑战，让我们看看是如何解决的吧。</summary>
    
    
    
    <category term="技术爱好者周刊" scheme="http://yonghong.tech/categories/%E6%8A%80%E6%9C%AF%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A/"/>
    
    
    <category term="技术爱好者周刊" scheme="http://yonghong.tech/tags/%E6%8A%80%E6%9C%AF%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>欧陆词典每日一句-2020年11月</title>
    <link href="http://yonghong.tech/eudic-2020-11/"/>
    <id>http://yonghong.tech/eudic-2020-11/</id>
    <published>2020-11-30T12:00:00.000Z</published>
    <updated>2020-11-30T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>I have to make a difficult choice. Decide quickly. 我必须做一个艰难的选择。那就是迅速做出决定。</p></blockquote><hr><p>If I were you, I wouldn’t worry about it. 如果我是你，我不会为此而担忧。</p><p>They worked hard at whatever they did, but they had a sense of achievement. 无论做什么，他们都很努力，有一种成就感。</p><p>A company should find ways to innovate not just in products but also in functions, business models and processes. 一个公司要寻求的不仅仅是产品创新，还应寻求运营、商业模式和流程方面的创新。</p><span id="more"></span><p>I just trust that the principle of reciprocity is true, and I give what I want. 我相信互利互惠的原则，我想要得到就要付出。</p><p>Most successful people are unorthodox persons whose minds wander outside traditional ways of thinking. 大多数成功的人都并非遵循传统之人，他们的思维方式都游离在传统的思维方式之外。</p><p>Curriculums — from grammar school to college, should evolve to focus less on memorizing facts and more on creativity and complex communication. 从语法学校到大学的课程，都应该逐渐发展，更多地注重创新和复杂的交流，而不是把重点放在记忆事实上。</p><p>Gradually it became dark outside. The rain was still beating on the windows, and I could hear the wind in the trees. 外面的天渐渐黑了。雨点仍然拍打着窗户，还可以听到风在树枝间呼啸。</p><hr><p>Almost all companies recognize the importance of innovation today. 如今，几乎所有的公司都知道创新的重要性。</p><p>I wish you well. You have my best wishes. 我祝福你。向你致以最好的祝愿。</p><p>Too much happiness can be destructive. 乐极也会生悲。</p><p>If you can speak the language, it’s easier to get to know the country and its people. 如果会说当地语言，了解这个国家和人民就会更加容易。</p><p>Truly my favorite part is to see the kids jumping up and down and they just get so excited. 我最喜欢的就是看着孩子们兴奋地蹦蹦跳跳。</p><p>People are curious by nature. 人类天性好奇。</p><p>They believed in goodness, in community, and helping one another. 他们信仰美德，信仰团体，信仰互助。</p><hr><p>In my line of work, I receive a lot of emails. I also send a lot of emails. 在我的职业生涯中，我收到过不少电子邮件，也发出去不少。</p><p>Your joy for life, transmitted wherever you took your smile, and the sparkle in those unforgettable eyes. 你对生活的欣喜，通过你的微笑和你令人难忘的双眸中的闪光，传遍了你的所到之处。</p><p>Use your voice to speak out for what’s right. 用你的影响力去为正义发声。</p><p>All kinds of myths surround the lives of well-known people. 名人的生活总是被各种各样的荒诞故事所围绕。</p><p>Demand is rising rapidly, because of the world’s increasing population and expanding industry. 需求量正在激增，因为整个世界人口急剧增长，工业规模不断扩大。</p><p>If I could go back in history and live when I liked, I wouldn’t go back very far. 如果我能回到过去并生活在我喜欢的年代，我不会选很久以前。</p><p>You might imagine the job you will get when you finish school. 你可能会设想自己毕业后从事的工作。</p><hr><p>We often use slang expressions when we talk, because they are so vivid and colorful. 我们说话时会经常使用俚语，因为俚语很生动、很丰富多彩。</p><p>You need to recognize each step of progress you take towards achieving your goals. 你成功路上的每一点进步都值得自己的认可。</p><p>With a lot of hard work and a good education, anything is possible. 只要你愿意努力工作，努力接受教育，任何事情都是可能的。</p><p>Think of an email as a letter. Spelling, grammar and punctuation should not be overlooked. 把编辑电子邮件当成在写信，拼写、语法、标点都不应忽视。</p><p>The ability to work well with others and collaborate on projects is a sought-after ability in nearly every position. 对于任何职位，与他人保持良好的合作关系，可以进行有效的项目合作，这些对职场人来说都是倍受追捧的能力。</p><p>I like to collect bits and pieces from different parts of the world. 我喜欢在世界各地搜集点点滴滴的东西。</p><p>I have to make a difficult choice. Decide quickly. 我必须做一个艰难的选择。那就是迅速做出决定。</p><hr><p>A well-organized essay will group similar ideas together and put them in the proper order. 一篇条理清晰的文章会把相似的观点组织在一起，并按适当的顺序排列。</p><p>Wherever you go and for whatever reason, it’s important to be safe. 不论你去哪，因为什么原因，安全都很重要。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;I have to make a difficult choice. Decide quickly. 我必须做一个艰难的选择。那就是迅速做出决定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;If I were you, I wouldn’t worry about it. 如果我是你，我不会为此而担忧。&lt;/p&gt;
&lt;p&gt;They worked hard at whatever they did, but they had a sense of achievement. 无论做什么，他们都很努力，有一种成就感。&lt;/p&gt;
&lt;p&gt;A company should find ways to innovate not just in products but also in functions, business models and processes. 一个公司要寻求的不仅仅是产品创新，还应寻求运营、商业模式和流程方面的创新。&lt;/p&gt;</summary>
    
    
    
    <category term="学英语" scheme="http://yonghong.tech/categories/%E5%AD%A6%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="http://yonghong.tech/tags/%E8%8B%B1%E8%AF%AD/"/>
    
    <category term="学英语" scheme="http://yonghong.tech/tags/%E5%AD%A6%E8%8B%B1%E8%AF%AD/"/>
    
    <category term="欧陆词典" scheme="http://yonghong.tech/tags/%E6%AC%A7%E9%99%86%E8%AF%8D%E5%85%B8/"/>
    
    <category term="每日一句" scheme="http://yonghong.tech/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>句读-2020年11月</title>
    <link href="http://yonghong.tech/judou-2020-11/"/>
    <id>http://yonghong.tech/judou-2020-11/</id>
    <published>2020-11-30T10:00:00.000Z</published>
    <updated>2020-11-30T10:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>能折磨你的，从来不是别人的绝情，而是你的心存幻想和期待。 ​​​​</p></blockquote><hr><p>生活如果没有目标，就会变得懒散。一旦决定“今天这样做”，生活一下子就会张弛有度。 ​​​​中村恒子</p><p>如果一个人必须完成一件自己不喜欢的事，最好的办法就是尽快做好，然后结束。迟子建</p><p>无论风暴将我带到什么样的岸边，我都将以主人的身份上岸。贺拉斯</p><span id="more"></span><p>有的人走了就再也没回来过，所以，等待和犹豫才是这个世界上最无情的杀手。三毛</p><p>你总是喜欢把事情拖到第二天，你不能再这么拖了，因为有一天，你会有很多事要做，你的余生都不够你用。《余生的第一天》</p><p>很多时候，并不是别人在折磨我们，而是我们用自己的价值观去评判对方的是非对错，是我们在折磨自己。铃木大拙</p><p>我太想爱上一个人了，只是不知道该爱谁。《木兰花》</p><hr><p>语言和文字真的是不可执取的东西，当一句话说出来或者写下来，它就不是你的了，你必须允许别人任意解读，甚至误读。所以我最想说的话，其实在我开口的一刹那就已经说完。扎西朗姆·多多</p><p>当没有任何一个人信任你的时候，沉默和坚持就是最好的反击和证明。托马斯·哈里斯 《沉默的羔羊》</p><p>你形容自己是随和、好相处又安分守己的人，所以你要不就是非常随和，要不就是极度与人疏离。《大小谎言》</p><p>我渴望拥抱你，对你说一千句温柔的蠢话，然这样的话只能在纸上我才能好意思写写，即使在想象中我见了你也将羞愧低头，你是如此可爱而残忍。朱生豪 《醒来觉得甚是爱你》</p><p>我们必须全力以赴，同时又不抱持任何希望。不管做什么事，都要当它是全世界最重要的一件事，但同时又知道这件事根本无关紧要。里尔克</p><p>我们要的或许不是爱，而是偏爱，从他人的偏爱里，确认自己是独特的。只有这样，才能消解在芸芸众生中的孤独。苏更生</p><p>世界上最让人感动的，是遥远的相似性。霍金</p><hr><p>假如您此时此刻刚好陷入了困境，正饱受折磨，那么我很想告诉您：“尽管眼下十分艰难，可日后这段经历说不定就会开花结果。”也不知道这话能否成为慰藉，不过请您这样换位思考、奋力前行。村上春树</p><p>我去练习，去训练，就是避免自己过度思考。平野步梦</p><p>我不会再尝试成为真实的我以外的东西了，我希望你能接受这样的我。《她》</p><p>人的本能是追逐从他身边飞走的东西，却逃避追逐他的东西。伏尔泰</p><p>有教养不是吃饭不洒汤，是别人洒汤的时候别去看他。契诃夫</p><p>能折磨你的，从来不是别人的绝情，而是你的心存幻想和期待。 ​​​​</p><p>生活给了我想要的东西，又让我知道这都是没有意义的。</p><hr><p>若有人能让你体会到心碎狂喜和一败涂地，那伟大的并不是他而是你自己。琦殿</p><p>人的一生中，最光辉的一天并非是功成名就那天，而是从悲叹与绝望中产生对人生的挑战，以勇敢迈向意志那天。福楼拜</p><p>有时候，觉得所有人都很美好，下一刻，这些人又变得贪得无厌，而且世界冷酷无比，根本没有自己的立足之地。然而，这都是自己的内心产生的幻想。我们总是将自己内心的恐惧投射在他人身上，当我们看他人，或是看世界的时候，其实看到的是自己。石田衣良 《掌心迷路》</p><p>太在意别人的视线和评价，才会不断寻求别人的认可。对认可的追求，才扼杀了自由。由于不想被任何人讨厌，才选择了不自由的生活方式。换言之，自由就是不再寻求认可。阿德勒</p><p>在以后的日子里，如果我们在各自的道路上，能不时对望一眼，就好了。林清玄</p><p>我始终相信，一切高贵的情感都羞于表白，一切深刻的体验都拙于言辞。周国平</p><p>事实是，每个人都有可能伤害你。你只需要找到那些值得让你忍受的人。鲍勃·马利</p><hr><p>比起偶然的幸福感，充足的睡眠似乎有着更持久的治愈力。禾几</p><p>渺小的忧伤和渺小的爱寿命很长，伟大的爱和伟大的忧伤却毁于自身的过于丰富强烈。王尔德 《道林·格雷的画像》</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;能折磨你的，从来不是别人的绝情，而是你的心存幻想和期待。 ​​​​&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;生活如果没有目标，就会变得懒散。一旦决定“今天这样做”，生活一下子就会张弛有度。 ​​​​中村恒子&lt;/p&gt;
&lt;p&gt;如果一个人必须完成一件自己不喜欢的事，最好的办法就是尽快做好，然后结束。迟子建&lt;/p&gt;
&lt;p&gt;无论风暴将我带到什么样的岸边，我都将以主人的身份上岸。贺拉斯&lt;/p&gt;</summary>
    
    
    
    <category term="句读" scheme="http://yonghong.tech/categories/%E5%8F%A5%E8%AF%BB/"/>
    
    
    <category term="句读" scheme="http://yonghong.tech/tags/%E5%8F%A5%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>技术爱好者周刊 第9期 | 2020年11月30日</title>
    <link href="http://yonghong.tech/weekly-009/"/>
    <id>http://yonghong.tech/weekly-009/</id>
    <published>2020-11-30T02:24:00.000Z</published>
    <updated>2020-11-30T02:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>技术爱好者周刊，每周一发布，欢迎提<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dhbmd5b25naG9uZy95b25naG9uZy1tZS9pc3N1ZXM=">issue<i class="fa fa-external-link-alt"></i></span>贡献内容。</p></blockquote><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd3ljMTk5NDY2Ni9wLzEwODMxMDM5Lmh0bWw=">Mysql 索引精讲<i class="fa fa-external-link-alt"></i></span><br>本文主要讲述常见索引类型(实现层面)、索引种类(应用层面)、聚簇索引与非聚簇索引、覆盖索引、最佳索引使用策略。</li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvRlR1aml0d2tNbDVMUmRiV0N4T0VHQQ==">京东到家MySQL容器化，为何首选Docker而非K8S？<i class="fa fa-external-link-alt"></i></span><br>本文根据詹乡泉老师在〖deeplus直播第250期〗线上分享演讲内容整理而成。（文末有获取本期PPT&amp;回放的方式，不要错过），分享视频：<span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS9za1psTGhxRFVkYw==">https://youtu.be/skZlLhqDUdc<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvWmE5ZVIwdE5qb1UzclRnNXhUWWdOQQ==">高德最佳实践：Serverless规模化落地有哪些价值？<i class="fa fa-external-link-alt"></i></span><br>曾经看上去很美、一直被观望的 Serverless，现已逐渐进入落地的阶段。今年的”十一出行节”，高德在核心业务规模化落地 Serverless，由 Serverless 支撑的业务在流量高峰期的表现十分优秀。传统应用也能带来同样的体验，那么 Serverless 的差异化价值又是什么呢？本文分享高德 Serverless 规模化落地背后的实践总结。</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamFqaWFuL3AvMTEyMjM5OTIuaHRtbA==">Elasticsearch 技术分析（九）：全文搜索引擎Elasticsearch，这篇文章给讲透了！<i class="fa fa-external-link-alt"></i></span><br>本篇主要是基于之前的博文的一个总结，希望通过这篇文章能让读者大致了解Elasticsearch是做什么的以及它的使用和基本原理。</li></ul><span id="more"></span><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvNDgzX2hlc1phbGFHUlBlYnp6NXRQQQ==">Android D8编译器“bug”导致Crash的问题排查<i class="fa fa-external-link-alt"></i></span><br>这篇文章主要是分析了一个因为 Android D8 编译器分配的寄存器不太合理，导致运行时 ART 抛出了 VerifyError 而 Crash 的问题，下文简单分析了下问题产生的原因以及我们采用的修复方案。</li><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMTEvMjYvY29uc2lzdGVuY3ktaW4tdWktZGVzaWduLmh0bWw=">移动端UI一致性解决方案<i class="fa fa-external-link-alt"></i></span><br>UI一致性是绝大部分研发团队面临的共性问题，大家对落地设计规范，提高UI中台能力，提升产研效率具有强烈的诉求。通过UI一致性的建设，不仅可以在品牌上实现体验升级，更可以全面提高产研效率，为业务的快速迭代提供有力支持和有效保障。统一的品牌符号、品牌特征，有助于加深产品在用户心目中的印象。统一的用户界面和交互形式，能帮助用户加深对产品的熟悉感和信任感。而一个好的设计语言可以在体验上为产品加分，也能够更好的创造一致性体验。</li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvZGRUVXhRRUVuSWJfYjFQek5fSlJKQQ==">干货 | 响应式设计在携程火车票的应用<i class="fa fa-external-link-alt"></i></span><br>可能很多人脑海中已经出现了这样一个动画，当浏览器中页面尺寸不断变化时，内容也在随之变化。简单说，响应式网站设计是一种允许设计和代码响应设备屏幕大小的方法。</li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvOUdqWEI5RXUtT1AzZklqZFFXS2tsZw==">UME - 丰富的Flutter调试工具<i class="fa fa-external-link-alt"></i></span><br>目前西瓜视频作者侧 Flutter 业务场景已经覆盖了 40多个页面 (包括视频播放场景)，用户侧核心场景包括我的 Tab 也已经是 Flutter，在开发过程中，暴露了一些问题，debug 调试难、离开了 IDE 后犹如抓瞎、PM 设计 QA 验收过程中拿不到有用的信息，在市面上找了一圈，也没有类似 iOS Flex 这样强大的调试工具，例如视图大小、层级的展示，实例对象属性的实时修改，网络请求抓取，log 日志打印，文件查看等，所以西瓜视频 Flutter 基础团队决定开发 UME。</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLmN0cmlwLmNvbS9hcnRpY2xlcy9hX2FyY2hpdGVjdHVyZS8xMTY4Ni8=">携程多语言平台-Shark系统的高可用演进之路<i class="fa fa-external-link-alt"></i></span><br>Shark是携程IBU国际化进程中孵化的集多语言内容管理、多语言翻译、多语言内容下发等功能为一体的多语言平台，目前为携程海外几十个站点和上千个业务应用提供稳定的多语言内容管理和下发服务。本文主要分享携程IBU多语言团队在提升系统稳定性过程中的一些实践和总结，希望给大家一些参考和帮助。</li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODk4NDk0ODE3NTYzOTAxOTYw">淘系面向业务价值的精细化流量管控实战-双11实录<i class="fa fa-external-link-alt"></i></span><br>本文将从背景问题、实战效果、设计思路与解法三个方面介绍马克尼(Marconi)在2020双11中，保障了淘系（淘宝、天猫等）核心业务平台（如 首页、会场、直播、互动、我的淘宝 等），多架构层次（从接入网关到业务应用集群/容器）管控业务流量并提升服务业务效果，给予用户顺滑的体验；提升了淘系(及阿里巴巴集团更多的BU)的稳定性底盘，成为应用稳定性保障的核心能力，推动了业界在大型分布式在线业务系统的高可用/稳定性保障进展。为今年双11创新纪录提供保障！</li></ul><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMTEvMjcvc2VsZi1kcml2aW5nLWluLXNpbXVsYXRpb24tc3lzdGVtLmh0bWw=">美团无人车引擎在仿真中的实践<i class="fa fa-external-link-alt"></i></span><br>过去几年，自动驾驶技术有了飞速发展。国内也出现了许多自动驾驶创业企业，这些公司以百度开源项目Apollo为起点，大都可以直接进行公开道路测试，公开道路测试也成为促进技术进步的主要方法。基础问题得以解决之后，行业面临的更多是长尾问题，依靠路测驱动自动驾驶能力建设的方式变得不再高效，离线仿真的地位日益凸显。行业头部企业在仿真的投入十分巨大，Waymo公司2019年公布的仿真里程是100亿英里，是路测里程的1000倍。相应地，美团无人车团队在仿真上的投入也在逐渐增大。在仿真平台的建设中，团队发现公开道路测试和仿真测试看似相似，实际上差异巨大：在车载环境下，为了确保系统的稳定运行，通常要保证一定资源处于空闲状态；仿真环境则不同，如何高效利用资源，如何实现压榨资源的同时确保仿真结果与路测结果一致成为了关键目标。在应对这些挑战的过程中，美团提出了无人车引擎的概念，将车载与离线环境的差异隔离起来：功能模块无需任何更改便可以满足两种场景的需要。</li></ul><h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvRGtDR3Vzem5IOEY4cDM5b1JMdU5CUQ==">TensorFlow Serving 模型更新毛刺的完全优化实践<i class="fa fa-external-link-alt"></i></span><br>在点击率CTR（Click Through Rate）预估算法的推荐场景中使用 Tensorflow Serving热更新较大模型时会出现短暂的延时毛刺，导致业务侧超时，降低算法效果，为了解决这个问题，爱奇艺深度学习平台团队经过多个阶段的优化实践，最后对 TF Serving 和 Tensorflow 的源码进行深入优化，将模型热更新时的毛刺现象解决，本文将分享Tensorflow Serving的优化细节，希望对大家有帮助。</li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvYW1lOVhMMjE4RksxRHVfYnkzX0w1QQ==">日志异常检测初步实践与探索<i class="fa fa-external-link-alt"></i></span><br>日志的主要目的是记录系统（包括服务和业务等）状态和重要的事件帮助定位系统的问题。日志对于理解系统状态和定位性能问题至关重要。因此，日志是在线监控和异常检测的一个重要信息源。在很多业务和服务的故障自愈过程中，日志异常检测与根因分析是必不可少的一环。但是之前我们通常都使用人工的方式来定位问题，主要包括人工检测与分析和人工学习错误日志提取正则表达式来进行故障定位这两种方式。</li></ul><h2 id="近期会议"><a href="#近期会议" class="headerlink" title="近期会议"></a>近期会议</h2><h3 id="第十一届中国数据库技术大会（DTCC2020）"><a href="#第十一届中国数据库技术大会（DTCC2020）" class="headerlink" title="第十一届中国数据库技术大会（DTCC2020）"></a>第十一届中国数据库技术大会（DTCC2020）</h3><p>报名链接：<span class="exturl" data-url="aHR0cDovL2R0Y2MuaXQxNjguY29tLw==">http://dtcc.it168.com/<i class="fa fa-external-link-alt"></i></span></p><p>会议时间：2020年12月21日 ~ 1010年12月23日</p><p>2020年12月21日~12月23日，由 IT168 旗下 ITPUB 企业社区平台主办的第十一届中国数据库技术大会（DTCC2020），将在北京隆重召开。大会以“架构革新 高效可控”为主题，设置2大主会场，20+技术专场，将邀请超百位行业专家，重点围绕数据架构、AI与大数据、传统企业数据库实践和国产开源数据库等内容展开分享和探讨，为广大数据领域从业人士提供一场年度盛会和交流平台。</p><p>为了帮助更多企业落地数据项目实施方案，今年将继续开设多门深度培训课程，内容涵盖数据中台、去IOE实践、区块链技术、内核开发实践等。3天传统技术演讲+1天深度主题，将汇聚各行业精英、技术领袖、行业专家和数据英雄，带来超过100场主题演讲和超5场培训课程的头脑风暴，诚邀您的加入。</p><p>历经十年的积累与沉淀，如今的DTCC已然成为国内数据库领域的技术风向标，见证了整个行业的发展与演变。作为顶级的数据领域技术盛会，DTCC2020将继续秉承一贯的干货分享和实践指导原则，期待大家的热情参与！</p><h3 id="第十届PostgreSQL中国技术大会"><a href="#第十届PostgreSQL中国技术大会" class="headerlink" title="第十届PostgreSQL中国技术大会"></a>第十届PostgreSQL中国技术大会</h3><p>报名链接：<span class="exturl" data-url="aHR0cDovL3BnY29uZjIwMjAucG9zdGdyZXMuY24v">http://pgconf2020.postgres.cn/<i class="fa fa-external-link-alt"></i></span></p><p>会议时间：2021年1月15日 ~ 2021年1月16日</p><p>2021年1月15～1月16日，由 PostgreSQL 中文社区主办的第十届《PostgreSQL 中国技术大会》将在南京索菲特银河大酒店现场隆重举办。</p><p>PostgreSQL 作为功能最强的的开源关系型数据库之一，得到了越来越多企业的推广和运用，也越来越受到广大技术爱好者的欢迎和重视。</p><p>本次大会以“开源，自研，新机遇”为主题。除了设立一个主会场外，还设立了多个分会场。大会汇聚了来自互联网、电商、教育，金融等各行业领域的专家，这将是 PostgreSQL 发展史上的又一次交流盛会。</p><h2 id="其他周报"><a href="#其他周报" class="headerlink" title="其他周报"></a>其他周报</h2><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1YW55Zi93ZWVrbHkvYmxvYi9tYXN0ZXIvZG9jcy9pc3N1ZS0xMzUubWQ=">科技爱好者周刊（第 135 期）：什么行业适合创业？<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BvbGFyaXMxMTE5L2dvbGFuZ3dlZWtseS9ibG9iL21hc3Rlci9kb2NzL2lzc3VlLTA3MS5tZA==">Go语言爱好者周刊：第 71 期<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3plbmFueS93ZWVrbHkvYmxvYi9tYXN0ZXIvc29mdHdhcmUvMjAyMC8xMTIzLm1k">2020.11.23 - Moving my serverless project to Ruby on Rails<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N3aWZ0T2xkRHJpdmVyL2lPUy1XZWVrbHkvYmxvYi9tYXN0ZXIvUmVwb3J0cy8yMDIwLyUyMzEzNy0yMDIwLjExLjMwLm1k">老司机 iOS 周报 #138 | 2020-11-30<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9yd2Vla2x5Lm9yZy8yMDIwLTQ3Lmh0bWw=">R Weekly 2020-47 NHS-R, testthat utility belt, bayesian networks<i class="fa fa-external-link-alt"></i></span></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;技术爱好者周刊，每周一发布，欢迎提&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL3dhbmd5b25naG9uZy95b25naG9uZy1tZS9pc3N1ZXM=&quot;&gt;issue&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;贡献内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;后端&quot;&gt;&lt;a href=&quot;#后端&quot; class=&quot;headerlink&quot; title=&quot;后端&quot;&gt;&lt;/a&gt;后端&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd3ljMTk5NDY2Ni9wLzEwODMxMDM5Lmh0bWw=&quot;&gt;Mysql 索引精讲&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;本文主要讲述常见索引类型(实现层面)、索引种类(应用层面)、聚簇索引与非聚簇索引、覆盖索引、最佳索引使用策略。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvRlR1aml0d2tNbDVMUmRiV0N4T0VHQQ==&quot;&gt;京东到家MySQL容器化，为何首选Docker而非K8S？&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;本文根据詹乡泉老师在〖deeplus直播第250期〗线上分享演讲内容整理而成。（文末有获取本期PPT&amp;amp;回放的方式，不要错过），分享视频：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly95b3V0dS5iZS9za1psTGhxRFVkYw==&quot;&gt;https://youtu.be/skZlLhqDUdc&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvWmE5ZVIwdE5qb1UzclRnNXhUWWdOQQ==&quot;&gt;高德最佳实践：Serverless规模化落地有哪些价值？&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;曾经看上去很美、一直被观望的 Serverless，现已逐渐进入落地的阶段。今年的”十一出行节”，高德在核心业务规模化落地 Serverless，由 Serverless 支撑的业务在流量高峰期的表现十分优秀。传统应用也能带来同样的体验，那么 Serverless 的差异化价值又是什么呢？本文分享高德 Serverless 规模化落地背后的实践总结。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamFqaWFuL3AvMTEyMjM5OTIuaHRtbA==&quot;&gt;Elasticsearch 技术分析（九）：全文搜索引擎Elasticsearch，这篇文章给讲透了！&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;本篇主要是基于之前的博文的一个总结，希望通过这篇文章能让读者大致了解Elasticsearch是做什么的以及它的使用和基本原理。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术爱好者周刊" scheme="http://yonghong.tech/categories/%E6%8A%80%E6%9C%AF%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A/"/>
    
    
    <category term="技术爱好者周刊" scheme="http://yonghong.tech/tags/%E6%8A%80%E6%9C%AF%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
  <entry>
    <title>技术爱好者周刊 第8期 | 2020年11月23日</title>
    <link href="http://yonghong.tech/weekly-008/"/>
    <id>http://yonghong.tech/weekly-008/</id>
    <published>2020-11-23T02:24:00.000Z</published>
    <updated>2020-11-23T02:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>技术爱好者周刊，每周一发布，欢迎提<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dhbmd5b25naG9uZy95b25naG9uZy1tZS9pc3N1ZXM=">issue<i class="fa fa-external-link-alt"></i></span>贡献内容。</p></blockquote><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvdlgzMGQ0c0FYMm9FVG5OaDN1WmxFQQ==">干货 | 携程 Cilium+BGP 云原生网络实践<i class="fa fa-external-link-alt"></i></span><br>Cilium 是近两年最火的云原生网络方案之一。Cilium 的核心基于 eBPF，有两大亮点：基于 eBPF 的灵活、高性能网络，以及基于 eBPF 的 L3-L7 安全策略实现。携程 2019 年开始在生产环境使用 Cilium，本文将介绍 Cilium 在携程的落地情况，以及我们基于 Cilium 的、覆盖虚拟机、物理机和容器的云原生安全的一些探索。</li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvZnluZG9ic2l3NEU1eV9sWGtyVEJ4dw==">数据人的“大考”：AnalyticDB如何强力支撑双11？<i class="fa fa-external-link-alt"></i></span><br>每年的双11都是云原生数据仓库AnalyticDB MySQL版（原分析型数据库MySQL版）的一块试金石。今年AnalyticDB除了在阿里数字经济体内进入更多核心交易链路，全力支撑双11以外，AnalyticDB全面拥抱云原生，构建极致弹性，大幅降低成本，释放技术红利，重磅发布了诸多全新企业级特性，让用户及时拥有极高性价比的云原生数据仓库。本文深度解析云原生数据仓库AnalyticDB面临的挑战和最新关键技术，分享双11护航背后的技术实践与经验。</li></ul><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODk2Mjg4OTkwNzY1MjUyNjE2">双十一SSR优化实践：秒开率提升新高度<i class="fa fa-external-link-alt"></i></span><br>会场是每年双十一的主角之一，会场的用户体验自然也是每年最关注的点。在日趋复杂的业务需求下，如何保障我们的用户体验不劣化甚至能更优化是永恒的命题。<br>今年（2020）我们在不改变现有架构，不改变业务的前提下，在会场上使用了 SSR 技术，将秒开率提高到了新的高度（82.6%）；也观察到在用户体验得到优化的同时，业务指标如 UV 点击率等也有小幅的增长（视不同业务场景有不同的提升，最大可达 5%），带来了不错的业务价值。<br>本文将从服务端、前端两个角度介绍我们在 SSR 上的方案与经验<br>1、前端在解决工程化、业务效果评估上的具体实践与方法论<br>2、服务端在解决前端模块代码于服务端执行、隔离和性能优化上的具体实践与方法论</li><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvRENyaXhYcW5FbnVIcFlmVVBqeUFDQQ==">爱奇艺知识移动端组件化探索和实践<i class="fa fa-external-link-alt"></i></span><br>组件化对于任何一个业务场景复杂的APP以及经过多次迭代之后的产品来说都是必经之路，组件化是指解耦复杂系统时将多个功能模块拆分、重组的过程。组件化要做的不仅仅是表面上看到的模块拆分解耦，其背后还有很多工作来支撑组件化的进行，例如结合业务特性的模块拆分策略、模块间的交互方式和构建系统等等。本文主要讲述爱奇艺知识APP如何结合自身的业务特点，探索和实践了一套高效的移动端组件化方案。</li></ul><span id="more"></span><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvNWU5Y21xdnZhSWhOczhDTlZKdU5vZw==">基于chaosblade的故障注入平台实践<i class="fa fa-external-link-alt"></i></span><br>当今社会互联网应用越来越广泛，用户量日益剧增。在人们对互联网服务的依赖性增大的同时，也对服务的可用性和体验感有了更高的要求。那么如何保障服务在运营过程中能一直给用户提供稳定的、不间断的、可靠可信的服务呢？例如一个金融产品，如果出现过一次问题，那可能带来巨大的损失。大家都知道金融产品的系统架构和服务逻辑是相当复杂的，至此大家都会第一时间联想到测试工程师，他们会通过单元测试、集成测试、性能测试等来验证服务的稳定性。但尽管如此，也是远远不够的，因为错误可以在任何时间以任何形式发生，尤其是对分布式系统。所以这里就需要引入混沌工程（Chaos Engineering）。</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODk3MDExMDUyNjAxNDA5NTQ5">设计模式最佳套路—— 愉快地使用策略模式<i class="fa fa-external-link-alt"></i></span><br>策略模式（Strategy Pattern）定义了一组策略，分别在不同类中封装起来，每种策略都可以根据当前场景相互替换，从而使策略的变化可以独立于操作者。比如我们要去某个地方，会根据距离的不同（或者是根据手头经济状况）来选择不同的出行方式（共享单车、坐公交、滴滴打车等等），这些出行方式即不同的策略。</li></ul><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMTEvMTkvYXBhY2hlLWt5bGluLXByYWN0aWNlLWluLW1laXR1YW4uaHRtbA==">Apache Kylin的实践与优化<i class="fa fa-external-link-alt"></i></span><br>Apache Kylin是一个基于Hadoop大数据平台打造的开源OLAP引擎，它采用了多维立方体预计算技术，利用空间换时间的方法，将查询速度提升至亚秒级别，极大地提高了数据分析的效率，并带来了便捷、灵活的查询功能。</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGFvc2RhdGEuY29tL2Jsb2cvMjAyMC8xMS8xNy8yMDI4Lmh0bWw=">双汇大数据方案选型：从棘手的InfluxDB+Redis到毫秒级查询的TDengine<i class="fa fa-external-link-alt"></i></span><br>双汇发展多个分厂的能源管控大数据系统主要采用两种技术栈：InfluxDB/Redis和Kafka/Redis/HBase/Flink，对于中小型研发团队来讲，无论是系统搭建，还是实施运维都非常棘手。经过对InfluxDB/Redis和TDengine大数据平台的功能和性能对比测试，最终将TDengine作为实施方案。</li></ul><h2 id="近期会议公开课"><a href="#近期会议公开课" class="headerlink" title="近期会议公开课"></a>近期会议公开课</h2><h3 id="2020-MongoDB-中国线上用户大会"><a href="#2020-MongoDB-中国线上用户大会" class="headerlink" title="2020 MongoDB 中国线上用户大会"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubW9uZ29kYi5jb20vbGl2ZS1jaGluYS16aA==">2020 MongoDB 中国线上用户大会<i class="fa fa-external-link-alt"></i></span></h3><p>会议时间：11 月 24 日 星期二</p><p>报名链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cubW9uZ29kYi5jb20vbGl2ZS1jaGluYS16aA==">https://www.mongodb.com/live-china-zh<i class="fa fa-external-link-alt"></i></span></p><p>线上参会，全天精彩享不停！MongoDB重磅嘉宾主题演讲、头部客户使用心得分享、干货满满的多个分会场、动手实操培训，MongoDB 只为助您轻松构建可扩展、高性能、现代化应用程序。</p><h3 id="NGINX开源社区技术专题系列课程（安全专题）"><a href="#NGINX开源社区技术专题系列课程（安全专题）" class="headerlink" title="NGINX开源社区技术专题系列课程（安全专题）"></a>NGINX开源社区技术专题系列课程（安全专题）</h3><p>报名链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cubmdpbngub3JnLmNuL2FydGljbGUvZGV0YWlsLzMzNg==">https://www.nginx.org.cn/article/detail/336<i class="fa fa-external-link-alt"></i></span></p><p>主题：使用ModSecurity/App Protect模块构建NGINX WAF</p><p>时间：11月25日下午2-3点</p><p>讲师：NGINX解决方案架构师邹俊</p><p>企业需要迅速将服务和应用推向市场，而快速将代码发布到生产环境中的压力使得安全性很容易下滑。过度依赖诸如漏洞扫描器之类的自动化工具是危险的，因为它们不能捕捉到所有问题。将各种跨功能开发团队提供的代码结合起来，就不太清楚谁负责实施安全性。在生产环境中运行多个应用和应用版本会使应用程序的防护层出现裂缝。</p><p>最终的结果是，对web应用防火墙（WAF）等安全工具的需求从未像现在这样迫切。这些安全工具通常与负载平衡代理集成，并部署在公司网络的边缘（或前门）以创建安全的外围环境。</p><p>安全不再是CISO和SecOps团队的唯一领域。DevOps团队在接受、测试和部署作为CI/CD管道一部分的安全策略方面扮演着重要角色。NGINX App Protect将F5先进WAF技术的有效性与NGINX的灵活性和性能相结合。它本机运行在NGINX Plus上，以解决现代DevOps环境面临的安全挑战。</p><p>通过本次公开课，您可以了解：</p><ul><li>NGINX WAF使用场景</li><li>NGINX WAF vs NGINX App Protect</li><li>NGINX App Protect策略配置</li><li>KIC WAF策略配置</li></ul><h2 id="会议公开课资料"><a href="#会议公开课资料" class="headerlink" title="会议公开课资料"></a>会议公开课资料</h2><h3 id="2020-Google-开发者大会-Google-Developer-Summit"><a href="#2020-Google-开发者大会-Google-Developer-Summit" class="headerlink" title="2020 Google 开发者大会 (Google Developer Summit)"></a>2020 Google 开发者大会 (Google Developer Summit)</h3><p>Google 开发者大会 (Google Developer Summit) 是谷歌面向开发者展示最新产品和平台的年度盛会。2020 Google 开发者大会于 11 月 16 日 至 21 日举行，这是谷歌首次以全线上大会的形式与中国开发者相聚。本次大会以“代码不止”为主题，全面介绍了产品更新以及一系列面向本地开发者的技术支持内容，旨在赋能开发者高效创新、持续不断地创造愉悦的产品体验。</p><p>2020 Google 开发者大会 (Google Developer Summit) 全部视频 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vcGxheWxpc3Q/bGlzdD1QTGRjT01jRE1yTHJVbVp1WFJLdE9saERaR3BzdlFJWGk3">https://www.youtube.com/playlist?list=PLdcOMcDMrLrUmZuXRKtOlhDZGpsvQIXi7<i class="fa fa-external-link-alt"></i></span></p><p>2020 Google 开发者大会 主题演讲 <span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS81ek82MEhOUWtXUQ==">https://youtu.be/5zO60HNQkWQ<i class="fa fa-external-link-alt"></i></span></p><p>2020 Google 开发者大会 技术演讲专场 Android、Google Play、ChromeOS <span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS9OLXg3dFhZZk94RQ==">https://youtu.be/N-x7tXYfOxE<i class="fa fa-external-link-alt"></i></span></p><p>2020 Google 开发者大会 技术演讲专场 Flutter、Web、Material Design <span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS80VkxRTXlTUWg4UQ==">https://youtu.be/4VLQMySQh8Q<i class="fa fa-external-link-alt"></i></span></p><p>2020 Google 开发者大会 技术演讲专场 TensorFlow、Google 女性开发者职业发展座谈会 <span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS9OdTl6Z1VJNUtUYw==">https://youtu.be/Nu9zgUI5KTc<i class="fa fa-external-link-alt"></i></span></p><p>2020 Google 开发者大会 技术演讲专场 Google Cloud、Google Assistant、游戏和移动应用、Firebase <span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS95cjhBeGFqZTBDNA==">https://youtu.be/yr8Axaje0C4<i class="fa fa-external-link-alt"></i></span></p><p>2020 Google 开发者大会 技术演讲专场 谷歌艺术与文化、ARCore by Google、WearOS by Google <span class="exturl" data-url="aHR0cHM6Ly95b3V0dS5iZS94cWZwR0FXOGRfTQ==">https://youtu.be/xqfpGAW8d_M<i class="fa fa-external-link-alt"></i></span></p><h2 id="其他周报"><a href="#其他周报" class="headerlink" title="其他周报"></a>其他周报</h2><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J1YW55Zi93ZWVrbHkvYmxvYi9tYXN0ZXIvZG9jcy9pc3N1ZS0xMzQubWQ=">科技爱好者周刊（第 134 期）：未来的游戏业比现在大100倍<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BvbGFyaXMxMTE5L2dvbGFuZ3dlZWtseS9ibG9iL21hc3Rlci9kb2NzL2lzc3VlLTA3MC5tZA==">Go语言爱好者周刊：第 70 期<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3plbmFueS93ZWVrbHkvYmxvYi9tYXN0ZXIvc29mdHdhcmUvMjAyMC8xMTE2Lm1k">2020.11.16 - KISS, SOLID, YAGNI And Other Fun Acronyms<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1N3aWZ0T2xkRHJpdmVyL2lPUy1XZWVrbHkvYmxvYi9tYXN0ZXIvUmVwb3J0cy8yMDIwLyUyMzEzNy0yMDIwLjExLjIzLm1k">老司机 iOS 周报 #137 | 2020-11-23<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9yd2Vla2x5Lm9yZy8yMDIwLTQ2Lmh0bWw=">R Weekly 2020-46 Open Acces, YAPOEH, Docker<i class="fa fa-external-link-alt"></i></span></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;技术爱好者周刊，每周一发布，欢迎提&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXRodWIuY29tL3dhbmd5b25naG9uZy95b25naG9uZy1tZS9pc3N1ZXM=&quot;&gt;issue&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;贡献内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;后端&quot;&gt;&lt;a href=&quot;#后端&quot; class=&quot;headerlink&quot; title=&quot;后端&quot;&gt;&lt;/a&gt;后端&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvdlgzMGQ0c0FYMm9FVG5OaDN1WmxFQQ==&quot;&gt;干货 | 携程 Cilium+BGP 云原生网络实践&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;Cilium 是近两年最火的云原生网络方案之一。Cilium 的核心基于 eBPF，有两大亮点：基于 eBPF 的灵活、高性能网络，以及基于 eBPF 的 L3-L7 安全策略实现。携程 2019 年开始在生产环境使用 Cilium，本文将介绍 Cilium 在携程的落地情况，以及我们基于 Cilium 的、覆盖虚拟机、物理机和容器的云原生安全的一些探索。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvZnluZG9ic2l3NEU1eV9sWGtyVEJ4dw==&quot;&gt;数据人的“大考”：AnalyticDB如何强力支撑双11？&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;每年的双11都是云原生数据仓库AnalyticDB MySQL版（原分析型数据库MySQL版）的一块试金石。今年AnalyticDB除了在阿里数字经济体内进入更多核心交易链路，全力支撑双11以外，AnalyticDB全面拥抱云原生，构建极致弹性，大幅降低成本，释放技术红利，重磅发布了诸多全新企业级特性，让用户及时拥有极高性价比的云原生数据仓库。本文深度解析云原生数据仓库AnalyticDB面临的挑战和最新关键技术，分享双11护航背后的技术实践与经验。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;前端&quot;&gt;&lt;a href=&quot;#前端&quot; class=&quot;headerlink&quot; title=&quot;前端&quot;&gt;&lt;/a&gt;前端&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODk2Mjg4OTkwNzY1MjUyNjE2&quot;&gt;双十一SSR优化实践：秒开率提升新高度&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;会场是每年双十一的主角之一，会场的用户体验自然也是每年最关注的点。在日趋复杂的业务需求下，如何保障我们的用户体验不劣化甚至能更优化是永恒的命题。&lt;br&gt;今年（2020）我们在不改变现有架构，不改变业务的前提下，在会场上使用了 SSR 技术，将秒开率提高到了新的高度（82.6%）；也观察到在用户体验得到优化的同时，业务指标如 UV 点击率等也有小幅的增长（视不同业务场景有不同的提升，最大可达 5%），带来了不错的业务价值。&lt;br&gt;本文将从服务端、前端两个角度介绍我们在 SSR 上的方案与经验&lt;br&gt;1、前端在解决工程化、业务效果评估上的具体实践与方法论&lt;br&gt;2、服务端在解决前端模块代码于服务端执行、隔离和性能优化上的具体实践与方法论&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvRENyaXhYcW5FbnVIcFlmVVBqeUFDQQ==&quot;&gt;爱奇艺知识移动端组件化探索和实践&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;组件化对于任何一个业务场景复杂的APP以及经过多次迭代之后的产品来说都是必经之路，组件化是指解耦复杂系统时将多个功能模块拆分、重组的过程。组件化要做的不仅仅是表面上看到的模块拆分解耦，其背后还有很多工作来支撑组件化的进行，例如结合业务特性的模块拆分策略、模块间的交互方式和构建系统等等。本文主要讲述爱奇艺知识APP如何结合自身的业务特点，探索和实践了一套高效的移动端组件化方案。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术爱好者周刊" scheme="http://yonghong.tech/categories/%E6%8A%80%E6%9C%AF%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A/"/>
    
    
    <category term="技术爱好者周刊" scheme="http://yonghong.tech/tags/%E6%8A%80%E6%9C%AF%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A/"/>
    
  </entry>
  
</feed>
