<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Honng</title>
  
  <subtitle>Stay Hungary. Stay Foolish.</subtitle>
  <link href="http://yonghong.tech/atom.xml" rel="self"/>
  
  <link href="http://yonghong.tech/"/>
  <updated>2021-11-19T11:13:41.529Z</updated>
  <id>http://yonghong.tech/</id>
  
  <author>
    <name>Honng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Studio 技巧</title>
    <link href="http://yonghong.tech/recommend/android-studio/"/>
    <id>http://yonghong.tech/recommend/android-studio/</id>
    <published>2021-11-19T11:13:41.529Z</published>
    <updated>2021-11-19T11:13:41.529Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Local-Changes-标签页"><a href="#Local-Changes-标签页" class="headerlink" title="Local Changes 标签页"></a>Local Changes 标签页</h3><p>打开 Preferences/Version Control/Commit ，将 Use non-modal commit interface 选项 取消勾选 即可。</p><span id="more"></span><h3 id="日期格式调整"><a href="#日期格式调整" class="headerlink" title="日期格式调整"></a>日期格式调整</h3><p>打开 Preferences/Appearacnce &amp; Behavior/System Settings/Date Formats，将日期格式设置为 yyyy/MM/dd </p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Local-Changes-标签页&quot;&gt;&lt;a href=&quot;#Local-Changes-标签页&quot; class=&quot;headerlink&quot; title=&quot;Local Changes 标签页&quot;&gt;&lt;/a&gt;Local Changes 标签页&lt;/h3&gt;&lt;p&gt;打开 Preferences/Version Control/Commit ，将 Use non-modal commit interface 选项 取消勾选 即可。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>macOS 装机清单</title>
    <link href="http://yonghong.tech/recommend/mac-install-list/"/>
    <id>http://yonghong.tech/recommend/mac-install-list/</id>
    <published>2021-11-19T11:13:41.529Z</published>
    <updated>2021-11-19T11:13:41.529Z</updated>
    
    <content type="html"><![CDATA[<h3 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h3><p>搜狗输入法：<span class="exturl" data-url="aHR0cHM6Ly9waW55aW4uc29nb3UuY29tL21hYy8=">https://pinyin.sogou.com/mac/<i class="fa fa-external-link-alt"></i></span></p><h3 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h3><p><span class="exturl" data-url="aHR0cHM6Ly9pdGVybTIuY29tLw==">https://iterm2.com/<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h3 id="omyzsh"><a href="#omyzsh" class="headerlink" title="omyzsh"></a>omyzsh</h3><p><span class="exturl" data-url="aHR0cHM6Ly9vaG15ei5zaC8=">https://ohmyz.sh/<i class="fa fa-external-link-alt"></i></span></p><h3 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h3><p><span class="exturl" data-url="aHR0cHM6Ly9icmV3LnNoLw==">https://brew.sh/<i class="fa fa-external-link-alt"></i></span></p><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>jenv：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew install <span class="symbol">openjdk@</span><span class="number">8</span></span><br><span class="line">brew install <span class="symbol">openjdk@</span><span class="number">11</span></span><br><span class="line"></span><br><span class="line">/usr/libexec/java_home -V</span><br></pre></td></tr></table></figure><h3 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h3><p>nvm：</p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>Edge：<span class="exturl" data-url="aHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS96aC1jbi9lZGdl">https://www.microsoft.com/zh-cn/edge<i class="fa fa-external-link-alt"></i></span></p><p>Chrome：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9jaHJvbWUv">https://www.google.com/chrome/<i class="fa fa-external-link-alt"></i></span></p><h3 id="聊天-办公工具"><a href="#聊天-办公工具" class="headerlink" title="聊天/办公工具"></a>聊天/办公工具</h3><p>微信：<span class="exturl" data-url="aHR0cHM6Ly93ZWl4aW4ucXEuY29tLw==">https://weixin.qq.com/<i class="fa fa-external-link-alt"></i></span></p><p>企业微信：<span class="exturl" data-url="aHR0cHM6Ly93b3JrLndlaXhpbi5xcS5jb20v">https://work.weixin.qq.com/<i class="fa fa-external-link-alt"></i></span></p><p>钉钉：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZGluZ3RhbGsuY29tLw==">https://www.dingtalk.com/<i class="fa fa-external-link-alt"></i></span></p><p>飞书：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZmVpc2h1LmNuLw==">https://www.feishu.cn/<i class="fa fa-external-link-alt"></i></span></p><p>腾讯会议：<span class="exturl" data-url="aHR0cHM6Ly9tZWV0aW5nLnRlbmNlbnQuY29tLw==">https://meeting.tencent.com/<i class="fa fa-external-link-alt"></i></span></p><p>office：<span class="exturl" data-url="aHR0cHM6Ly9uZXh0Lml0ZWxseW91LmNuLw==">https://next.itellyou.cn/<i class="fa fa-external-link-alt"></i></span></p><h3 id="解压工具"><a href="#解压工具" class="headerlink" title="解压工具"></a>解压工具</h3><p>keka：<span class="exturl" data-url="aHR0cHM6Ly93d3cua2VrYS5pby9lbi8=">https://www.keka.io/en/<i class="fa fa-external-link-alt"></i></span></p><p>The Unarchiver：<span class="exturl" data-url="aHR0cHM6Ly90aGV1bmFyY2hpdmVyLmNvbS8=">https://theunarchiver.com/<i class="fa fa-external-link-alt"></i></span></p><h3 id="系统工具"><a href="#系统工具" class="headerlink" title="系统工具"></a>系统工具</h3><p>腾讯柠檬：<span class="exturl" data-url="aHR0cHM6Ly9sZW1vbi5xcS5jb20v">https://lemon.qq.com/<i class="fa fa-external-link-alt"></i></span></p><p>防息屏 Sleep Control Center：App Store</p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>JetBrains Toolbox：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamV0YnJhaW5zLmNvbS90b29sYm94LWFwcC8=">https://www.jetbrains.com/toolbox-app/<i class="fa fa-external-link-alt"></i></span></p><p>vscode：<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20v">https://code.visualstudio.com/<i class="fa fa-external-link-alt"></i></span></p><p>postman：<span class="exturl" data-url="aHR0cHM6Ly93d3cucG9zdG1hbi5jb20v">https://www.postman.com/<i class="fa fa-external-link-alt"></i></span></p><p>SwitchHosts：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29sZGovU3dpdGNoSG9zdHMvcmVsZWFzZXM=">https://github.com/oldj/SwitchHosts/releases<i class="fa fa-external-link-alt"></i></span></p><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><p>Typora：<span class="exturl" data-url="aHR0cHM6Ly90eXBvcmEuaW8v">https://typora.io/<i class="fa fa-external-link-alt"></i></span></p><h3 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h3><p>drawio：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pncmFwaC9kcmF3aW8tZGVza3RvcC9yZWxlYXNlcw==">https://github.com/jgraph/drawio-desktop/releases<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;输入法&quot;&gt;&lt;a href=&quot;#输入法&quot; class=&quot;headerlink&quot; title=&quot;输入法&quot;&gt;&lt;/a&gt;输入法&lt;/h3&gt;&lt;p&gt;搜狗输入法：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9waW55aW4uc29nb3UuY29tL21hYy8=&quot;&gt;https://pinyin.sogou.com/mac/&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;iTerm2&quot;&gt;&lt;a href=&quot;#iTerm2&quot; class=&quot;headerlink&quot; title=&quot;iTerm2&quot;&gt;&lt;/a&gt;iTerm2&lt;/h3&gt;&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9pdGVybTIuY29tLw==&quot;&gt;https://iterm2.com/&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>mac 键盘延迟突然增高</title>
    <link href="http://yonghong.tech/2021/10/mac-keyboard/"/>
    <id>http://yonghong.tech/2021/10/mac-keyboard/</id>
    <published>2021-09-27T14:24:00.000Z</published>
    <updated>2021-09-27T14:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在系统菜单栏或者控制中心找到你的蓝牙图标。下图中最左边就是蓝牙，最右边是控制中心。点击控制中心，就能显示蓝牙。</p><p>按下 shift+option 的同时，点击蓝牙。会出现几个隐藏选项。选择“恢复连接苹果设备的出厂设置”。 </p><p><img src="https://up-img.yonghong.tech/pic/2021/11/18-20-50-%E6%88%AA%E5%B1%8F2021-09-27%20%E4%B8%8B%E5%8D%889.51.05-HaJhAi.png" alt="蓝牙设置"></p><span id="more"></span><p>再连接你的Keyboard。就好了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在系统菜单栏或者控制中心找到你的蓝牙图标。下图中最左边就是蓝牙，最右边是控制中心。点击控制中心，就能显示蓝牙。&lt;/p&gt;
&lt;p&gt;按下 shift+option 的同时，点击蓝牙。会出现几个隐藏选项。选择“恢复连接苹果设备的出厂设置”。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://up-img.yonghong.tech/pic/2021/11/18-20-50-%E6%88%AA%E5%B1%8F2021-09-27%20%E4%B8%8B%E5%8D%889.51.05-HaJhAi.png&quot; alt=&quot;蓝牙设置&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="macOS" scheme="http://yonghong.tech/categories/macOS/"/>
    
    
    <category term="macOS" scheme="http://yonghong.tech/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 技巧</title>
    <link href="http://yonghong.tech/recommend/idea/"/>
    <id>http://yonghong.tech/recommend/idea/</id>
    <published>2021-08-02T14:24:00.000Z</published>
    <updated>2021-08-02T14:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="properties-文件-Unicode-转中文"><a href="#properties-文件-Unicode-转中文" class="headerlink" title="properties 文件 Unicode 转中文"></a>properties 文件 Unicode 转中文</h2><ul><li>Preference -&gt; Editor -&gt; File Encodings -&gt; Properties Files (*.properties) </li><li>勾选上 Transparent native-to-ascii conversion</li></ul><h2 id="调整-import-多个类时不变成-import"><a href="#调整-import-多个类时不变成-import" class="headerlink" title="调整 import 多个类时不变成 import *"></a>调整 import 多个类时不变成 import *</h2><ul><li>Preference -&gt; Editor -&gt; Code Style -&gt; Java -&gt; Imports </li><li>Class count to use import with “*”</li><li>Names count to use static import with “*”</li><li>这两个数值调大到 999</li></ul><span id="more"></span><h2 id="关闭XML中SQL的黄色背景"><a href="#关闭XML中SQL的黄色背景" class="headerlink" title="关闭XML中SQL的黄色背景"></a>关闭XML中SQL的黄色背景</h2><ul><li>Preference -&gt; Editor -&gt; Inspections -&gt; SQL </li><li>取消勾选 No data sources configured 和 SQL dialect detection</li></ul><p><img src="https://up-img.yonghong.tech/pic/2021/08/03-15-20-xhH8ST-vf3mKv.jpg" alt="pic"></p><h2 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h2><ul><li>格式化整个文件，⌘ + ⌥ + L</li><li>格式化选中区域，选中指定区域后，⌘ + ⌥ + L</li></ul><h2 id="补全方法调用的返回值"><a href="#补全方法调用的返回值" class="headerlink" title="补全方法调用的返回值"></a>补全方法调用的返回值</h2><p>光标放在调用的方法名上，⌘ + ⌥ + V </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;properties-文件-Unicode-转中文&quot;&gt;&lt;a href=&quot;#properties-文件-Unicode-转中文&quot; class=&quot;headerlink&quot; title=&quot;properties 文件 Unicode 转中文&quot;&gt;&lt;/a&gt;properties 文件 Unicode 转中文&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Preference -&amp;gt; Editor -&amp;gt; File Encodings -&amp;gt; Properties Files (*.properties) &lt;/li&gt;
&lt;li&gt;勾选上 Transparent native-to-ascii conversion&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;调整-import-多个类时不变成-import&quot;&gt;&lt;a href=&quot;#调整-import-多个类时不变成-import&quot; class=&quot;headerlink&quot; title=&quot;调整 import 多个类时不变成 import *&quot;&gt;&lt;/a&gt;调整 import 多个类时不变成 import *&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Preference -&amp;gt; Editor -&amp;gt; Code Style -&amp;gt; Java -&amp;gt; Imports &lt;/li&gt;
&lt;li&gt;Class count to use import with “*”&lt;/li&gt;
&lt;li&gt;Names count to use static import with “*”&lt;/li&gt;
&lt;li&gt;这两个数值调大到 999&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技巧" scheme="http://yonghong.tech/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="IDEA" scheme="http://yonghong.tech/tags/IDEA/"/>
    
    <category term="技巧" scheme="http://yonghong.tech/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Android 常用布局</title>
    <link href="http://yonghong.tech/2021/07/android-layout/"/>
    <id>http://yonghong.tech/2021/07/android-layout/</id>
    <published>2021-07-31T14:24:00.000Z</published>
    <updated>2021-07-31T14:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LinearLayout-线性布局"><a href="#LinearLayout-线性布局" class="headerlink" title="LinearLayout 线性布局"></a>LinearLayout 线性布局</h2><p>常用属性</p><ul><li>orientation：布局总组件的排列方式 vertical、horizontal</li><li>gravity：组件所包含的组件的排列方式</li><li>layout_gravity：组件在父容器里的排列方式</li><li>background：背景</li><li>divider：分割线</li><li>showDividers：分割线所在位置：none, beginning, end, middle</li><li>dividerPadding：设置分割线的 padding</li><li>layout_weight：权重，分配剩余空间</li></ul><span id="more"></span><h2 id="RelativeLayout-相对布局"><a href="#RelativeLayout-相对布局" class="headerlink" title="RelativeLayout 相对布局"></a>RelativeLayout 相对布局</h2><p>根据父容器定位</p><ul><li>android:layout_alignParentStart</li><li>android:layout_alignParentEnd</li><li>android:layout_alignParentTop</li><li>android:layout_alignParentBottom</li><li>android:layout_centerHorizontal</li><li>android:layout_centerVertical</li><li>android:layout_centerInParent</li></ul><p>根据兄弟组件定位</p><ul><li><p>android:layout_toStartOf</p></li><li><p>android:layout_toEndOf</p></li><li><p>android:layout_above</p></li><li><p>android:layout_below</p></li><li><p>android:layout_alignStart</p></li><li><p>android:layout_alignEnd</p></li><li><p>android:layout_alignTop</p></li><li><p>android:layout_alignBottom</p><p>margin：组件与父容器的边距</p></li><li><p>android:layout_margin</p></li><li><p>android:layout_marginStart</p></li><li><p>android:layout_marginEnd</p></li><li><p>android:layout_marginTop</p></li><li><p>android:layout_marginBottom</p></li></ul><p>padding：组件内部的边距</p><ul><li>android:padding</li><li>android:paddingStart</li><li>android:paddingEnd</li><li>android:paddingTop</li><li>android:paddingBottom</li></ul><h2 id="FrameLayout-帧布局"><a href="#FrameLayout-帧布局" class="headerlink" title="FrameLayout 帧布局"></a>FrameLayout 帧布局</h2><p>常用属性：</p><ul><li>android:foreground=”@drawable/ceshi”</li><li>android:foregroundGravity=”right|bottom”</li></ul><h2 id="TableLayout-表格布局"><a href="#TableLayout-表格布局" class="headerlink" title="TableLayout 表格布局"></a>TableLayout 表格布局</h2><p>常用属性</p><ul><li>android:collapseColumns   隐藏</li><li>android:stretchColumns    拉伸</li><li>android:shrinkColumns     收缩</li></ul><p>子控件属性</p><ul><li>android:layout_column     显示在第几列</li><li>android:layout_span       横向跨几列</li></ul><h2 id="GridLayout-网格布局"><a href="#GridLayout-网格布局" class="headerlink" title="GridLayout 网格布局"></a>GridLayout 网格布局</h2><p>常用属性</p><ul><li>android:orientation </li><li>android:columnCount</li><li>android:rowCount</li></ul><p>子控件属性</p><ul><li>android:layout_gravity fill、center</li><li>android:layout_column</li><li>android:layout_columnSpan</li><li>android:layout_columnWeight</li><li>android:layout_row</li><li>android:layout_rowSpan</li><li>android:layout_rowWeight</li></ul><h2 id="ConstraintLayout-约束布局"><a href="#ConstraintLayout-约束布局" class="headerlink" title="ConstraintLayout 约束布局"></a>ConstraintLayout 约束布局</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vdHJhaW5pbmcvY29uc3RyYWludC1sYXlvdXQ/aGw9emgtY24=">https://developer.android.com/training/constraint-layout?hl=zh-cn<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;LinearLayout-线性布局&quot;&gt;&lt;a href=&quot;#LinearLayout-线性布局&quot; class=&quot;headerlink&quot; title=&quot;LinearLayout 线性布局&quot;&gt;&lt;/a&gt;LinearLayout 线性布局&lt;/h2&gt;&lt;p&gt;常用属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;orientation：布局总组件的排列方式 vertical、horizontal&lt;/li&gt;
&lt;li&gt;gravity：组件所包含的组件的排列方式&lt;/li&gt;
&lt;li&gt;layout_gravity：组件在父容器里的排列方式&lt;/li&gt;
&lt;li&gt;background：背景&lt;/li&gt;
&lt;li&gt;divider：分割线&lt;/li&gt;
&lt;li&gt;showDividers：分割线所在位置：none, beginning, end, middle&lt;/li&gt;
&lt;li&gt;dividerPadding：设置分割线的 padding&lt;/li&gt;
&lt;li&gt;layout_weight：权重，分配剩余空间&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Android" scheme="http://yonghong.tech/categories/Android/"/>
    
    
    <category term="Android" scheme="http://yonghong.tech/tags/Android/"/>
    
    <category term="布局" scheme="http://yonghong.tech/tags/%E5%B8%83%E5%B1%80/"/>
    
    <category term="Layout" scheme="http://yonghong.tech/tags/Layout/"/>
    
    <category term="LinearLayout" scheme="http://yonghong.tech/tags/LinearLayout/"/>
    
    <category term="RelativeLayout" scheme="http://yonghong.tech/tags/RelativeLayout/"/>
    
    <category term="FrameLayout" scheme="http://yonghong.tech/tags/FrameLayout/"/>
    
    <category term="TableLayout" scheme="http://yonghong.tech/tags/TableLayout/"/>
    
    <category term="GridLayout" scheme="http://yonghong.tech/tags/GridLayout/"/>
    
    <category term="ConstraintLayout" scheme="http://yonghong.tech/tags/ConstraintLayout/"/>
    
  </entry>
  
  <entry>
    <title>Android 常用组件</title>
    <link href="http://yonghong.tech/2021/07/android-widget/"/>
    <id>http://yonghong.tech/2021/07/android-widget/</id>
    <published>2021-07-30T14:24:00.000Z</published>
    <updated>2021-07-30T14:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h2><p>TextView 基础属性</p><ul><li>layout_width：组件宽度</li><li>layout_height：组件高度</li><li>id：为 TextView 组件设置一个 id</li><li>text：设置显示文本的内容</li><li>textColor：设置字体颜色</li><li>textStyle：设置字体风格：三种可选值：normal, bold, italic</li><li>textSize：字体大小，单位一般是用 sp</li><li>background：控件的背景颜色，可以理解为填充整个控件颜色，可以是图片</li><li>gravity：设置控件中内容对齐方向</li></ul><span id="more"></span><p>带阴影的TextView</p><ul><li>shadowColor：设置阴影的颜色值</li><li>shadowRadius：设置阴影的模糊度</li><li>shadowDx：设置水平偏移</li><li>shadowDy：设置垂直偏移</li></ul><p>跑马灯效果TextView</p><ul><li>singleLine：设置内容单行显示</li><li>focusable：是否可以获得焦点</li><li>focusableInTouchMode：在触摸模式下是否可以获得焦点</li><li>ellipsize：在哪里省略文本</li><li>marqueeRepeatLimit：字幕动画重复次数</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">    android:id=&quot;@+id/tv_one&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:ellipsize=&quot;marquee&quot;</span><br><span class="line">    android:focusable=&quot;true&quot;</span><br><span class="line">    android:focusableInTouchMode=&quot;true&quot;</span><br><span class="line">    android:marqueeRepeatLimit=&quot;marquee_forever&quot;</span><br><span class="line">    android:singleLine=&quot;true&quot;</span><br><span class="line">    android:text=&quot;@string/tv_one&quot;&gt;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">requestFocus</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h2><p>继承 TextView</p><p>三层</p><ul><li>foreground：前景色、前景图片</li><li>text：文字内容</li><li>background：背景色、背景图片</li></ul><p>事件处理</p><ul><li>点击事件：onClickListener，抬起时触发</li><li>长按事件：onLongClickListener，按下指定时长后触发</li><li>触摸事件：onTouchListener<ul><li>按下(ACTION_DOWN, 0)</li><li>抬起(ACTION_UP, 1)</li><li>移动(ACTION_MOVE, 2)</li></ul></li></ul><h2 id="StateListDrawable"><a href="#StateListDrawable" class="headerlink" title="StateListDrawable"></a>StateListDrawable</h2><p>StateListDrawable 是 Drawable 资源的一种，可以根据不同的状态，设置不同的图片效果，关键节点 <code>&lt;selector&gt;</code>，我们只需要将 Button 的 background 属性设置为该 drawable 资源即可</p><p>常用属性</p><ul><li>drawable：引用的 Drawable 资源</li><li>state_focused：是否获得焦点</li><li>state_pressed：控件是否被按下</li><li>state_enabled：控件是否可用</li><li>state_selected：控件是够被选择，针对有滚动的情况</li><li>state_checked：控件是否被勾选</li><li>state_checkable：控件可否被勾选</li><li>state_window_focused：是否获得窗口焦点</li><li>state_active：控件是否处于活跃状态</li><li>state_single：控件包含多个子控件时，确定是否只显示一个控件</li><li>state_first：控件包含多个子控件时，确定第一个控件是否处于显示状态</li><li>state_middle：控件包含多个子控件时，确定中间一个控件是否处于显示状态</li><li>state_last：控件包含多个子控件时，确定最后一个控件是否处于显示状态</li></ul><h2 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h2><p>继承 TextView</p><p>常用属性</p><ul><li>hint：输入提示</li><li>textColorHint：输入提示文字颜色</li><li>inputType：输入类型</li><li>drawableXxxx：在输入框的指定方位添加图片</li><li>drawablePadding：设置图片与文字间距</li><li>padding：设置内容与边框边距</li><li>background：背景色</li></ul><h2 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h2><p>常用属性</p><ul><li>src：设置图片资源</li><li>scaleType：设置图片缩放类型</li><li>maxHeight：最大高度</li><li>maxWidth：最大宽度</li><li>adjustViewBounds：调整View的界限</li></ul><p>缩放类型</p><ul><li>fitStart：保持宽高比缩放图片，缩放完成后在 ImageView 的左上角</li><li>fitCenter：默认，保持宽高比缩放图片，缩放后放于中间</li><li>fitEnd：保持宽高比缩放图片，缩放后在 ImageView 的右下角 </li><li>fitXY：对图像的纵横方向进行独立缩放，使得图片完全适应 ImageView，但是图片宽高比可能会发生变化</li><li>center：保持原图大小，显示在 ImageView 中心，当原图大于 ImageView 的 size，会进行适当裁剪</li><li>centerCrop：保持宽高比缩放图片，直到完全覆盖 ImageView，可能会出现图片显示的不完全</li><li>centerInside：保持宽高比缩放图片，直到 ImageView 能够完全的显示图片</li><li>matrix：不改变原图大小，从 ImageView 左上角开始绘制原图，超出部分做裁剪处理</li></ul><h2 id="ProgressBar"><a href="#ProgressBar" class="headerlink" title="ProgressBar"></a>ProgressBar</h2><p>常用属性</p><ul><li>max：进度条的最大值</li><li>progress：进度条已完成进度</li><li>indeterminate：如果设置成 true，则进度条不精确显示进度</li><li>style=”?android:attr/progressBarStyleHorizontal”：水平进度条</li></ul><h2 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h2><ul><li>NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</li><li>NotificationChannel（Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O）</li><li>NotificationCompat.Builder()</li><li>Notification</li><li>PendingIntent</li></ul><p>通知重要程度设置</p><ul><li>IMPORTANCE_NONE：关闭通知</li><li>IMPORTANCE_MIN：开启通知，不会弹出，没有提示音，状态栏无显示</li><li>IMPORTANCE_LOW：开启通知，不会弹出，没有提示音，状态栏显示</li><li>IMPORTANCE_DEFAULT：开启通知，不会弹出，有提示音，状态栏显示</li><li>IMPORTANCE_HIGH：开启通知，会弹出，有提示音，状态栏显示</li></ul><p>常用属性</p><ul><li>.setContentTitle() 标题</li><li>.setContentText()  内容</li><li>.setSmallIcon()    小图片 使用 alpha 图层</li><li>.setLargeIcon()    大图片 Bitmap</li><li>.setColor()        小图标颜色 Color.parseColor(“#ff0000”)</li><li>.setContentIntent() 跳转意图 PendingIntent</li><li>.setAutoCancel()    自动清除通知</li><li>.setWhen()         通知创建时间</li></ul><h2 id="Toolbar"><a href="#Toolbar" class="headerlink" title="Toolbar"></a>Toolbar</h2><p>常用属性</p><ul><li>id</li><li>layout_width</li><li>layout_height=”?attr/actionBarSize”</li><li>title</li><li>titleMarginStart</li><li>titleTextColor</li><li>subtitle</li><li>subtitleTextColor</li><li>background</li><li>logo</li><li>navigationIcon</li><li>layout_height=”wrap_content”</li><li>android:layout_gravity=”center”</li></ul><h2 id="AlertDialog"><a href="#AlertDialog" class="headerlink" title="AlertDialog"></a>AlertDialog</h2><p>常用属性</p><ul><li>.setIcon()</li><li>.setTitle()</li><li>.setMessage()</li><li>.setView()     自定义布局</li><li>.setPositiveButton()</li><li>.setNegativeButton()</li><li>.setNeutralButton()</li></ul><h2 id="PopUpWindow"><a href="#PopUpWindow" class="headerlink" title="PopUpWindow"></a>PopUpWindow</h2><ul><li>contentView</li><li>width</li><li>height</li><li>focusable</li><li>showAsDropDown</li><li>dismiss</li><li>touchable</li><li>outsideTouchable</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">View popupView = getLayoutInflater().inflate(R.layout.popup_view, <span class="keyword">null</span>);</span><br><span class="line">PopupWindow popupWindow = <span class="keyword">new</span> PopupWindow(popupView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, <span class="keyword">true</span>);</span><br><span class="line">popupWindow.showAsDropDown(view);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;TextView&quot;&gt;&lt;a href=&quot;#TextView&quot; class=&quot;headerlink&quot; title=&quot;TextView&quot;&gt;&lt;/a&gt;TextView&lt;/h2&gt;&lt;p&gt;TextView 基础属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;layout_width：组件宽度&lt;/li&gt;
&lt;li&gt;layout_height：组件高度&lt;/li&gt;
&lt;li&gt;id：为 TextView 组件设置一个 id&lt;/li&gt;
&lt;li&gt;text：设置显示文本的内容&lt;/li&gt;
&lt;li&gt;textColor：设置字体颜色&lt;/li&gt;
&lt;li&gt;textStyle：设置字体风格：三种可选值：normal, bold, italic&lt;/li&gt;
&lt;li&gt;textSize：字体大小，单位一般是用 sp&lt;/li&gt;
&lt;li&gt;background：控件的背景颜色，可以理解为填充整个控件颜色，可以是图片&lt;/li&gt;
&lt;li&gt;gravity：设置控件中内容对齐方向&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Android" scheme="http://yonghong.tech/categories/Android/"/>
    
    
    <category term="Android" scheme="http://yonghong.tech/tags/Android/"/>
    
    <category term="控件" scheme="http://yonghong.tech/tags/%E6%8E%A7%E4%BB%B6/"/>
    
    <category term="Widget" scheme="http://yonghong.tech/tags/Widget/"/>
    
    <category term="TextView" scheme="http://yonghong.tech/tags/TextView/"/>
    
    <category term="Button" scheme="http://yonghong.tech/tags/Button/"/>
    
    <category term="EditText" scheme="http://yonghong.tech/tags/EditText/"/>
    
    <category term="ImageView" scheme="http://yonghong.tech/tags/ImageView/"/>
    
    <category term="ProgressBar" scheme="http://yonghong.tech/tags/ProgressBar/"/>
    
    <category term="Notification" scheme="http://yonghong.tech/tags/Notification/"/>
    
    <category term="Toolbar" scheme="http://yonghong.tech/tags/Toolbar/"/>
    
    <category term="AlertDialog" scheme="http://yonghong.tech/tags/AlertDialog/"/>
    
    <category term="PopUpWindow" scheme="http://yonghong.tech/tags/PopUpWindow/"/>
    
  </entry>
  
  <entry>
    <title>Android Runtime (ART) 和 Dalvik</title>
    <link href="http://yonghong.tech/2021/07/android-runtime-dalvik/"/>
    <id>http://yonghong.tech/2021/07/android-runtime-dalvik/</id>
    <published>2021-07-29T12:00:00.000Z</published>
    <updated>2021-07-29T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android Runtime (ART) 是 Android 上的应用和部分系统服务使用的托管式运行时。ART 及其前身 Dalvik 最初是专为 Android 项目打造的。作为运行时的 ART 可执行 Dalvik 可执行文件并遵循 Dex 字节码规范。</p><p>ART 和 Dalvik 是运行 Dex 字节码的兼容运行时，因此针对 Dalvik 开发的应用也能在 ART 环境中运作。不过，Dalvik 采用的一些技术并不适用于 ART。有关最重要问题的信息，请参阅<span class="exturl" data-url="aHR0cDovL2RldmVsb3Blci5hbmRyb2lkLmNvbS9ndWlkZS9wcmFjdGljZXMvdmVyaWZ5aW5nLWFwcHMtYXJ0Lmh0bWw/aGw9emgtY24=">在 Android Runtime (ART) 上验证应用行为<i class="fa fa-external-link-alt"></i></span>。</p><span id="more"></span><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2UuYW5kcm9pZC5jb20vZGV2aWNlcy90ZWNoL2RhbHZpaz9obD16aC1jbg==">https://source.android.com/devices/tech/dalvik?hl=zh-cn<i class="fa fa-external-link-alt"></i></span></p><h2 id="ART-功能"><a href="#ART-功能" class="headerlink" title="ART 功能"></a>ART 功能</h2><p>以下是 ART 实现的一些主要功能。</p><h3 id="预先-AOT-编译"><a href="#预先-AOT-编译" class="headerlink" title="预先 (AOT) 编译"></a>预先 (AOT) 编译</h3><p>ART 引入了预先编译机制，可提高应用的性能。ART 还具有比 Dalvik 更严格的安装时验证。</p><p>在安装时，ART 使用设备自带的 <strong>dex2oat</strong> 工具来编译应用。此实用工具接受 <span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2UuYW5kcm9pZC5jb20vZGV2aWNlcy90ZWNoL2RhbHZpay9kZXgtZm9ybWF0P2hsPXpoLWNu">DEX<i class="fa fa-external-link-alt"></i></span> 文件作为输入，并为目标设备生成经过编译的应用可执行文件。该工具应能够顺利编译所有有效的 DEX 文件。但是，一些后处理工具会生成无效文件，Dalvik 可以接受这些文件，但 ART 无法编译这些文件。如需了解详情，请参阅<span class="exturl" data-url="aHR0cDovL2RldmVsb3Blci5hbmRyb2lkLmNvbS9ndWlkZS9wcmFjdGljZXMvdmVyaWZ5aW5nLWFwcHMtYXJ0Lmh0bWw/aGw9emgtY24jR0NfTWlncmF0aW9u">处理垃圾回收问题<i class="fa fa-external-link-alt"></i></span>。</p><h3 id="垃圾回收方面的优化"><a href="#垃圾回收方面的优化" class="headerlink" title="垃圾回收方面的优化"></a>垃圾回收方面的优化</h3><p>垃圾回收 (GC) 会耗费大量资源，这可能有损于应用性能，导致显示不稳定、界面响应速度缓慢以及其他问题。ART 通过以下几种方式对垃圾回收做了优化：</p><ul><li>大多采用并发设计，具有一次 GC 暂停</li><li>并发复制，可减少后台内存使用和碎片</li><li>GC 暂停的时间不受堆大小影响</li><li>在清理最近分配的短时对象这种特殊情况中，回收器的总 GC 时间更短</li><li>优化了垃圾回收的工效，能够更加及时地进行并行垃圾回收，这使得 <a href="http://developer.android.com/tools/debugging/debugging-memory.html?hl=zh-cn#LogMessages"><code>GC_FOR_ALLOC</code></a> 事件在典型用例中极为罕见</li></ul><h3 id="开发和调试方面的优化"><a href="#开发和调试方面的优化" class="headerlink" title="开发和调试方面的优化"></a>开发和调试方面的优化</h3><p>ART 提供了大量功能来优化应用开发和调试。</p><h4 id="支持采样分析器"><a href="#支持采样分析器" class="headerlink" title="支持采样分析器"></a>支持采样分析器</h4><p>一直以来，开发者都使用 <span class="exturl" data-url="aHR0cDovL2RldmVsb3Blci5hbmRyb2lkLmNvbS90b29scy9oZWxwL3RyYWNldmlldy5odG1sP2hsPXpoLWNu">Traceview<i class="fa fa-external-link-alt"></i></span> 工具（用于跟踪应用执行情况）作为分析器。虽然 Traceview 可提供有用的信息，但每次方法调用产生的开销会导致 Dalvik 分析结果出现偏差，而且使用该工具明显会影响运行时性能。</p><p>ART 添加了对没有这些限制的专用采样分析器的支持，因而可更准确地了解应用执行情况，而不会明显减慢速度。KitKat 版本为 Dalvik 的 Traceview 添加了采样支持。</p><h4 id="支持更多调试功能"><a href="#支持更多调试功能" class="headerlink" title="支持更多调试功能"></a>支持更多调试功能</h4><p>ART 支持许多新的调试选项，特别是与监控和垃圾回收相关的功能。例如，您可以：</p><ul><li>查看堆栈跟踪中保留了哪些锁，然后跳转到持有锁的线程。</li><li>询问指定类的当前活动的实例数、请求查看实例，以及查看使对象保持有效状态的参考。</li><li>过滤特定实例的事件（如断点）。</li><li>查看方法退出（使用“method-exit”事件）时返回的值。</li><li>设置字段观察点，以在访问和/或修改特定字段时暂停程序执行。</li></ul><h4 id="优化了异常和崩溃报告中的诊断详细信息"><a href="#优化了异常和崩溃报告中的诊断详细信息" class="headerlink" title="优化了异常和崩溃报告中的诊断详细信息"></a>优化了异常和崩溃报告中的诊断详细信息</h4><p>当发生运行时异常时，ART 会为您提供尽可能多的上下文和详细信息。ART 会提供 <code>java.lang.ClassCastException</code>、<code>java.lang.ClassNotFoundException</code> 和 <code>java.lang.NullPointerException</code> 的更多异常详细信息。（较高版本的 Dalvik 会提供 <code>java.lang.ArrayIndexOutOfBoundsException</code> 和 <code>java.lang.ArrayStoreException</code> 的更多异常详细信息，这些信息现在包括数组大小和越界偏移量；ART 也提供这类信息。）</p><p>例如，<code>java.lang.NullPointerException</code> 现在会显示有关应用尝试处理 null 指针时所执行操作的信息，例如应用尝试写入的字段或尝试调用的方法。一些典型示例如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException: Attempt <span class="keyword">to</span> <span class="keyword">write</span> <span class="keyword">to</span> field <span class="string">&#x27;int</span></span><br><span class="line"><span class="string">android.accessibilityservice.AccessibilityServiceInfo.flags&#x27;</span> <span class="keyword">on</span> a null object</span><br><span class="line"><span class="keyword">reference</span></span><br><span class="line">java.lang.NullPointerException: Attempt <span class="keyword">to</span> invoke <span class="keyword">virtual</span> <span class="function"><span class="keyword">method</span></span></span><br><span class="line"><span class="function">&#x27;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span>.<span class="title">toString</span><span class="params">()</span>&#x27; <span class="title">on</span> <span class="title">a</span> <span class="title">null</span> <span class="title">object</span> <span class="title">reference</span></span></span><br></pre></td></tr></table></figure><p>ART 还通过纳入 Java 和原生堆栈信息，在应用原生代码崩溃报告中提供更实用的上下文信息。</p><h2 id="Android-8-0-中的-ART-功能改进"><a href="#Android-8-0-中的-ART-功能改进" class="headerlink" title="Android 8.0 中的 ART 功能改进"></a>Android 8.0 中的 ART 功能改进</h2><p>在 Android 8.0 版本中，Android Runtime (ART) 有了极大改进。下面的列表总结了设备制造商可以在 ART 中获得的增强功能。</p><h3 id="并发压缩式垃圾回收器"><a href="#并发压缩式垃圾回收器" class="headerlink" title="并发压缩式垃圾回收器"></a>并发压缩式垃圾回收器</h3><p>正如 Google 在 Google I/O 大会上所宣布的那样，ART 在 Android 8.0 中提供了新的并发压缩式垃圾回收器 (GC)。该回收器会在每次执行 GC 时以及应用正在运行时对堆进行压缩，且仅在处理线程根时短暂停顿一次。该回收器具有以下优势：</p><ul><li>GC 始终会对堆进行压缩：堆的大小平均比 Android 7.0 中的小 32%。</li><li>得益于压缩，系统现可实现线程局部碰撞指针对象分配：分配速度比 Android 7.0 中的快 70%。</li><li>H2 基准的停顿次数比 Android 7.0 GC 的少 85%。</li><li>停顿次数不再随堆的大小而变化，应用在使用较大的堆时也无需担心造成卡顿。</li><li>GC 实现细节 - 读取屏障：<ul><li>读取屏障是在读取每个对象字段时所做的少量工作。</li><li>它们在编译器中经过了优化，但可能会减慢某些用例的速度。</li></ul></li></ul><h3 id="循环优化"><a href="#循环优化" class="headerlink" title="循环优化"></a>循环优化</h3><p>在 Android 8.0 版本中，ART 采取了多种循环优化措施，具体如下：</p><ul><li>消除边界检查<ul><li>静态：在编译时证明范围位于边界内</li><li>动态：运行时测试确保循环始终位于边界内（否则不进行优化）</li></ul></li><li>消除归纳变量<ul><li>移除无用归纳</li><li>用封闭式表达式替换仅在循环后使用的归纳</li></ul></li><li>消除循环主体内的无用代码，移除整个死循环</li><li>强度降低</li><li>循环转换：逆转、交换、拆分、展开、单模等</li><li>SIMDization（也称为矢量化）</li></ul><p>循环优化器位于 ART 编译器中一个独立的优化环节中。大多数循环优化与其他方面的优化和简化类似。采用比平时更复杂的方式进行一些重写 CFG 的优化时会面临挑战，因为大多数 CFG 实用工具（请参阅 nodes.h）都侧重于构建而不是重写 CFG。</p><h3 id="类层次结构分析"><a href="#类层次结构分析" class="headerlink" title="类层次结构分析"></a>类层次结构分析</h3><p>在 Android 8.0 中，ART 会使用类层次结构分析 (CHA)，这是一种编译器优化，可根据对类层次结构的分析结果，将虚拟调用去虚拟化为直接调用。虚拟调用代价高昂，因为它们围绕 vtable 查找来实现，且会占用几个依赖负载。另外，虚拟调用也不能内嵌。</p><p>以下是对相关增强功能的总结：</p><ul><li>动态单一实现方法状态更新 - 在类关联时间结束时，如果 vtable 已被填充，ART 会按条目对超类的 vtable 进行比较。</li><li>编译器优化 - 编译器会利用某种方法的单一实现信息。如果方法 A.foo 设置了单一实现标记，则编译器会将虚拟调用去虚拟化为直接调用，并借此进一步尝试内嵌直接调用。</li><li>已编译代码无效 - 另外，在类关联时间结束时，如果单一实现信息已更新，且方法 A.foo 之前拥有单一实现，但该状态现已变为无效，则依赖方法 A.foo 拥有单一实现这一假设的所有已编译代码都需要变为无效代码。</li><li>去优化 - 对于堆栈上已编译的有效代码，系统会启动去优化功能，以强制使已编译无效代码进入解释器模式，从而确保正确性。系统会采用结合了同步和异步去优化的全新去优化机制。</li></ul><h3 id="oat-文件中的内嵌缓存"><a href="#oat-文件中的内嵌缓存" class="headerlink" title=".oat 文件中的内嵌缓存"></a>.oat 文件中的内嵌缓存</h3><p>ART 现在采用内嵌缓存，并对有足够数据可用的调用站点进行优化。内嵌缓存功能会将额外的运行时信息记录到配置文件中，并利用这类信息将动态优化添加到预先编译中。</p><h3 id="Dexlayout"><a href="#Dexlayout" class="headerlink" title="Dexlayout"></a>Dexlayout</h3><p>Dexlayout 是在 Android 8.0 中引入的一个库，用于分析 dex 文件，并根据配置文件对其进行重新排序。Dexlayout 旨在使用运行时配置信息，在设备的空闲维护编译期间对 dex 文件的各个部分进行重新排序。通过将经常一起访问的部分 dex 文件集中在一起，程序可以因改进文件位置而拥有更好的内存访问模式，从而节省 RAM 并缩短启动时间。</p><p>由于配置文件信息目前仅在运行应用后可用，因此系统会在空闲维护期间将 dexlayout 集成到 dex2oat 的设备编译中。</p><h3 id="Dex-缓存移除"><a href="#Dex-缓存移除" class="headerlink" title="Dex 缓存移除"></a>Dex 缓存移除</h3><p>在 Android 7.0 及更低版本中，DexCache 对象拥有四个大型数组，与 DexFile 中特定元素的数量成正比，即：</p><ul><li>字符串（每个 DexFile::StringId 一个引用），</li><li>类型（每个 DexFile::TypeId 一个引用），</li><li>方法（每个 DexFile::MethodId 一个原生指针），</li><li>字段（每个 DexFile::FieldId 一个原生指针）。</li></ul><p>这些数组用于快速检索我们以前解析的对象。在 Android 8.0 中，除方法数组外，所有数组都已移除。</p><h3 id="解释器性能"><a href="#解释器性能" class="headerlink" title="解释器性能"></a>解释器性能</h3><p>在 Android 7.0 版本中，通过引入 mterp（一种解释器，具有以汇编语言编写的核心提取/解码/解释机制），解释器性能得以显著提升。Mterp 模仿了快速 Dalvik 解释器，并支持 arm、arm64、x86、x86_64、mips 和 mips64。对于计算代码而言，ART 的 Mterp 大致相当于 Dalvik 的快速解释器。不过，有时候，它的速度可能会显著变慢，甚至急剧变慢：</p><ol><li>调用性能。</li><li>字符串操作和 Dalvik 中其他被视为内嵌函数的高频用户方法。</li><li>堆栈内存使用量较高。</li></ol><p>Android 8.0 解决了这些问题。</p><h3 id="详细了解内嵌"><a href="#详细了解内嵌" class="headerlink" title="详细了解内嵌"></a>详细了解内嵌</h3><p>从 Android 6.0 开始，ART 可以内嵌同一个 dex 文件中的任何调用，但只能内嵌来自其他 dex 文件的叶方法。此项限制具有以下两个原因：</p><ol><li>从其他 dex 文件进行内嵌要求使用该 dex 文件的 dex 缓存，这与同一个 dex 文件内嵌（只需重复使用调用方的 dex 缓存）有所不同。已编译代码中需要具有 dex 缓存，以便执行一系列指令，例如静态调用、字符串加载或类加载。</li><li>堆栈映射只对当前 dex 文件中的方法索引进行编码。</li></ol><p>为了应对这些限制，Android 8.0 做出了以下改进：</p><ol><li>从已编译代码中移除 dex 缓存访问（另请参阅“Dex 缓存移除”部分）</li><li>扩展堆栈映射编码。</li></ol><h3 id="同步方面的改进"><a href="#同步方面的改进" class="headerlink" title="同步方面的改进"></a>同步方面的改进</h3><p>ART 团队调整了 MonitorEnter/MonitorExit 代码路径，并减少了我们对 ARMv8 上传统内存屏障的依赖，尽可能将其替换为较新的（获取/释放）指令。</p><h3 id="更快速的原生方法"><a href="#更快速的原生方法" class="headerlink" title="更快速的原生方法"></a>更快速的原生方法</h3><p>使用 <a href="https://android.googlesource.com/platform/libcore/+/master/dalvik/src/main/java/dalvik/annotation/optimization/FastNative.java"><code>@FastNative</code></a> 和 <a href="https://android.googlesource.com/platform/libcore/+/master/dalvik/src/main/java/dalvik/annotation/optimization/CriticalNative.java"><code>@CriticalNative</code></a> 注解可以更快速地对 Java 原生接口 (JNI) 进行原生调用。这些内置的 ART 运行时优化可以加快 JNI 转换速度，并取代了现已弃用的 !bang JNI 标记。这些注解对非原生方法没有任何影响，并且仅适用于 <code>bootclasspath</code> 上的平台 Java 语言代码（无 Play 商店更新）。</p><p><code>@FastNative</code> 注解支持非静态方法。如果某种方法将 <code>jobject</code> 作为参数或返回值进行访问，请使用此注解。</p><p>利用 <code>@CriticalNative</code> 注解，可更快速地运行原生方法，但存在以下限制：</p><ul><li>方法必须是静态方法 - 没有参数、返回值或隐式 <code>this</code> 的对象。</li><li>仅将基元类型传递给原生方法。</li><li>原生方法在其函数定义中不使用 <code>JNIEnv</code> 和 <code>jclass</code> 参数。</li><li>方法必须使用 <code>RegisterNatives</code> 进行注册，而不是依靠动态 JNI 链接。</li></ul><p><code>@FastNative</code> 和 <code>@CriticalNative</code> 注解在执行原生方法时会停用垃圾回收。不要与长时间运行的方法一起使用，包括通常很快但一般不受限制的方法。</p><p>停顿垃圾回收可能会导致死锁。如果锁尚未得到本地释放（即尚未返回受管理代码），请勿在原生快速调用期间获取锁。此要求不适用于常规的 JNI 调用，因为 ART 将正执行的原生代码视为已暂停的状态。</p><p><code>@FastNative</code> 可以使原生方法的性能提升高达 3 倍，而 <code>@CriticalNative</code> 可以使原生方法的性能提升高达 5 倍。例如，在 Nexus 6P 设备上测量的 JNI 转换如下：</p><table><thead><tr><th align="left">Java 原生接口 (JNI) 调用</th><th align="left">执行时间（以纳秒计）</th></tr></thead><tbody><tr><td align="left">常规 JNI</td><td align="left">115</td></tr><tr><td align="left">!bang JNI</td><td align="left">60</td></tr><tr><td align="left"><code>@FastNative</code></td><td align="left">35</td></tr><tr><td align="left"><code>@CriticalNative</code></td><td align="left">25</td></tr></tbody></table><h2 id="调试-ART-垃圾回收"><a href="#调试-ART-垃圾回收" class="headerlink" title="调试 ART 垃圾回收"></a>调试 ART 垃圾回收</h2><p>本页介绍了如何调试 Android 运行时 (ART) 垃圾回收 (GC) 的正确性和性能问题。此外，还说明了如何使用 GC 验证选项、确定应对 GC 验证失败的解决方案，以及衡量并解决 GC 性能问题。</p><p>如需使用 ART，请参阅此 <span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2UuYW5kcm9pZC5jb20vZGV2aWNlcy90ZWNoL2RhbHZpaz9obD16aC1jbg==">ART 和 Dalvik<i class="fa fa-external-link-alt"></i></span> 部分中介绍的内容，以及 <span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2UuYW5kcm9pZC5jb20vZGV2aWNlcy90ZWNoL2RhbHZpay9kZXgtZm9ybWF0P2hsPXpoLWNu">Dalvik 可执行文件格式<i class="fa fa-external-link-alt"></i></span>。如需获得验证应用行为方面的其他帮助，请参阅<span class="exturl" data-url="aHR0cDovL2RldmVsb3Blci5hbmRyb2lkLmNvbS9ndWlkZS9wcmFjdGljZXMvdmVyaWZ5aW5nLWFwcHMtYXJ0P2hsPXpoLWNu">在 Android Runtime (ART) 上验证应用行为<i class="fa fa-external-link-alt"></i></span>。</p><h3 id="ART-GC-概览"><a href="#ART-GC-概览" class="headerlink" title="ART GC 概览"></a>ART GC 概览</h3><p>ART 有多个不同的 GC 方案，涉及运行不同的垃圾回收器。从 Android 8 (Oreo) 开始，默认方案是并发复制 (CC)。另一个 GC 方案是并发标记清除 (CMS)。</p><p>并发复制 GC 的一些主要特性包括：</p><ul><li>CC 支持使用名为“RegionTLAB”的触碰指针分配器。此分配器可以向每个应用线程分配一个线程本地分配缓冲区 (TLAB)，这样，应用线程只需触碰“栈顶”指针，而无需任何同步操作，即可从其 TLAB 中将对象分配出去。</li><li>CC 通过在不暂停应用线程的情况下并发复制对象来执行堆碎片整理。这是在读取屏障的帮助下实现的，读取屏障会拦截来自堆的引用读取，无需应用开发者进行任何干预。</li><li>GC 只有一次很短的暂停，对于堆大小而言，该次暂停在时间上是一个常量。</li><li>在 Android 10 及更高版本中，CC 会扩展为分代 GC。它支持轻松回收存留期较短的对象，这类对象通常很快便会无法访问。这有助于提高 GC 吞吐量，并显著延迟执行全堆 GC 的需要。</li></ul><p>ART 仍然支持的另一个 GC 方案是 CMS。此 GC 方案还支持压缩，但不是以并发方式。在应用进入后台之前，它会避免执行压缩，应用进入后台后，它会暂停应用线程以执行压缩。如果对象分配因碎片而失败，也必须执行压缩操作。在这种情况下，应用可能会在一段时间内没有响应。</p><p>由于 CMS 很少进行压缩，因此空闲对象可能会不连续。CMS 使用一个名为 RosAlloc 的基于空闲列表的分配器。与 RegionTLAB 相比，该分配器的分配成本较高。最后，由于内部碎片，Java 堆的 CMS 内存用量可能会高于 CC 内存用量。</p><h3 id="GC-验证和性能选项"><a href="#GC-验证和性能选项" class="headerlink" title="GC 验证和性能选项"></a>GC 验证和性能选项</h3><h4 id="更改-GC-类型"><a href="#更改-GC-类型" class="headerlink" title="更改 GC 类型"></a>更改 GC 类型</h4><p>原始设备制造商 (OEM) 可以更改 GC 类型。如需进行更改，需要在构建时设置 <code>ART_USE_READ_BARRIER</code> 环境变量。默认值为 true，这会启用 CC 回收器，因为该回收器使用读取屏障。对于 CMS，此变量应明确设置为 false。</p><p>默认情况下，在 Android 10 及更高版本中，CC 回收器在分代模式下运行。如需停用分代模式，可以使用 <code>-Xgc:nogenerational_cc</code> 命令行参数。或者，也可以按如下方式设置系统属性：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">adb</span> shell setprop dalvik.vm.gc<span class="keyword">type</span> nogenerational_cc</span><br></pre></td></tr></table></figure><p>CMS 回收器始终在分代模式下运行。</p><h4 id="验证堆"><a href="#验证堆" class="headerlink" title="验证堆"></a>验证堆</h4><p>堆验证可能是调试 GC 相关错误或堆损坏的最有用的 GC 选项。启用堆验证会使 GC 在垃圾回收过程中在几个点检查堆的正确性。堆验证的选项与更改 GC 类型的相同。启用后，堆验证流程会验证根，并确保可访问对象仅引用了其他可访问对象。您可以通过传入以下 <code>-Xgc</code> 值来启用 GC 验证：</p><ul><li>启用后，<code>[no]preverify</code> 将在启动 GC 之前执行堆验证。</li><li>启用后，<code>[no]presweepingverify</code> 将在开始垃圾回收器清除过程之前执行堆验证。</li><li>启用后，<code>[no]postverify</code> 将在 GC 完成清除之后执行堆验证。</li><li><code>[no]preverify_rosalloc</code>、<code>[no]postsweepingverify_rosalloc</code> 和 <code>[no]postverify_rosalloc</code> 是附加 GC 选项，仅验证 RosAlloc 内部记录的状态。因此，它们仅适用于使用 RosAlloc 分配器的 CMS 回收器。验证的主要内容是，魔法值是否与预期常量匹配，以及可用内存块是否已全部在 <code>free_page_runs_</code> 映射中注册。</li></ul><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>衡量 GC 性能的工具主要有两个：GC 时序转储和 Systrace。Systrace 还有一个高级版本，称为 Perfetto。如需衡量 GC 性能问题，直观的方法是使用 Systrace 和 Perfetto 确定哪些 GC 会导致长时间暂停或抢占应用线程。尽管 ART GC 经过多年发展已得到显著改进，但不良更改器行为（例如过度分配）仍会导致性能问题</p><h4 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h4><p>CC GC 通过运行新生代 GC 或全堆 GC 来回收垃圾。理想情况下，新生代 GC 的运行频率更高。GC 会一直执行新生代 CC 回收，直到刚结束的回收周期的吞吐量（计算公式是：释放的字节数除以 GC 持续秒数）小于全堆 CC 回收的平均吞吐量。发生这种情况时，将为下一次并发 GC 选择全堆 CC（而不是新生代 CC）。全堆回收完成后，下一次 GC 将切换回新生代 CC。新生代 CC 在完成后不会调整堆占用空间限制，这是此策略发挥作用的一个关键因素。这使得新生代 CC 运行得越来越频繁，直到吞吐量低于全堆 CC，最终导致堆增大。</p><h4 id="使用-SIGQUIT-获取-GC-性能信息"><a href="#使用-SIGQUIT-获取-GC-性能信息" class="headerlink" title="使用 SIGQUIT 获取 GC 性能信息"></a>使用 SIGQUIT 获取 GC 性能信息</h4><p>如需获得应用的 GC 性能时序，请将 <code>SIGQUIT</code> 发送到已在运行的应用，或者在启动命令行程序时将 <code>-XX:DumpGCPerformanceOnShutdown</code> 传递给 <code>dalvikvm</code>。当应用获得 ANR 请求信号 (<code>SIGQUIT</code>) 时，会转储与其锁定、线程堆栈和 GC 性能相关的信息。</p><p>如需获得 GC 时序转储，请使用以下命令：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell <span class="keyword">kill</span> -<span class="keyword">S</span> <span class="keyword">QUIT</span> PID</span><br></pre></td></tr></table></figure><p>这会在 <code>/data/anr/</code> 中创建一个文件（名称中会包含日期和时间，例如 anr_2020-07-13-19-23-39-817）。此文件包含一些 ANR 转储信息以及 GC 时序。您可以通过搜索“Dumping cumulative Gc timings”（转储累计 GC 时序）来确定 GC 时序。这些时序会显示一些需要关注的内容，包括每个 GC 类型的阶段和暂停时间的直方图信息。暂停信息通常比较重要。例如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">young</span> concurrent copying paused:Sum: <span class="number">5</span>.<span class="number">491</span>ms <span class="number">99</span>% C.I. <span class="number">1</span>.<span class="number">464</span>ms-<span class="number">2</span>.<span class="number">133</span>ms Avg: <span class="number">1</span>.<span class="number">830</span>ms Max: <span class="number">2</span>.<span class="number">133</span>ms</span><br></pre></td></tr></table></figure><p>本示例中显示平均暂停时间为 1.83 毫秒，该值应该足够低，在大多数应用中不会导致丢帧，因此您不必担心。</p><p>需要关注的另一个方面是挂起时间，挂起时间测量在 GC 要求某个线程挂起后，该线程到达挂起点所需的时间。此时间包含在 GC 暂停时间中，所以对于确定长时间暂停是由 GC 缓慢还是线程挂起缓慢造成的很有用。以下是 Nexus 5 上的正常挂起时间示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">suspend</span> <span class="literal">all</span> histogram:Sum: <span class="number">1</span>.<span class="number">513</span>ms <span class="number">99</span>% C.I. <span class="number">3</span>us-<span class="number">546</span>.<span class="number">560</span>us Avg: <span class="number">47</span>.<span class="number">281</span>us Max: <span class="number">601</span>us</span><br></pre></td></tr></table></figure><p>还有其他一些需要关注的方面，包括总耗时和 GC 吞吐量。示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Total</span> time spent in GC: <span class="number">502</span>.<span class="number">251</span>ms</span><br><span class="line"><span class="attribute">Mean</span> GC size throughput: <span class="number">92</span>MB/s</span><br><span class="line"><span class="attribute">Mean</span> GC object throughput: <span class="number">1</span>.<span class="number">54702</span>e+<span class="number">06</span> objects/s</span><br></pre></td></tr></table></figure><p>以下示例说明了如何转储已在运行的应用的 GC 时序：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">adb</span> shell kill -s QUIT PID</span><br><span class="line"><span class="attribute">adb</span> pull /data/anr/anr_<span class="number">2020</span>-<span class="number">07</span>-<span class="number">13</span>-<span class="number">19</span>-<span class="number">23</span>-<span class="number">39</span>-<span class="number">817</span></span><br></pre></td></tr></table></figure><p>此时，GC 时序在 <code>anr_2020-07-13-19-23-39-817</code> 中。以下是 Google 地图的输出示例：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Start</span> <span class="variable">Dumping</span> <span class="variable">histograms</span> <span class="variable">for</span> <span class="number">2195</span> <span class="variable">iterations</span> <span class="variable">for</span> <span class="variable">concurrent</span> <span class="variable">copying</span></span><br><span class="line"><span class="variable">MarkingPhase</span><span class="operator">:</span>   <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">258.127</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">58.854</span><span class="variable">ms</span><span class="operator">-</span><span class="number">352.575</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">117.651</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">641.940</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">ScanCardsForSpace</span><span class="operator">:</span>      <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">85.966</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">15.121</span><span class="variable">ms</span><span class="operator">-</span><span class="number">112.080</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">39.164</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">662.555</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">ScanImmuneSpaces</span><span class="operator">:</span>       <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">79.066</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">7.614</span><span class="variable">ms</span><span class="operator">-</span><span class="number">57.658</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">18.014</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">546.276</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">ProcessMarkStack</span><span class="operator">:</span>       <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">49.308</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">6.439</span><span class="variable">ms</span><span class="operator">-</span><span class="number">81.640</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">22.464</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">638.448</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">ClearFromSpace</span><span class="operator">:</span> <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">35.068</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">6.522</span><span class="variable">ms</span><span class="operator">-</span><span class="number">40.040</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">15.976</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">633.665</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">SweepSystemWeaks</span><span class="operator">:</span>       <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">14.209</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">3.224</span><span class="variable">ms</span><span class="operator">-</span><span class="number">15.210</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">6.473</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">201.738</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">CaptureThreadRootsForMarking</span><span class="operator">:</span>   <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">11.067</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">0.835</span><span class="variable">ms</span><span class="operator">-</span><span class="number">13.902</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">5.044</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">25.565</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">VisitConcurrentRoots</span><span class="operator">:</span>   <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">8.588</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">1.260</span><span class="variable">ms</span><span class="operator">-</span><span class="number">8.547</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">1.956</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">231.593</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">ProcessReferences</span><span class="operator">:</span>      <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">7.868</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">0.002</span><span class="variable">ms</span><span class="operator">-</span><span class="number">8.336</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">1.792</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">17.376</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">EnqueueFinalizerReferences</span><span class="operator">:</span>     <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">3.976</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">0.691</span><span class="variable">ms</span><span class="operator">-</span><span class="number">8.005</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">1.811</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">16.540</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">GrayAllDirtyImmuneObjects</span><span class="operator">:</span>      <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">3.721</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">0.622</span><span class="variable">ms</span><span class="operator">-</span><span class="number">6.702</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">1.695</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">14.893</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">SweepLargeObjects</span><span class="operator">:</span>      <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">3.202</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">0.032</span><span class="variable">ms</span><span class="operator">-</span><span class="number">6.388</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">1.458</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">549.851</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">FlipOtherThreads</span><span class="operator">:</span>       <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">2.265</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">0.487</span><span class="variable">ms</span><span class="operator">-</span><span class="number">3.702</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">1.031</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">6.327</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">VisitNonThreadRoots</span><span class="operator">:</span>    <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">1.883</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">45</span><span class="variable">us</span><span class="operator">-</span><span class="number">3207.333</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">429.210</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">27524</span><span class="variable">us</span></span><br><span class="line"><span class="variable">InitializePhase</span><span class="operator">:</span>        <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">1.624</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">231.171</span><span class="variable">us</span><span class="operator">-</span><span class="number">2751.250</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">740.220</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">6961</span><span class="variable">us</span></span><br><span class="line"><span class="variable">ForwardSoftReferences</span><span class="operator">:</span>  <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">1.071</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">215.113</span><span class="variable">us</span><span class="operator">-</span><span class="number">2175.625</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">488.362</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">7441</span><span class="variable">us</span></span><br><span class="line"><span class="variable">ReclaimPhase</span><span class="operator">:</span>   <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">490.854</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">32.029</span><span class="variable">us</span><span class="operator">-</span><span class="number">6373.807</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">223.623</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">362851</span><span class="variable">us</span></span><br><span class="line"><span class="variable">EmptyRBMarkBitStack</span><span class="operator">:</span>    <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">479.736</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">11</span><span class="variable">us</span><span class="operator">-</span><span class="number">3202.500</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">218.558</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">13652</span><span class="variable">us</span></span><br><span class="line"><span class="variable">CopyingPhase</span><span class="operator">:</span>   <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">399.163</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">24</span><span class="variable">us</span><span class="operator">-</span><span class="number">4602.500</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">181.851</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">22865</span><span class="variable">us</span></span><br><span class="line"><span class="variable">ThreadListFlip</span><span class="operator">:</span> <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">295.609</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">15</span><span class="variable">us</span><span class="operator">-</span><span class="number">2134.999</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">134.673</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">13578</span><span class="variable">us</span></span><br><span class="line"><span class="variable">ResumeRunnableThreads</span><span class="operator">:</span>  <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">238.329</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">5</span><span class="variable">us</span><span class="operator">-</span><span class="number">2351.250</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">108.578</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">10539</span><span class="variable">us</span></span><br><span class="line"><span class="variable">ResumeOtherThreads</span><span class="operator">:</span>     <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">207.915</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">1.072</span><span class="variable">us</span><span class="operator">-</span><span class="number">3602.499</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">94.722</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">14179</span><span class="variable">us</span></span><br><span class="line"><span class="variable">RecordFree</span><span class="operator">:</span>     <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">188.009</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">64</span><span class="variable">us</span><span class="operator">-</span><span class="number">312.812</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">85.653</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">2709</span><span class="variable">us</span></span><br><span class="line"><span class="variable">MarkZygoteLargeObjects</span><span class="operator">:</span> <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">133.301</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">12</span><span class="variable">us</span><span class="operator">-</span><span class="number">734.999</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">60.729</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">10169</span><span class="variable">us</span></span><br><span class="line"><span class="variable">MarkStackAsLive</span><span class="operator">:</span>        <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">127.554</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">13</span><span class="variable">us</span><span class="operator">-</span><span class="number">417.083</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">58.111</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">1728</span><span class="variable">us</span></span><br><span class="line"><span class="variable">FlipThreadRoots</span><span class="operator">:</span>        <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">126.119</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">1.028</span><span class="variable">us</span><span class="operator">-</span><span class="number">3202.499</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">57.457</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">11412</span><span class="variable">us</span></span><br><span class="line"><span class="variable">SweepAllocSpace</span><span class="operator">:</span>        <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">117.761</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">24</span><span class="variable">us</span><span class="operator">-</span><span class="number">400.624</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">53.649</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">1541</span><span class="variable">us</span></span><br><span class="line"><span class="variable">SwapBitmaps</span><span class="operator">:</span>    <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">56.301</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">10</span><span class="variable">us</span><span class="operator">-</span><span class="number">125.312</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">25.649</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">1475</span><span class="variable">us</span></span><br><span class="line"><span class="punctuation">(</span><span class="variable">Paused</span><span class="punctuation">)</span><span class="variable">GrayAllNewlyDirtyImmuneObjects</span><span class="operator">:</span> <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">33.047</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">9</span><span class="variable">us</span><span class="operator">-</span><span class="number">49.931</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">15.055</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">72</span><span class="variable">us</span></span><br><span class="line"><span class="punctuation">(</span><span class="variable">Paused</span><span class="punctuation">)</span><span class="variable">SetFromSpace</span><span class="operator">:</span>   <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">11.651</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">2</span><span class="variable">us</span><span class="operator">-</span><span class="number">49.772</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">5.307</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">71</span><span class="variable">us</span></span><br><span class="line"><span class="punctuation">(</span><span class="variable">Paused</span><span class="punctuation">)</span><span class="variable">FlipCallback</span><span class="operator">:</span>   <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">7.693</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">2</span><span class="variable">us</span><span class="operator">-</span><span class="number">32</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">3.504</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">32</span><span class="variable">us</span></span><br><span class="line"><span class="punctuation">(</span><span class="variable">Paused</span><span class="punctuation">)</span><span class="variable">ClearCards</span><span class="operator">:</span>     <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">6.371</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">250</span><span class="variable">ns</span><span class="operator">-</span><span class="number">49753</span><span class="variable">ns</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">207</span><span class="variable">ns</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">188000</span><span class="variable">ns</span></span><br><span class="line"><span class="variable">Sweep</span><span class="operator">:</span>  <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">5.793</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">1</span><span class="variable">us</span><span class="operator">-</span><span class="number">49.818</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">2.639</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">93</span><span class="variable">us</span></span><br><span class="line"><span class="variable">UnBindBitmaps</span><span class="operator">:</span>  <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">5.255</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">1</span><span class="variable">us</span><span class="operator">-</span><span class="number">31</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">2.394</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">31</span><span class="variable">us</span></span><br><span class="line"><span class="variable">Done</span> <span class="variable">Dumping</span> <span class="variable">histograms</span></span><br><span class="line"><span class="variable">concurrent</span> <span class="variable">copying</span> <span class="variable">paused</span><span class="operator">:</span>      <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">315.249</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">49</span><span class="variable">us</span><span class="operator">-</span><span class="number">1378.125</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">143.621</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">7722</span><span class="variable">us</span></span><br><span class="line"><span class="variable">concurrent</span> <span class="variable">copying</span> <span class="variable">freed</span><span class="operator">-</span><span class="variable">bytes</span><span class="operator">:</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">34</span><span class="variable">MB</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">54</span><span class="variable">MB</span> <span class="built_in">Min</span><span class="operator">:</span> <span class="number">2062</span><span class="variable">KB</span></span><br><span class="line"><span class="variable">Freed</span><span class="operator">-</span><span class="variable">bytes</span> <span class="variable">histogram</span><span class="operator">:</span> <span class="number">0</span><span class="operator">:</span><span class="number">4</span><span class="operator">,</span><span class="number">5120</span><span class="operator">:</span><span class="number">5</span><span class="operator">,</span><span class="number">10240</span><span class="operator">:</span><span class="number">19</span><span class="operator">,</span><span class="number">15360</span><span class="operator">:</span><span class="number">69</span><span class="operator">,</span><span class="number">20480</span><span class="operator">:</span><span class="number">167</span><span class="operator">,</span><span class="number">25600</span><span class="operator">:</span><span class="number">364</span><span class="operator">,</span><span class="number">30720</span><span class="operator">:</span><span class="number">529</span><span class="operator">,</span><span class="number">35840</span><span class="operator">:</span><span class="number">405</span><span class="operator">,</span><span class="number">40960</span><span class="operator">:</span><span class="number">284</span><span class="operator">,</span><span class="number">46080</span><span class="operator">:</span><span class="number">311</span><span class="operator">,</span><span class="number">51200</span><span class="operator">:</span><span class="number">38</span></span><br><span class="line"><span class="variable">concurrent</span> <span class="variable">copying</span> <span class="variable">total</span> <span class="variable">time</span><span class="operator">:</span> <span class="number">569.947</span><span class="variable">s</span> <span class="variable">mean</span> <span class="variable">time</span><span class="operator">:</span> <span class="number">259.657</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">concurrent</span> <span class="variable">copying</span> <span class="variable">freed</span><span class="operator">:</span> <span class="number">1453160493</span> <span class="variable">objects</span> <span class="variable">with</span> <span class="variable">total</span> <span class="variable">size</span> <span class="number">74</span><span class="variable">GB</span></span><br><span class="line"><span class="variable">concurrent</span> <span class="variable">copying</span> <span class="variable">throughput</span><span class="operator">:</span> <span class="number">2.54964</span><span class="variable">e</span><span class="operator">+</span><span class="number">06</span><span class="operator">/</span><span class="variable">s</span> <span class="operator">/</span> <span class="number">134</span><span class="variable">MB</span><span class="operator">/</span><span class="variable">s</span>  <span class="variable">per</span> <span class="variable">cpu</span><span class="operator">-</span><span class="variable">time</span><span class="operator">:</span> <span class="number">157655668</span><span class="operator">/</span><span class="variable">s</span> <span class="operator">/</span> <span class="number">150</span><span class="variable">MB</span><span class="operator">/</span><span class="variable">s</span></span><br><span class="line"><span class="variable">Average</span> <span class="variable">major</span> <span class="variable">GC</span> <span class="variable">reclaim</span> <span class="variable">bytes</span> <span class="variable">ratio</span> <span class="number">0.486928</span> <span class="variable">over</span> <span class="number">2195</span> <span class="variable">GC</span> <span class="variable">cycles</span></span><br><span class="line"><span class="variable">Average</span> <span class="variable">major</span> <span class="variable">GC</span> <span class="variable">copied</span> <span class="variable">live</span> <span class="variable">bytes</span> <span class="variable">ratio</span> <span class="number">0.0894662</span> <span class="variable">over</span> <span class="number">2199</span> <span class="variable">major</span> <span class="variable">GCs</span></span><br><span class="line"><span class="variable">Cumulative</span> <span class="variable">bytes</span> <span class="variable">moved</span> <span class="number">6586367960</span></span><br><span class="line"><span class="variable">Cumulative</span> <span class="variable">objects</span> <span class="variable">moved</span> <span class="number">127490240</span></span><br><span class="line"><span class="variable">Peak</span> <span class="variable">regions</span> <span class="variable">allocated</span> <span class="number">376</span> <span class="punctuation">(</span><span class="number">94</span><span class="variable">MB</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="number">2048</span> <span class="punctuation">(</span><span class="number">512</span><span class="variable">MB</span><span class="punctuation">)</span></span><br><span class="line"><span class="variable">Start</span> <span class="variable">Dumping</span> <span class="variable">histograms</span> <span class="variable">for</span> <span class="number">685</span> <span class="variable">iterations</span> <span class="variable">for</span> <span class="variable">young</span> <span class="variable">concurrent</span> <span class="variable">copying</span></span><br><span class="line"><span class="variable">ScanCardsForSpace</span><span class="operator">:</span>      <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">26.288</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">8.617</span><span class="variable">ms</span><span class="operator">-</span><span class="number">77.759</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">38.377</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">432.991</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">ProcessMarkStack</span><span class="operator">:</span>       <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">21.829</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">2.116</span><span class="variable">ms</span><span class="operator">-</span><span class="number">71.119</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">31.868</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">98.679</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">ClearFromSpace</span><span class="operator">:</span> <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">19.420</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">5.480</span><span class="variable">ms</span><span class="operator">-</span><span class="number">50.293</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">28.351</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">507.330</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">ScanImmuneSpaces</span><span class="operator">:</span>       <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">9.968</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">8.155</span><span class="variable">ms</span><span class="operator">-</span><span class="number">30.639</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">14.552</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">46.676</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">SweepSystemWeaks</span><span class="operator">:</span>       <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">6.741</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">3.655</span><span class="variable">ms</span><span class="operator">-</span><span class="number">14.715</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">9.841</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">22.142</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">GrayAllDirtyImmuneObjects</span><span class="operator">:</span>      <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">4.466</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">0.584</span><span class="variable">ms</span><span class="operator">-</span><span class="number">14.315</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">6.519</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">24.355</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">FlipOtherThreads</span><span class="operator">:</span>       <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">3.672</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">0.631</span><span class="variable">ms</span><span class="operator">-</span><span class="number">16.630</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">5.361</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">18.513</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">ProcessReferences</span><span class="operator">:</span>      <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">2.806</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">0.001</span><span class="variable">ms</span><span class="operator">-</span><span class="number">9.459</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">2.048</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">11.951</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">EnqueueFinalizerReferences</span><span class="operator">:</span>     <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">1.857</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">0.424</span><span class="variable">ms</span><span class="operator">-</span><span class="number">8.609</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">2.711</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">24.063</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">VisitConcurrentRoots</span><span class="operator">:</span>   <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">1.094</span><span class="variable">s</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">1.306</span><span class="variable">ms</span><span class="operator">-</span><span class="number">5.357</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">1.598</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">6.831</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">SweepArray</span><span class="operator">:</span>     <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">711.032</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">0.022</span><span class="variable">ms</span><span class="operator">-</span><span class="number">3.502</span><span class="variable">ms</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">1.038</span><span class="variable">ms</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">7.307</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">InitializePhase</span><span class="operator">:</span>        <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">667.346</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">303</span><span class="variable">us</span><span class="operator">-</span><span class="number">2643.749</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">974.227</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">3199</span><span class="variable">us</span></span><br><span class="line"><span class="variable">VisitNonThreadRoots</span><span class="operator">:</span>    <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">388.145</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">103.911</span><span class="variable">us</span><span class="operator">-</span><span class="number">1385.833</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">566.635</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">5374</span><span class="variable">us</span></span><br><span class="line"><span class="variable">ThreadListFlip</span><span class="operator">:</span> <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">202.730</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">18</span><span class="variable">us</span><span class="operator">-</span><span class="number">2414.999</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">295.956</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">6780</span><span class="variable">us</span></span><br><span class="line"><span class="variable">EmptyRBMarkBitStack</span><span class="operator">:</span>    <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">132.934</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">8</span><span class="variable">us</span><span class="operator">-</span><span class="number">1757.499</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">194.064</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">8495</span><span class="variable">us</span></span><br><span class="line"><span class="variable">ResumeRunnableThreads</span><span class="operator">:</span>  <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">109.593</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">6</span><span class="variable">us</span><span class="operator">-</span><span class="number">4719.999</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">159.989</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">11106</span><span class="variable">us</span></span><br><span class="line"><span class="variable">ResumeOtherThreads</span><span class="operator">:</span>     <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">86.733</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">3</span><span class="variable">us</span><span class="operator">-</span><span class="number">4114.999</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">126.617</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">19332</span><span class="variable">us</span></span><br><span class="line"><span class="variable">ForwardSoftReferences</span><span class="operator">:</span>  <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">69.686</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">14</span><span class="variable">us</span><span class="operator">-</span><span class="number">2014.999</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">101.731</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">4723</span><span class="variable">us</span></span><br><span class="line"><span class="variable">RecordFree</span><span class="operator">:</span>     <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">58.889</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">0.500</span><span class="variable">us</span><span class="operator">-</span><span class="number">185.833</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">42.984</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">769</span><span class="variable">us</span></span><br><span class="line"><span class="variable">FlipThreadRoots</span><span class="operator">:</span>        <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">58.540</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">1.034</span><span class="variable">us</span><span class="operator">-</span><span class="number">4314.999</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">85.459</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">10224</span><span class="variable">us</span></span><br><span class="line"><span class="variable">CopyingPhase</span><span class="operator">:</span>   <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">52.227</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">26</span><span class="variable">us</span><span class="operator">-</span><span class="number">728.749</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">76.243</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">2060</span><span class="variable">us</span></span><br><span class="line"><span class="variable">ReclaimPhase</span><span class="operator">:</span>   <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">37.207</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">7</span><span class="variable">us</span><span class="operator">-</span><span class="number">2322.499</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">54.316</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">3826</span><span class="variable">us</span></span><br><span class="line"><span class="punctuation">(</span><span class="variable">Paused</span><span class="punctuation">)</span><span class="variable">GrayAllNewlyDirtyImmuneObjects</span><span class="operator">:</span> <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">23.859</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">11</span><span class="variable">us</span><span class="operator">-</span><span class="number">98.917</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">34.830</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">128</span><span class="variable">us</span></span><br><span class="line"><span class="variable">FreeList</span><span class="operator">:</span>       <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">20.376</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">2</span><span class="variable">us</span><span class="operator">-</span><span class="number">188.875</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">29.573</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">998</span><span class="variable">us</span></span><br><span class="line"><span class="variable">MarkZygoteLargeObjects</span><span class="operator">:</span> <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">18.970</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">4</span><span class="variable">us</span><span class="operator">-</span><span class="number">115.749</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">27.693</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">122</span><span class="variable">us</span></span><br><span class="line"><span class="punctuation">(</span><span class="variable">Paused</span><span class="punctuation">)</span><span class="variable">SetFromSpace</span><span class="operator">:</span>   <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">12.331</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">3</span><span class="variable">us</span><span class="operator">-</span><span class="number">94.226</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">18.001</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">109</span><span class="variable">us</span></span><br><span class="line"><span class="variable">SwapBitmaps</span><span class="operator">:</span>    <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">11.761</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">5</span><span class="variable">us</span><span class="operator">-</span><span class="number">49.968</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">17.169</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">67</span><span class="variable">us</span></span><br><span class="line"><span class="variable">ResetStack</span><span class="operator">:</span>     <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">4.317</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">1</span><span class="variable">us</span><span class="operator">-</span><span class="number">64.374</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">6.302</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">190</span><span class="variable">us</span></span><br><span class="line"><span class="variable">UnBindBitmaps</span><span class="operator">:</span>  <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">3.803</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">4</span><span class="variable">us</span><span class="operator">-</span><span class="number">49.822</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">5.551</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">70</span><span class="variable">us</span></span><br><span class="line"><span class="punctuation">(</span><span class="variable">Paused</span><span class="punctuation">)</span><span class="variable">ClearCards</span><span class="operator">:</span>     <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">3.336</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">250</span><span class="variable">ns</span><span class="operator">-</span><span class="number">7000</span><span class="variable">ns</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">347</span><span class="variable">ns</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">7000</span><span class="variable">ns</span></span><br><span class="line"><span class="punctuation">(</span><span class="variable">Paused</span><span class="punctuation">)</span><span class="variable">FlipCallback</span><span class="operator">:</span>   <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">3.082</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">1</span><span class="variable">us</span><span class="operator">-</span><span class="number">30</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">4.499</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">30</span><span class="variable">us</span></span><br><span class="line"><span class="variable">Done</span> <span class="variable">Dumping</span> <span class="variable">histograms</span></span><br><span class="line"><span class="variable">young</span> <span class="variable">concurrent</span> <span class="variable">copying</span> <span class="variable">paused</span><span class="operator">:</span>        <span class="built_in">Sum</span><span class="operator">:</span> <span class="number">229.314</span><span class="variable">ms</span> <span class="number">99</span><span class="operator">%</span> <span class="built_in">C</span><span class="operator">.</span><span class="built_in">I</span><span class="operator">.</span> <span class="number">37</span><span class="variable">us</span><span class="operator">-</span><span class="number">2287.499</span><span class="variable">us</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">334.764</span><span class="variable">us</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">6850</span><span class="variable">us</span></span><br><span class="line"><span class="variable">young</span> <span class="variable">concurrent</span> <span class="variable">copying</span> <span class="variable">freed</span><span class="operator">-</span><span class="variable">bytes</span><span class="operator">:</span> <span class="variable">Avg</span><span class="operator">:</span> <span class="number">44</span><span class="variable">MB</span> <span class="built_in">Max</span><span class="operator">:</span> <span class="number">50</span><span class="variable">MB</span> <span class="built_in">Min</span><span class="operator">:</span> <span class="number">9132</span><span class="variable">KB</span></span><br><span class="line"><span class="variable">Freed</span><span class="operator">-</span><span class="variable">bytes</span> <span class="variable">histogram</span><span class="operator">:</span> <span class="number">5120</span><span class="operator">:</span><span class="number">1</span><span class="operator">,</span><span class="number">15360</span><span class="operator">:</span><span class="number">1</span><span class="operator">,</span><span class="number">20480</span><span class="operator">:</span><span class="number">6</span><span class="operator">,</span><span class="number">25600</span><span class="operator">:</span><span class="number">1</span><span class="operator">,</span><span class="number">30720</span><span class="operator">:</span><span class="number">1</span><span class="operator">,</span><span class="number">35840</span><span class="operator">:</span><span class="number">9</span><span class="operator">,</span><span class="number">40960</span><span class="operator">:</span><span class="number">235</span><span class="operator">,</span><span class="number">46080</span><span class="operator">:</span><span class="number">427</span><span class="operator">,</span><span class="number">51200</span><span class="operator">:</span><span class="number">4</span></span><br><span class="line"><span class="variable">young</span> <span class="variable">concurrent</span> <span class="variable">copying</span> <span class="variable">total</span> <span class="variable">time</span><span class="operator">:</span> <span class="number">100.823</span><span class="variable">s</span> <span class="variable">mean</span> <span class="variable">time</span><span class="operator">:</span> <span class="number">147.187</span><span class="variable">ms</span></span><br><span class="line"><span class="variable">young</span> <span class="variable">concurrent</span> <span class="variable">copying</span> <span class="variable">freed</span><span class="operator">:</span> <span class="number">519927309</span> <span class="variable">objects</span> <span class="variable">with</span> <span class="variable">total</span> <span class="variable">size</span> <span class="number">30</span><span class="variable">GB</span></span><br><span class="line"><span class="variable">young</span> <span class="variable">concurrent</span> <span class="variable">copying</span> <span class="variable">throughput</span><span class="operator">:</span> <span class="number">5.15683</span><span class="variable">e</span><span class="operator">+</span><span class="number">06</span><span class="operator">/</span><span class="variable">s</span> <span class="operator">/</span> <span class="number">304</span><span class="variable">MB</span><span class="operator">/</span><span class="variable">s</span>  <span class="variable">per</span> <span class="variable">cpu</span><span class="operator">-</span><span class="variable">time</span><span class="operator">:</span> <span class="number">333152554</span><span class="operator">/</span><span class="variable">s</span> <span class="operator">/</span> <span class="number">317</span><span class="variable">MB</span><span class="operator">/</span><span class="variable">s</span></span><br><span class="line"><span class="variable">Average</span> <span class="variable">minor</span> <span class="variable">GC</span> <span class="variable">reclaim</span> <span class="variable">bytes</span> <span class="variable">ratio</span> <span class="number">0.52381</span> <span class="variable">over</span> <span class="number">685</span> <span class="variable">GC</span> <span class="variable">cycles</span></span><br><span class="line"><span class="variable">Average</span> <span class="variable">minor</span> <span class="variable">GC</span> <span class="variable">copied</span> <span class="variable">live</span> <span class="variable">bytes</span> <span class="variable">ratio</span> <span class="number">0.0512109</span> <span class="variable">over</span> <span class="number">685</span> <span class="variable">minor</span> <span class="variable">GCs</span></span><br><span class="line"><span class="variable">Cumulative</span> <span class="variable">bytes</span> <span class="variable">moved</span> <span class="number">1542000944</span></span><br><span class="line"><span class="variable">Cumulative</span> <span class="variable">objects</span> <span class="variable">moved</span> <span class="number">28393168</span></span><br><span class="line"><span class="variable">Peak</span> <span class="variable">regions</span> <span class="variable">allocated</span> <span class="number">376</span> <span class="punctuation">(</span><span class="number">94</span><span class="variable">MB</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="number">2048</span> <span class="punctuation">(</span><span class="number">512</span><span class="variable">MB</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">Total</span> <span class="variable">time</span> <span class="variable">spent</span> <span class="variable">in</span> <span class="variable">GC</span><span class="operator">:</span> <span class="number">670.771</span><span class="variable">s</span></span><br><span class="line"><span class="built_in">Mean</span> <span class="variable">GC</span> <span class="variable">size</span> <span class="variable">throughput</span><span class="operator">:</span> <span class="number">159</span><span class="variable">MB</span><span class="operator">/</span><span class="variable">s</span> <span class="variable">per</span> <span class="variable">cpu</span><span class="operator">-</span><span class="variable">time</span><span class="operator">:</span> <span class="number">177</span><span class="variable">MB</span><span class="operator">/</span><span class="variable">s</span></span><br><span class="line"><span class="built_in">Mean</span> <span class="variable">GC</span> <span class="variable">object</span> <span class="variable">throughput</span><span class="operator">:</span> <span class="number">2.94152</span><span class="variable">e</span><span class="operator">+</span><span class="number">06</span> <span class="variable">objects</span><span class="operator">/</span><span class="variable">s</span></span><br><span class="line"><span class="built_in">Total</span> <span class="variable">number</span> <span class="variable">of</span> <span class="variable">allocations</span> <span class="number">1974199562</span></span><br><span class="line"><span class="built_in">Total</span> <span class="variable">bytes</span> <span class="variable">allocated</span> <span class="number">104</span><span class="variable">GB</span></span><br><span class="line"><span class="built_in">Total</span> <span class="variable">bytes</span> <span class="variable">freed</span> <span class="number">104</span><span class="variable">GB</span></span><br><span class="line"><span class="variable">Free</span> <span class="variable">memory</span> <span class="number">10</span><span class="variable">MB</span></span><br><span class="line"><span class="variable">Free</span> <span class="variable">memory</span> <span class="variable">until</span> <span class="variable">GC</span> <span class="number">10</span><span class="variable">MB</span></span><br><span class="line"><span class="variable">Free</span> <span class="variable">memory</span> <span class="variable">until</span> <span class="variable">OOME</span> <span class="number">442</span><span class="variable">MB</span></span><br><span class="line"><span class="built_in">Total</span> <span class="variable">memory</span> <span class="number">80</span><span class="variable">MB</span></span><br><span class="line"><span class="built_in">Max</span> <span class="variable">memory</span> <span class="number">512</span><span class="variable">MB</span></span><br><span class="line"><span class="variable">Zygote</span> <span class="variable">space</span> <span class="variable">size</span> <span class="number">2780</span><span class="variable">KB</span></span><br><span class="line"><span class="built_in">Total</span> <span class="variable">mutator</span> <span class="variable">paused</span> <span class="variable">time</span><span class="operator">:</span> <span class="number">544.563</span><span class="variable">ms</span></span><br><span class="line"><span class="built_in">Total</span> <span class="variable">time</span> <span class="variable">waiting</span> <span class="variable">for</span> <span class="variable">GC</span> <span class="variable">to</span> <span class="variable">complete</span><span class="operator">:</span> <span class="number">117.494</span><span class="variable">ms</span></span><br><span class="line"><span class="built_in">Total</span> <span class="variable">GC</span> <span class="variable">count</span><span class="operator">:</span> <span class="number">2880</span></span><br><span class="line"><span class="built_in">Total</span> <span class="variable">GC</span> <span class="variable">time</span><span class="operator">:</span> <span class="number">670.771</span><span class="variable">s</span></span><br><span class="line"><span class="built_in">Total</span> <span class="variable">blocking</span> <span class="variable">GC</span> <span class="variable">count</span><span class="operator">:</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">Total</span> <span class="variable">blocking</span> <span class="variable">GC</span> <span class="variable">time</span><span class="operator">:</span> <span class="number">86.373</span><span class="variable">ms</span></span><br><span class="line"><span class="built_in">Histogram</span> <span class="variable">of</span> <span class="variable">GC</span> <span class="variable">count</span> <span class="variable">per</span> <span class="number">10000</span> <span class="variable">ms</span><span class="operator">:</span> <span class="number">0</span><span class="operator">:</span><span class="number">259879</span><span class="operator">,</span><span class="number">1</span><span class="operator">:</span><span class="number">2828</span><span class="operator">,</span><span class="number">2</span><span class="operator">:</span><span class="number">24</span><span class="operator">,</span><span class="number">3</span><span class="operator">:</span><span class="number">1</span></span><br><span class="line"><span class="built_in">Histogram</span> <span class="variable">of</span> <span class="variable">blocking</span> <span class="variable">GC</span> <span class="variable">count</span> <span class="variable">per</span> <span class="number">10000</span> <span class="variable">ms</span><span class="operator">:</span> <span class="number">0</span><span class="operator">:</span><span class="number">262731</span><span class="operator">,</span><span class="number">1</span><span class="operator">:</span><span class="number">1</span></span><br><span class="line"><span class="variable">Native</span> <span class="variable">bytes</span> <span class="variable">total</span><span class="operator">:</span> <span class="number">30599192</span> <span class="variable">registered</span><span class="operator">:</span> <span class="number">8947416</span></span><br><span class="line"><span class="built_in">Total</span> <span class="variable">native</span> <span class="variable">bytes</span> <span class="variable">at</span> <span class="variable">last</span> <span class="variable">GC</span><span class="operator">:</span> <span class="number">30344912</span></span><br></pre></td></tr></table></figure><h3 id="分析-GC-正确性问题的工具"><a href="#分析-GC-正确性问题的工具" class="headerlink" title="分析 GC 正确性问题的工具"></a>分析 GC 正确性问题的工具</h3><p>造成 ART 内部崩溃的原因多种多样。读取或写入对象字段时发生崩溃可能表明堆损坏。如果 GC 在运行时崩溃，也可能是由堆损坏造成的。造成堆损坏的最常见原因是应用代码不正确。好在有一些工具可用来调试与 GC 和堆相关的崩溃问题，这些工具包括上面指定的堆验证选项和 CheckJNI。</p><h4 id="CheckJNI"><a href="#CheckJNI" class="headerlink" title="CheckJNI"></a>CheckJNI</h4><p>CheckJNI 是一种添加 JNI 检查来验证应用行为的模式；出于性能方面的原因，默认情况下不启用此类检查。此类检查将捕获一些可能会导致堆损坏的错误，如使用无效/过时的局部和全局引用。如需启用 CheckJNI，请使用以下命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="bash"> setprop dalvik.vm.checkjni <span class="literal">true</span></span></span><br></pre></td></tr></table></figure><p>CheckJNI 的 forcecopy 模式对于检测超出数组区域末端的写入很有用。启用后，forcecopy 会促使数组访问 JNI 函数返回带有红色区域的副本。红色区域是返回的指针末端/始端的一个区域，该区域具有一个特殊值，该值在数组释放时得到验证。如果红色区域中的值与预期值不匹配，表明发生了缓冲区溢出或欠载。这会导致 CheckJNI 中止。如需启用 forcecopy 模式，请使用以下命令：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="keyword">shell </span>setprop dalvik.vm.<span class="keyword">jniopts </span>forcecopy</span><br></pre></td></tr></table></figure><p>举例来说，当写入超出从 <code>GetPrimitiveArrayCritical</code> 获取的数组的末端时，这就是 CheckJNI 应捕获的一个错误。此操作可能会损坏 Java 堆。如果写入发生在 CheckJNI 红色区域内，则在调用相应的 <code>ReleasePrimitiveArrayCritical</code> 时，CheckJNI 会捕获该问题。否则，写入会损坏 Java 堆中的某个随机对象，并且可能会导致将来发生 GC 崩溃。如果损坏的内存是引用字段，则 GC 可能会捕获错误并输出错误消息“Tried to mark <ptr> not contained by any spaces”。</p><p>当 GC 尝试标记一个对象但无法找到其空间时，就会发生此错误。此检查失败后，GC 会遍历根，并尝试查看无效的对象是否为根。结果共有两个选项：对象为根或非根。</p><h4 id="无效根示例"><a href="#无效根示例" class="headerlink" title="无效根示例"></a>无效根示例</h4><p>如果对象为无效根，则会输出一些有用的信息：<code>art E 5955 5955 art/runtime/gc/collector/mark_sweep.cc:383] Tried to mark 0x2 not contained by any spaces</code></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">art E  <span class="number">5955</span>  <span class="number">5955</span> art/runtime/gc/collector/mark_sweep.cc:<span class="number">384</span>] Attempting see if</span><br><span class="line">it&#x27;s a bad root</span><br><span class="line">art E  <span class="number">5955</span>  <span class="number">5955</span> art/runtime/gc/collector/mark_sweep.cc:485] Found invalid</span><br><span class="line">root: 0x2</span><br><span class="line">art E  <span class="number">5955</span>  <span class="number">5955</span> art/runtime/gc/collector/mark_sweep.cc:486]</span><br><span class="line">Type=RootJavaFrame thread_id=1 location=Visiting method &#x27;java.lang.Object</span><br><span class="line">com.google.gwt.corp.collections.JavaReadableJsArray.get(int)&#x27; at dex PC 0x<span class="number">0002</span></span><br><span class="line">(native PC 0xf<span class="number">1960</span>9d9) vreg=1</span><br></pre></td></tr></table></figure><p>在本示例中，<code>com.google.gwt.corp.collections.JavaReadableJsArray.get</code> 内的 <code>vreg=1</code> 应该包含一个堆引用，但却包含了一个地址为 <code>0x2</code> 的无效指针。这是一个无效根。如需调试此问题，请在 oat 文件上使用 <code>oatdump</code>，并查看具有无效根的方法。在本示例中，结果证明错误在于 x86 后端的编译器错误。修复该错误的变更列表如下：<span class="exturl" data-url="aHR0cHM6Ly9hbmRyb2lkLXJldmlldy5nb29nbGVzb3VyY2UuY29tLyMvYy8xMzM5MzIv">https://android-review.googlesource.com/#/c/133932/<i class="fa fa-external-link-alt"></i></span></p><h4 id="损坏的对象示例"><a href="#损坏的对象示例" class="headerlink" title="损坏的对象示例"></a>损坏的对象示例</h4><p>如果对象不是根，则输出类似于以下内容：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">01</span>-<span class="number">15</span> <span class="number">12</span>:<span class="number">38</span>:<span class="number">00</span>.<span class="number">196</span>  <span class="number">1217</span>  <span class="number">1238</span> E art     : Attempting see if it&#x27;s a bad root</span><br><span class="line"><span class="attribute">01</span>-<span class="number">15</span> <span class="number">12</span>:<span class="number">38</span>:<span class="number">00</span>.<span class="number">196</span>  <span class="number">1217</span>  <span class="number">1238</span> F art     :</span><br><span class="line"><span class="attribute">art</span>/runtime/gc/collector/mark_sweep.cc:<span class="number">381</span>] Can&#x27;t mark invalid object</span><br></pre></td></tr></table></figure><p>如果堆损坏不是无效根，将很难调试。此错误消息表明堆中至少有一个对象指向无效对象。</p><h2 id="实现-ART-即时-JIT-编译器"><a href="#实现-ART-即时-JIT-编译器" class="headerlink" title="实现 ART 即时 (JIT) 编译器"></a>实现 ART 即时 (JIT) 编译器</h2><p>Android Runtime (ART) 包含一个具备代码分析功能的即时 (JIT) 编译器，该编译器可以在 Android 应用运行时持续提高其性能。JIT 编译器对 Android 运行组件当前的预先 (AOT) 编译器进行了补充，可以提升运行时性能，节省存储空间，加快应用和系统更新速度。相较于 AOT 编译器，JIT 编译器的优势也更为明显，因为在应用自动更新期间或在无线下载 (OTA) 更新期间重新编译应用时，它不会拖慢系统速度。</p><p>尽管 JIT 和 AOT 使用相同的编译器，它们所进行的一系列优化也较为相似，但它们生成的代码可能会有所不同。JIT 会利用运行时类型信息，可以更高效地进行内联，并可让堆栈替换 (OSR) 编译成为可能，而这一切都会使其生成的代码略有不同。</p><h3 id="JIT-架构"><a href="#JIT-架构" class="headerlink" title="JIT 架构"></a>JIT 架构</h3><p><img src="https://up-img.yonghong.tech/pic/2021/07/29-20-44-jit-arch-3Fcld1.png" alt="JIT 架构"></p><p><strong>图 1.</strong> JIT 架构。</p><h3 id="JIT-编译"><a href="#JIT-编译" class="headerlink" title="JIT 编译"></a>JIT 编译</h3><p>JIT 编译涉及以下活动：</p><p><img src="https://up-img.yonghong.tech/pic/2021/07/29-20-44-jit-profile-comp-RifrTY.png" alt="配置文件指导的编译"></p><p><strong>图 2.</strong> 配置文件引导的编译。</p><ol><li><p>用户运行应用，此举随后触发 ART 加载<code>.dex</code>文件。</p><ul><li>如果有 <code>.oat</code> 文件（即 <code>.dex</code> 文件的 AOT 二进制文件），ART 会直接使用该文件。虽然 <code>.oat</code> 文件会定期生成，但文件中不一定会包含经过编译的代码（即 AOT 二进制文件）。</li><li>如果 <code>.oat</code> 文件不含经过编译的代码，ART 会通过 JIT 和解释器执行 <code>.dex</code> 文件。</li></ul></li><li><p>针对任何未根据 <code>speed</code> 编译过滤器编译的应用启用 JIT（也就是说，要尽可能多地编译应用中的代码）。</p></li><li><p>将 JIT 配置文件数据转储到只有该应用可以访问的系统目录下的文件中。</p></li><li><p>AOT 编译 (<code>dex2oat</code>) 守护程序通过解析该文件来推进其编译。</p><p> <img src="https://up-img.yonghong.tech/pic/2021/07/29-20-44-jit-daemon-NoNjuF.png" alt="JIT 守护程序"><strong>图 3.</strong> JIT 守护程序活动。</p></li></ol><p>举例来说，Google Play 服务就是一种由其他应用使用的类似于共享库的服务。</p><h3 id="JIT-工作流程"><a href="#JIT-工作流程" class="headerlink" title="JIT 工作流程"></a>JIT 工作流程</h3><p><img src="https://source.android.com/devices/tech/dalvik/images/jit-workflow.png?hl=zh-cn" alt="JIT 架构"></p><p><strong>图 4.</strong> JIT 数据流。</p><ul><li><p>分析信息会存储在代码缓存中，并会在内存紧张时作为垃圾被回收。</p><ul><li>无法保证在应用处于后台运行状态时所捕获的快照能够包含完整的数据（即 JIT 编译的所有内容）。</li><li>该过程不会尝试确保记录所有内容（因为这会影响运行时性能）。</li></ul></li><li><p>方法可能有三种不同的状态：</p><ul><li><p>已经过解释（dex 代码）</p></li><li><p>已经过 JIT 编译</p></li><li><p>已经过 AOT 编译</p><p>如果同时存在 JIT 和 AOT 代码（例如，由于反复进行逆优化），经过 JIT 编译的代码将是首选代码。</p></li></ul></li><li><p>在不影响前台应用性能的情况下运行 JIT 所需的内存取决于相关应用。大型应用比小型应用需要更多内存。一般来说，大型应用所需的内存稳定维持在 4 MB 左右。</p></li></ul><h3 id="开启-JIT-日志记录"><a href="#开启-JIT-日志记录" class="headerlink" title="开启 JIT 日志记录"></a>开启 JIT 日志记录</h3><p>要开启 JIT 日志记录，请运行以下命令：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb <span class="keyword">shell</span> <span class="keyword">stop</span></span><br><span class="line">adb <span class="keyword">shell</span> setprop dalvik.<span class="keyword">vm</span>.extra-opts -<span class="keyword">verbose</span>:jit</span><br><span class="line">adb <span class="keyword">shell</span> start</span><br></pre></td></tr></table></figure><h3 id="停用-JIT"><a href="#停用-JIT" class="headerlink" title="停用 JIT"></a>停用 JIT</h3><p>要停用 JIT，请运行以下命令：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb <span class="built_in">shell</span> <span class="built_in">stop</span></span><br><span class="line">adb <span class="built_in">shell</span> setprop dalvik.vm.usejit <span class="literal">false</span></span><br><span class="line">adb <span class="built_in">shell</span> <span class="built_in">start</span></span><br></pre></td></tr></table></figure><h3 id="强制编译"><a href="#强制编译" class="headerlink" title="强制编译"></a>强制编译</h3><p>要强制编译，请运行以下命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cmd <span class="keyword">package</span> <span class="title">compile</span></span><br></pre></td></tr></table></figure><p>强制编译特定软件包的常见用例：</p><ul><li><p>基于配置文件：</p>  <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cmd <span class="keyword">package</span> <span class="title">compile -m speed-profile -f my-<span class="keyword">package</span></span></span><br></pre></td></tr></table></figure></li><li><p>全面：</p>  <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cmd <span class="keyword">package</span> <span class="title">compile -m speed -f my-<span class="keyword">package</span></span></span><br></pre></td></tr></table></figure></li></ul><p>强制编译所有软件包的常见用例：</p><ul><li><p>基于配置文件：</p>  <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cmd <span class="keyword">package</span> <span class="title">compile -m speed-profile -f -a</span></span><br></pre></td></tr></table></figure></li><li><p>全面：</p>  <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cmd <span class="keyword">package</span> <span class="title">compile -m speed -f -a</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="清除配置文件数据"><a href="#清除配置文件数据" class="headerlink" title="清除配置文件数据"></a>清除配置文件数据</h3><p>要清除配置文件数据并移除经过编译的代码，请运行以下命令：</p><ul><li><p>针对一个软件包：</p>  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cmd <span class="keyword">package</span> compile --<span class="keyword">reset</span> <span class="keyword">my</span>-<span class="keyword">package</span></span><br></pre></td></tr></table></figure></li><li><p>针对所有软件包：</p>  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="built_in">shell</span> cmd package compile <span class="comment">--reset -a</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Android Runtime (ART) 是 Android 上的应用和部分系统服务使用的托管式运行时。ART 及其前身 Dalvik 最初是专为 Android 项目打造的。作为运行时的 ART 可执行 Dalvik 可执行文件并遵循 Dex 字节码规范。&lt;/p&gt;
&lt;p&gt;ART 和 Dalvik 是运行 Dex 字节码的兼容运行时，因此针对 Dalvik 开发的应用也能在 ART 环境中运作。不过，Dalvik 采用的一些技术并不适用于 ART。有关最重要问题的信息，请参阅&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cDovL2RldmVsb3Blci5hbmRyb2lkLmNvbS9ndWlkZS9wcmFjdGljZXMvdmVyaWZ5aW5nLWFwcHMtYXJ0Lmh0bWw/aGw9emgtY24=&quot;&gt;在 Android Runtime (ART) 上验证应用行为&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="http://yonghong.tech/categories/Android/"/>
    
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
    <category term="Android" scheme="http://yonghong.tech/tags/Android/"/>
    
    <category term="ART" scheme="http://yonghong.tech/tags/ART/"/>
    
    <category term="Dalvik" scheme="http://yonghong.tech/tags/Dalvik/"/>
    
    <category term="运行时" scheme="http://yonghong.tech/tags/%E8%BF%90%E8%A1%8C%E6%97%B6/"/>
    
    <category term="虚拟机" scheme="http://yonghong.tech/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>看看大厂是如何用云原生解决千万视频会议难题的</title>
    <link href="http://yonghong.tech/2021/07/cloud-native-for-videoconferencing/"/>
    <id>http://yonghong.tech/2021/07/cloud-native-for-videoconferencing/</id>
    <published>2021-07-09T14:24:00.000Z</published>
    <updated>2021-07-09T14:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="腾讯：揭秘日活千万腾讯会议全量云原生化上TKE技术实践"><a href="#腾讯：揭秘日活千万腾讯会议全量云原生化上TKE技术实践" class="headerlink" title="腾讯：揭秘日活千万腾讯会议全量云原生化上TKE技术实践"></a>腾讯：揭秘日活千万腾讯会议全量云原生化上TKE技术实践</h2><p>文章链接：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTA0MTkyODMwNjAzMjcy">https://juejin.cn/post/6844904192830603272<i class="fa fa-external-link-alt"></i></span></p><p>本文总结了腾讯会议在TKE容器化部署时用到的平台相关特性，包括业务镜像自动分批灰度发布、ConfigMap分批灰度发布、Pod内A/B容器ms级切换发布、多集群发布管理、基于DynamicQuota的产品配额管理、探测节点和集群稳定性问题以提升自愈能力等。</p><h2 id="华为：远程办公利器华为云WeLink，如何练就硬核抗压能力？"><a href="#华为：远程办公利器华为云WeLink，如何练就硬核抗压能力？" class="headerlink" title="华为：远程办公利器华为云WeLink，如何练就硬核抗压能力？"></a>华为：远程办公利器华为云WeLink，如何练就硬核抗压能力？</h2><p>文章链接：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDYzODgxMzM=">https://zhuanlan.zhihu.com/p/106388133<i class="fa fa-external-link-alt"></i></span></p><p>业务快速增长带来的挑战聚焦在海量请求的冲击，从消息到语音模块、视频会议系统，华为云WeLink核心业务采用全容器化架构，结合华为云容器引擎单集群百万容器的超大规模支撑，可以迅速在新扩容的云服务器上启动业务，每秒最快可新增1000业务实例，大大降低了业务高峰时段的断线率、故障率和请求等待时长。更能通过瑶光的二次调度进行热点消除，保障计算资源压力的平均分布，助力业务平稳运行。</p><span id="more"></span><h2 id="字节：字节跳动容器化场景下的性能优化实践"><a href="#字节：字节跳动容器化场景下的性能优化实践" class="headerlink" title="字节：字节跳动容器化场景下的性能优化实践"></a>字节：字节跳动容器化场景下的性能优化实践</h2><p>文章链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY24vYXJ0aWNsZS9tdS0xYkZITm1yZGQwa3liZ1BYeA==">https://www.infoq.cn/article/mu-1bFHNmrdd0kybgPXx<i class="fa fa-external-link-alt"></i></span></p><p>字节跳动资源调度团队负责私有云平台 TCE 的底层 Kubernetes 集群的开发和维护工作。TCE 托管了头条、抖音、字节国际化业务等内部上万个在线微服务。随着这些业务的快速发展，集群规模不断扩大，机器负载越来越高，运维难度和成本问题越发显著。原生 Kubernetes 作为控制面系统，并不能很好地解决这些问题。为了提升系统可见性，我们基于 eBPF 实现了系统监控，使内核能更好地理解微服务，极大地提升了问题诊断效率。为提升资源利用率，我们通过动态超售，实现了业务实例的高密度部署，并通过优化 Kubernetes 资源模型，有效保证了延时敏感服务的 QoS。</p><h2 id="微软：Advancing-Microsoft-Teams-on-Azure—operating-at-pandemic-scale"><a href="#微软：Advancing-Microsoft-Teams-on-Azure—operating-at-pandemic-scale" class="headerlink" title="微软：Advancing Microsoft Teams on Azure—operating at pandemic scale"></a>微软：Advancing Microsoft Teams on Azure—operating at pandemic scale</h2><p>文章链接：<span class="exturl" data-url="aHR0cHM6Ly9henVyZS5taWNyb3NvZnQuY29tL2VuLXVzL2Jsb2cvYWR2YW5jaW5nLW1pY3Jvc29mdC10ZWFtcy1vbi1henVyZS1vcGVyYXRpbmctYXQtcGFuZGVtaWMtc2NhbGUv">https://azure.microsoft.com/en-us/blog/advancing-microsoft-teams-on-azure-operating-at-pandemic-scale/<i class="fa fa-external-link-alt"></i></span></p><h2 id="Zoom：Zoom-deploys-its-core-videoconferencing-service-on-Oracle-Cloud"><a href="#Zoom：Zoom-deploys-its-core-videoconferencing-service-on-Oracle-Cloud" class="headerlink" title="Zoom：Zoom deploys its core videoconferencing service on Oracle Cloud"></a>Zoom：Zoom deploys its core videoconferencing service on Oracle Cloud</h2><p>文章链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemRuZXQuY29tL2FydGljbGUvem9vbS1kZXBsb3lzLWl0cy1jb3JlLXZpZGVvY29uZmVyZW5jaW5nLXNlcnZpY2Utb24tb3JhY2xlLWNsb3VkLw==">https://www.zdnet.com/article/zoom-deploys-its-core-videoconferencing-service-on-oracle-cloud/<i class="fa fa-external-link-alt"></i></span></p><h2 id="声网：企业云原生创新与实践"><a href="#声网：企业云原生创新与实践" class="headerlink" title="声网：企业云原生创新与实践"></a>声网：企业云原生创新与实践</h2><p>视频链接：<span class="exturl" data-url="aHR0cHM6Ly95dW5xaS5hbGl5dW4uY29tLzIwMjAvc2Vzc2lvbjg4P2xpdmVJZD00NDE5MQ==">https://yunqi.aliyun.com/2020/session88?liveId=44191<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;腾讯：揭秘日活千万腾讯会议全量云原生化上TKE技术实践&quot;&gt;&lt;a href=&quot;#腾讯：揭秘日活千万腾讯会议全量云原生化上TKE技术实践&quot; class=&quot;headerlink&quot; title=&quot;腾讯：揭秘日活千万腾讯会议全量云原生化上TKE技术实践&quot;&gt;&lt;/a&gt;腾讯：揭秘日活千万腾讯会议全量云原生化上TKE技术实践&lt;/h2&gt;&lt;p&gt;文章链接：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTA0MTkyODMwNjAzMjcy&quot;&gt;https://juejin.cn/post/6844904192830603272&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本文总结了腾讯会议在TKE容器化部署时用到的平台相关特性，包括业务镜像自动分批灰度发布、ConfigMap分批灰度发布、Pod内A/B容器ms级切换发布、多集群发布管理、基于DynamicQuota的产品配额管理、探测节点和集群稳定性问题以提升自愈能力等。&lt;/p&gt;
&lt;h2 id=&quot;华为：远程办公利器华为云WeLink，如何练就硬核抗压能力？&quot;&gt;&lt;a href=&quot;#华为：远程办公利器华为云WeLink，如何练就硬核抗压能力？&quot; class=&quot;headerlink&quot; title=&quot;华为：远程办公利器华为云WeLink，如何练就硬核抗压能力？&quot;&gt;&lt;/a&gt;华为：远程办公利器华为云WeLink，如何练就硬核抗压能力？&lt;/h2&gt;&lt;p&gt;文章链接：&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDYzODgxMzM=&quot;&gt;https://zhuanlan.zhihu.com/p/106388133&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;业务快速增长带来的挑战聚焦在海量请求的冲击，从消息到语音模块、视频会议系统，华为云WeLink核心业务采用全容器化架构，结合华为云容器引擎单集群百万容器的超大规模支撑，可以迅速在新扩容的云服务器上启动业务，每秒最快可新增1000业务实例，大大降低了业务高峰时段的断线率、故障率和请求等待时长。更能通过瑶光的二次调度进行热点消除，保障计算资源压力的平均分布，助力业务平稳运行。&lt;/p&gt;</summary>
    
    
    
    <category term="云原生" scheme="http://yonghong.tech/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="云原生" scheme="http://yonghong.tech/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 08 —— JVM 垃圾回收器</title>
    <link href="http://yonghong.tech/java-advance/08-jvm-gc/"/>
    <id>http://yonghong.tech/java-advance/08-jvm-gc/</id>
    <published>2021-07-02T13:00:00.000Z</published>
    <updated>2021-07-02T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="垃圾回收器概述"><a href="#垃圾回收器概述" class="headerlink" title="垃圾回收器概述"></a>垃圾回收器概述</h2><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商，不同版本的 JVM 来实现。</p><p>由于 JDK 的版本处于高速迭代过程中，因此 Java 发展至今已经衍生了众多的 GC 版本。</p><span id="more"></span><p>从不同角度分析垃圾收集器，可以将 GC 分为不同的类型。</p><p>Java 不同版本的新特性需要关注的点：</p><ul><li>语法层面，Lambda表达式，switch 表达式，自动装箱、拆箱，enum，&lt;&gt;，…</li><li>API 层面：Stream API，新的时间日期，Optional，String，集合框架</li><li>底层优化：JVM 的优化，元空间，静态域，字符串常量池，GC 的变化，多语言的支持</li></ul><h2 id="垃圾回收器的分类"><a href="#垃圾回收器的分类" class="headerlink" title="垃圾回收器的分类"></a>垃圾回收器的分类</h2><ul><li><p>按线程数分，可以分为串行垃圾回收器（Serial Collector）和并行垃圾回收器（Parallel Collector）。</p><ul><li><p>串行回收指的是在同一时间段内只允许有一个 CPU 用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p></li><li><p>在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以串行回收器默认被应用在客户端的 Client 模式下的 JVM 中。</p></li><li><p>在并发能力比较强的 CPU 上，并行回收器产生的停顿时间要短于串行回收器。</p></li></ul></li><li><p>和串行回收相反，并行收集可以运用多个 CPU 同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了 STW 机制。</p></li><li><p>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。</p><ul><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li><li>独占式垃圾回收器一旦运行，就停止应用程序中的所有用于线程，直到垃圾回收过程完全结束。</li></ul></li><li><p>按碎片处理方式分，可以分为压缩式垃圾回收器和非压缩式垃圾回收器。</p><ul><li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。（再分配对象空间使用指针碰撞）</li><li>非压缩式的垃圾回收器不进行这步操作。（再分配对象空间使用空闲列表）</li></ul></li><li><p>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</p></li></ul><h2 id="评估-GC-的性能指标"><a href="#评估-GC-的性能指标" class="headerlink" title="评估 GC 的性能指标"></a>评估 GC 的性能指标</h2><ul><li><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例<ul><li>总运行时间：程序的运行时间 + 内存回收的时间</li></ul></li><li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li><li><strong>暂停时间</strong>：<strong>执行垃圾收集时，程序的工作线程被暂停的时间</strong>。</li><li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li><li><strong>内存占用</strong>：Java 堆区所占的内存大小。</li><li>快速：一个对象从诞生到被回收所经历的时间。</li></ul><p>吞吐量、暂停时间、内存占用，这三者共同构成一个不可能三角。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p><p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升有有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面的效果。</p><p>简单来说，主要抓住两点：<strong>吞吐量</strong>和<strong>暂停时间</strong>。</p><h3 id="吞吐量（throughput）"><a href="#吞吐量（throughput）" class="headerlink" title="吞吐量（throughput）"></a>吞吐量（throughput）</h3><p>吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）</p><ul><li>比如：虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%</li></ul><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p><p>吞吐量优先，意味着在单位时间内，STW 的时间最短：0.2 + 0.2 = 0.4</p><h3 id="暂停时间（pause-time）"><a href="#暂停时间（pause-time）" class="headerlink" title="暂停时间（pause time）"></a>暂停时间（pause time）</h3><p>暂停时间是指一个时间段内应用程序线程暂停，让 GC 线程执行的状态</p><ul><li>例如，GC 期间 100 毫秒的暂停时间意味着在这 100 毫秒期间内没有应用程序线程是活动的。</li></ul><p>暂停时间优先，意味着尽可能让单次 STW 的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5</p><h3 id="吞吐量-vs-暂停时间"><a href="#吞吐量-vs-暂停时间" class="headerlink" title="吞吐量 vs 暂停时间"></a>吞吐量 vs 暂停时间</h3><p>高吞吐量较好因为这会让应用程序的最终用户感觉到只有应用程序线程在做”生产性“工作。直觉上，吞吐量越高程序运行越快。</p><p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是 GC 还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的 200 毫秒暂停都可能打断终端用户体验。因此具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。</p><p>不幸的是 ”高吞吐量“ 和 ”低暂停时间“ 是一对相互竞争的目标（矛盾）。</p><ul><li>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致 GC 需要更长的暂停时间来执行内存回收。</li><li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li></ul><p>在设计（或使用）GC 算法时，我们必须确定我们的目标：一个 GC 算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折中。</p><p>现在标准：在最大吞吐量优先的情况下，降低停顿时间。 </p><h2 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h2><h3 id="垃圾收集器发展史"><a href="#垃圾收集器发展史" class="headerlink" title="垃圾收集器发展史"></a>垃圾收集器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是 Grabage Collection，对应的产品我们称为 Garbage Collector。</p><ul><li>1993 年随 JDK 1.3.1 一起来的是串行方式的 Serial GC，它是第一款 GC。ParNew 垃圾收集器是 Serial 收集器的多线程版本。</li><li>2002 年 2 月 26 日，Parallel GC 和 Concurrent Mark Sweep GC 跟随 JDK 1.4.2 一起发布。</li><li>Parallel GC 在 JDK 6 之后成为 HotSpot 默认 GC。</li><li>2012 年，在 JDK 1.7u4 版本中，G1 可用。</li><li>2017 年，JDK 9 中 G1 变成默认的垃圾收集器，以替代 CMS。</li><li>2018 年 3 月，JDK 10 中 G1 垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li><li>2018 年 9 月，JDK 11 发布。引入 Epsilon 垃圾回收器，又被称为 ”No-Op“（无操作）</li><li>2019 年 3 月，JDK 12 发布。增强 G1，自动返回未用堆内存给操作系统。同时，引入 Shenandoah GC，是一个低停顿时间的 GC（Experimental）。</li><li>2019 年 9 月，JDK 13 发布。增强 ZGC，自动返回未用堆内存给操作系统。</li><li>2020 年 3 月，JDK 14 发布。删除 CMS 垃圾回收器。拓展 ZGC 在 macOS 和 Windows 上的应用。</li></ul><h3 id="7-款经典的垃圾回收器"><a href="#7-款经典的垃圾回收器" class="headerlink" title="7 款经典的垃圾回收器"></a>7 款经典的垃圾回收器</h3><p>串行回收器：Serial、Serial Old</p><p>并行回收器：ParNew、Parallel Scavenge、Parallel Old</p><p>并发回收器：CMS、G1</p><h3 id="7-款经典的垃圾回收器与垃圾分代之间的关系"><a href="#7-款经典的垃圾回收器与垃圾分代之间的关系" class="headerlink" title="7 款经典的垃圾回收器与垃圾分代之间的关系"></a>7 款经典的垃圾回收器与垃圾分代之间的关系</h3><p>新生代收集器：Serial、ParNew、Parallel Scavenge</p><p>老年代收集器：Serial Old、Parallel Old、CMS</p><p>整堆垃圾收集器：G1</p><h3 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h3><p><img src="https://up-img.yonghong.tech/pic/2021/05/12-20-45-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB-BZidDy.png" alt="垃圾收集器的组合关系"></p><ul><li><p>两个收集器间有连线，表明它们可以搭配使用：</p><p>Serial / Serial Old 、Serial / CMS 、ParNew / Serial Old 、 ParNew / CMS 、Parallel Scavenge / Serial Old 、Parallel Scavenge / Parallel Old 、G1</p></li><li><p>其中 Serial Old 作为 CMS 出现 ”Concurrent Mode Failure“ 失败的后备预案。</p></li><li><p>（红色虚线）由于维护和兼容性测试的版本，在  JDK 8 时将 Serial + CMS、ParNew + Serial Old 这两个组合声明为废弃（JEP 173），并在 JDK 9 中完全取消了这些组合的支持（JEP 214），即，移除了这些组合。</p></li><li><p>（绿色虚线）JDK 14 中：弃用 Parallel Scavenge 和 Serial Old 组合（JEP 366）</p></li><li><p>（青色虚线）JDK 14中：删除 CMS 垃圾回收器（JEP 363）</p></li></ul><h3 id="如何查看默认的垃圾回收器"><a href="#如何查看默认的垃圾回收器" class="headerlink" title="如何查看默认的垃圾回收器"></a>如何查看默认的垃圾回收器</h3><p><code>-XX:+PrintCommandLineFlags</code> 查看命令行相关参数（包含使用的垃圾收集器）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure><p>使用命令行指令： jinfo -flag 相关垃圾回收器参数 进程 ID</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jinfo -flag UseParallelGC 58951</span></span><br><span class="line">-XX:-UseParallelGC</span><br><span class="line"><span class="meta">$</span><span class="bash"> jinfo -flag UseParallelOldGC 58951</span></span><br><span class="line">-XX:-UseParallelOldGC</span><br><span class="line"><span class="meta">$</span><span class="bash"> jinfo -flag UseG1GC 58951</span></span><br><span class="line">-XX:-UseG1GC</span><br><span class="line"><span class="meta">$</span><span class="bash"> jinfo -flag UseConcMarkSweepGC 58951</span></span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure><h2 id="垃圾回收器介绍"><a href="#垃圾回收器介绍" class="headerlink" title="垃圾回收器介绍"></a>垃圾回收器介绍</h2><h3 id="Serial-回收器：串行回收"><a href="#Serial-回收器：串行回收" class="headerlink" title="Serial 回收器：串行回收"></a>Serial 回收器：串行回收</h3><p>Serial 收集器是最基本、历史最悠久的垃圾收集器了。JDK 1.3 之前回收新生代唯一的选择。</p><p>Serial 收集器作为 HotSpot 中 Client 模式下的默认新生垃圾收集器。</p><p>Serial 收集器采用复制算法、串行回收和 STW 机制的方式执行内存回收。</p><p>除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。Serial Old 收集器同样也采用了串行回收和 STW 机制，只不过内存回收算法使用的是标记-压缩算法。</p><ul><li>Serial Old 是运行在 Client 模式下默认的老年代的垃圾回收器。</li><li>Serial Old 在 Server 模式下主要有两个用途：①与新生代的 Parallel Scavenge 配合使用 ②作为老年代 CMS 收集器的后备垃圾收集方案。</li></ul><p>这个收集器是一个单线程的收集器，但它的 ”单线程“ 的意义并不仅仅说明它<strong>只会使用一个 CPU 或一条收集线程去完成垃圾收集工作</strong>，更重要的是在它进行垃圾收集时，<strong>必须暂停其他所有的工作线程</strong>，直到它收集结束。</p><p>优势：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p><ul><li>运行在 Client 模式下的虚拟机是个不错的选择。</li></ul><p>在用户的桌面应用场景中，可用内存一般不大（几十 MB 至一两百 MB），可以在较短时间内完成垃圾回收（几十 ms 至一百多 ms），只要不频繁发生，使用串行回收器是可以接受的。</p><h4 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h4><p>在 HotSpot 虚拟机中，使用 <code>-XX:UseSerialGC</code> 参数可以指定年轻代和老年代都是用串行收集器。</p><ul><li>等价于新生代使用 Serial GC，且老年代使用 Serial Old GC。</li></ul><p>总结：这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核 CPU 才可以用。现在都不是单核的了。</p><p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在 Java Web 应用程序中是不会采用串行垃圾收集器的。</p><h3 id="ParNew-回收器：并行回收"><a href="#ParNew-回收器：并行回收" class="headerlink" title="ParNew 回收器：并行回收"></a>ParNew 回收器：并行回收</h3><p>如果说 Serial GC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本。</p><ul><li>Par 是 Parallel 的缩写，New：只能处理的是新生代</li></ul><p>ParNew 收集器除了采用<strong>并行回收</strong>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew 收集器在年轻代中同样也是<strong>采用复制算法、STW 机制</strong>。</p><p>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器。</p><ul><li>对于新生代，回收次数频繁，使用并行方式高效。</li><li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li></ul><p>由于 ParNew 收集器是基于并行回收，那么是否可以断定 ParNew 收集器的回收效率在任何场景下都会比 Serial 收集器更高效？</p><ul><li>ParNew 收集器运行在多 CPU 环境下，由于可以充分利用多 CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li><li>但是在单个 CPU 的环境下，ParNew 收集器不比 Serial 收集器更高效。虽然 Serial 收集器是基于串行回收，但是由于 CPU 不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li></ul><p>除 Serial 外，目前只有 ParNew GC 能与 CMS 收集器配合工作。</p><h4 id="参数配置-1"><a href="#参数配置-1" class="headerlink" title="参数配置"></a>参数配置</h4><p>在程序中，开发人员可以通过选项 <code>-XX:+UseParNewGC</code> 手动指定使用 ParNew 收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p><p><code>-XX:ParallelGCThreads</code> 限制线程数量，默认开启和 CPU 数相同的线程数。</p><h3 id="Parallel-回收器：吞吐量优先"><a href="#Parallel-回收器：吞吐量优先" class="headerlink" title="Parallel 回收器：吞吐量优先"></a>Parallel 回收器：吞吐量优先</h3><p>HotSpot 的年轻代中除了拥有 ParNew 收集器是基于并行回收以外，Parallel Scavenge 收集器同样也采用了复制算法、并行回收和 STW 机制。</p><p>那么 Parallel 收集器的出现是否多此一举？</p><ul><li>和 ParNew 收集器不同，Parallel Scavenge 收集器的目标是达到一个<strong>可控的吞吐量</strong>（Throughput），它也被称为吞吐量优先的垃圾收集器。</li><li>自适应调节策略也是 Parallel Scavenge 与 ParNew 的一个重要区别。</li></ul><p>高吞吐量则可以高效地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p><p>Parallel 收集器在 JDK 1.6 时提供了用于执行老年代垃圾收集的 Parallel Old 收集器，用来代替老年代的 Serial Old 收集器。</p><p>Parallel Old 收集器采用了<strong>标记-压缩算法</strong>，但同样也是基于<strong>并行回收</strong>和 STW 机制。</p><p>在吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错。</p><p>在 Java 8 中，默认也是此垃圾收集器。</p><h4 id="参数配置-2"><a href="#参数配置-2" class="headerlink" title="参数配置"></a>参数配置</h4><ul><li><code>-XX:+UserParallelGC</code> 手动指定年轻代使用 Parallel 并行收集器执行内存回收任务。</li><li><code>-XX:+UseParallelOld</code> 手动指定老年代都是使用并行回收收集器。<ul><li>上面两个参数，分别适用于新生代和老年代。默认 JDK 8 是开启的。</li><li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li></ul></li><li><code>-XX:ParallelGCTheads</code> 设置年轻代并行收集器的线程数。一般地，最好与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能。<ul><li>在默认情况下，当 CPU 数量小于 8 个，ParallelGCThreads 的值等于 CPU 数量。</li><li>当 CPU 数量大于 8 个，ParallelGCThreads 的值等于 <code>3 + ((5 * CPU_COUNT) / 8 )</code>。</li></ul></li><li><code>-XX:MaxGCPauseMillis</code> 设置垃圾收集器最大停顿时间（即 STW 的时间）。单位是毫秒。<ul><li>为了尽可能地把停顿时间控制在 MaxGCPauseMillis 以内，收集器在工作时会调整 Java 堆大小或者其他一些参数。</li><li>对于用户来讲，停顿时间越短体验越好。但是在服务端，我们注重高并发，整体的吞吐量。所以服务器端适合 Parallel，进行控制</li><li><strong>该参数使用需要谨慎。</strong></li></ul></li><li><code>-XX:GCTimeRatio</code> 垃圾收集时间占总时间的比例（= 1 / (N + 1)）。用于衡量吞吐量的大小。<ul><li>取值范围（0, 100）。默认值 99，也就是垃圾回收时间不超过 1%。</li><li>与前一个 <code>-XX:MaxGCPauseMillis</code> 参数有一定的矛盾性。暂停时间越长，Radio 参数就容易超过设定的比例。</li></ul></li><li><code>-XX:+UseAdaptiveSizePolicy</code> 设置 Parallel Scavenge 收集器具有自适应调节策略。<ul><li>在这种模式下，年轻代的大小，Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。</li><li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调度工作。</li></ul></li></ul><h3 id="CMS-回收器：低延迟"><a href="#CMS-回收器：低延迟" class="headerlink" title="CMS  回收器：低延迟"></a>CMS  回收器：低延迟</h3><p>在 JDK 1.5 时期，HotSpot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是 HotSpot 虚拟中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</p><p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><ul><li>目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。</li></ul><p>CMS 的垃圾收集算法采用 标记-清除 算法，并且也会 STW。</p><p>不幸的是，CMS 作为老年代的收集器，却无法与 JDK 1.4.0 中已经存在的新生代收集器 Parallel Scavenge 收集器配合工作，所以在 JDK 1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。</p><p>在 G1 出现之前，CMS 使用还是非常广泛的，一直到今天，任然有很多系统使用 CMS GC。</p><h4 id="CMS-工作原理"><a href="#CMS-工作原理" class="headerlink" title="CMS 工作原理"></a>CMS 工作原理</h4><p>CMS 整个过程比之前的收集器要复杂，整个过程分为 4 个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段、并发清除阶段。</p><ul><li>初始标记（Initial-Mark）阶段：在这个阶段中，程序用所有的工作线程都将会因为 STW 机制而出现短暂的暂停，这个阶段的主要任务<strong>仅仅是标记出 GC Roots 能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<strong>速度非常快</strong>。</li><li>并发标记（Concurrent-Mark）阶段：<strong>从 GC Roots 的直接关联对象开始遍历整个对象图的过程</strong>，这个过程<strong>耗时较长</strong>但是<strong>不需要停顿用户线程</strong>，可以与垃圾收集线程一起并发运行。</li><li>重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或交叉运行，因此为了<strong>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li>并发清除（Concurrent-Sweep）阶段：此阶段<strong>清理删除掉标记阶段的已经死亡的对象，释放内存空间</strong>。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li></ul><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>尽管 CMS 收集器采用的是并发回收（非独占式），但是在其<strong>初始化标记和再次标记这两个阶段中仍然需要执行 STW 机制暂停程序中的工作线程</strong>，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要 STW，只是尽可能的缩短暂停时间。</p><p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低延迟的。</p><p>另外，由于在垃圾收集阶段用户线程没有中断，所以在 CMS 回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了在进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在 CMS 工作过程中依然有足够的内存空间支持应用程序运行。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次 ”Concurrent Mode Failure“ 失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p><p>CMS 收集器的垃圾收集算法采用的是 标记-清除 算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能选择空闲列表（Free List）执行内存分配。</p><p>有人会觉得既然 Mark Sweep 会造成内存碎片，那么为什么不把算法换成 Mark Compact 呢？</p><p>答案其实很简单，因为当并发清除的时候，用 Compact 整理内存的话，原来的用户线程使用的内存还怎么用？要保证用户线程能继续执行，前提得是它运行的资源不受影响。Mark Compact 更适合 STW 这种场景下使用。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>并发收集</li><li>低延迟</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发 Full GC。</li><li>对 CPU 资源非常敏感，在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li><li>无法处理浮动垃圾，可能会出现 ”Concurrent Mode Failure“ 失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间。</li></ul><h4 id="参数配置-3"><a href="#参数配置-3" class="headerlink" title="参数配置"></a>参数配置</h4><ul><li><code>-XX:+UseConcMarkSweepGC</code> 手动指定使用 CMS 收集器执行内存回收任务。<ul><li>开启该参数后会自动将 <code>-XX:+UseParNewGC</code> 打开。即：年轻代使用 ParNew 收集器 + 老年代使用 CMS 收集器 + 老年代的备用收集器 Serial Old 收集器</li></ul></li><li><code>-XX:CMSInitiatingOccupanyFraction</code> 设置堆内存使用率的阈值，一旦到达该阈值，便开始进行回收。<ul><li>JDK 5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68% 时，会执行一次 CMS 回收。JDK 6 及以上的版本默认值为 92%。</li><li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低 Full GC 的执行次数。</li></ul></li><li><code>-XX:+UseCMSCompactAtFullCollection</code> 用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</li><li><code>-XX:CMSFullGCsBeforeCompaction</code> 设置在执行多少次 Full GC 后对内存空间进行压缩整理。</li><li><code>-XX:ParallelCMSThreads</code> 设置 CMS 的线程数量。<ul><li>CMS 默认启动的线程数是 （ParallelCMSThreads + 3） / 4</li><li>ParallelCMSThreads 是年轻代并行收集器（ParNew）的线程数。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ul></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>HotSpot 有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、CMS GC 这三个 GC 有什么不同呢？</p><ul><li>如果你想要最小化地使用内存和并行开销，请选择 Serial GC</li><li>如果你想要最大化应用程序的吞吐量，请选择 Parallel GC</li><li>如果你想要最小化 GC 的中断或停顿时间，请选择 CMS GC</li></ul><p>JDK 9 新特性：CMS 被标记为 Deprecate 了（JEP291）</p><ul><li>如果对 JDK 9 及以上版本的 HotSpot 虚拟机使用参数 <code>-XX:+UseConcMarkSweepGC</code> 来开启 CMS 收集器的话，用户会收到一个警告信息，提示 CMS 为了将会被去除。</li></ul><p>JDK 14 新特性：去除 CMS 垃圾收集器（JEP363）</p><ul><li>移除了 CMS 垃圾收集器，如果在 JDK 14 中使用 <code>-XX:+UseConcMarkSweepGC</code> 的话，JVM 不会报错，只是给出警告，但是不会退出。JVM 会自动使用默认的 GC。</li></ul><h3 id="G1-回收器：区域化分代式"><a href="#G1-回收器：区域化分代式" class="headerlink" title="G1 回收器：区域化分代式"></a>G1 回收器：区域化分代式</h3><p><strong>1.既然我们已经有了前面几个强大的 GC，为什么还要发布 Garbage First（G1）GC？</strong></p><p>原因就在于对于应用程序所应用的<strong>业务越来越庞大、复杂，用户越来越多</strong>，没有 GC 就不能保证应用程序正常进行，而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。G1（Garbage First）垃圾回收器是在 Java 7 Update 4 之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p><p>与此同时，为了适应现在<strong>不断扩大的内存和不断增加的处理器数量</strong>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p><p><strong>官方给 G1 设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起”全功能收集器“的重任与期望。</strong></p><p><strong>2.为什么名字叫做 Garbage First（G1）呢？</strong></p><p>因为 G1 是一个并行回收器，它把堆内存分割成很多不相关的区域（Region）（物理上不连续的）。使用不同的 Region 来表示 Eden、Survivor0、Survivor1、老年代等。</p><p>G1 GC 有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的 Region</strong>。</p><p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给 G1 一个名字：垃圾优先（Garbage First）。</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>G1（Garbage First）是一款面向服务端应用的垃圾收集器，主要针对配备多核 CPU 及大容量内存的机器，以极高概率满足 GC 停顿时间的同时，还兼具高吞吐量的性能特征。</p><p>在 JDK 1.7 版本正式启用，移除了 Experimental 的标识，是 JDK 9 以后的默认垃圾回收器，取代了 CMS 回收器以及 Parallel + Parallel Old 组合。被 Oracle 官方称为 ”全功能的垃圾收集器“。</p><p>与此同时，CMS 已经在 JDK 9 中被标记为废弃（Deprecated）。在  JDK 8 中还不是默认的垃圾回收器，需要使用 <code>-XX:+UseG1GC</code> 来使用。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>与其他的 GC 收集相比，G1 使用了全新的<strong>分区算法</strong>，其特定如下所示：</p><ul><li><strong>并行与并发</strong><ul><li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力。此时用户线程 STW</li><li>并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。</li></ul></li><li><strong>分代收集</strong><ul><li>从分代上看，<strong>G1 依然属于分代型垃圾回收器</strong>，它会区分年轻代和老生代，年轻代依然有 Eden 区和 Survivor 区。但从堆的结构上看，它不要求整个 Eden 区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将<strong>堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代</strong>。</li><li>和之前的各类回收器不同，它同时<strong>兼顾年轻代和老年代</strong>。对比其他回收器，或者工作在年轻代，或者工作在老年代。</li></ul></li><li><strong>空间整合</strong><ul><li>CMS：”标记-清除“ 算法、内存碎片、若干次 GC 后进行一次碎片整理</li><li>G1 将内存划分成为一个个的 Region。内存的回收是以 Region 作为基本单位的。<strong>Region 之间是复制算法</strong>，但整体上实际可看做是<strong>标记-压缩（Mark-Compact）算法</strong>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当 Java 堆非常大的时候，G1 的优势更加明显。</li></ul></li><li><strong>可预测的停顿时间模型</strong>（即软实时 soft real-time）<ul><li>这是 G1 相对于 CMS 的另一大优势，G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。<ul><li>由于分区的原因，G1 可以只选择部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的 Region。</strong>保证了 G1 收集器在有限的时间内可以<strong>获取尽可能高的收集效率。</strong></li><li>相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延迟停顿，但是最差情况要好很多。</li></ul></li></ul></li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比 CMS 要高。</p><p>从经验上说，在小内存应用上 CMS 的表现大概率会优于 G1，而  G1 在大内存应用上则发挥其优势。平衡点在 6-8 GB 之间。</p><h4 id="参数配置-4"><a href="#参数配置-4" class="headerlink" title="参数配置"></a>参数配置</h4><ul><li><code>-XX:+UseG1GC</code> 手动指定使用 G1 收集器执行内存回收任务。JDK 9 及以后默认开启。</li><li><code>-XX:G1HeapRegionSize</code> 设置每个 Region 的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域。默认是堆内存的 1/2000。</li><li><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大 GC 停顿时间指标（JJVM 会尽力实现，但不保证达到）。默认值是 200 ms。</li><li><code>-XX:ParallelGCThread</code> 设置 STW 工作线程数的值。最多设置为 8。</li><li><code>-XX:ConcGCThreads</code>设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1/4 左右。</li><li><code>-XX:InitiatingHeapOccupanyPercent</code> 设置触发并发 GC 周期的 Java 堆占用率阈值。超过此值，就触发 GC。默认值是 45。</li></ul><h4 id="常见操作步骤"><a href="#常见操作步骤" class="headerlink" title="常见操作步骤"></a>常见操作步骤</h4><p>G1 的设计原则就是简化 JVM 性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li>第一步，开启 G1 垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li></ul><p>G1 中提供了三种垃圾回收模式：Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</li><li>最主要的应用是需要低 GC 延迟，并具有大堆的应用程序提供解决方案</li><li>如：在堆大小约 6GB 或更大时，可预测的暂停时间可以低于 0.5 秒；G1 通过每次只清理一部分而不是全部的 Region 的增量式清理来保证每次 GC 停顿时间不会太长。</li><li>用来替换掉 CMS 收集器，在下面的情况时，使用 G1 可能比 CMS 好：<ul><li>超过 50% 的 Java 堆被活动数据占用</li><li>对象分配频率或年代提升频率变化很大</li><li>GC 停顿时间过长（长于 0.5 至 1 秒）</li></ul></li><li>HotSpot 垃圾收集器里，除了 G1 以外，其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，即当 JVM 的 GC 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。（啥意思？）</li></ul><h4 id="分区-Region：化整为零"><a href="#分区-Region：化整为零" class="headerlink" title="分区 Region：化整为零"></a>分区 Region：化整为零</h4><p>使用 G1 收集器时，它将整个 Java 堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32 MB 之间，且为 2 的 N 次幂，即 1 MB，2 MB，4 MB，8 MB，16 MB，32 MB。可以通过 <code>-XX:G1HeapRegionSize</code> 设定。所有的 Region 大小相同，且在 JVM 生命周期内不会被改变。</p><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。通过 Region 的动态分配方式实现逻辑上的连续。</p><p>一个 Region 有可能属于 Eden、Survivor 或者 Old/Tenured 内存区域。但是一个 Region 只可能属于一个角色。图中的 E 表示该 Region 属于 Eden 内存区域，S 表示属于 Survivor 内存区域，O 表示属于 Old 内存区域。图中空白的表示未使用的内存空间。</p><p>G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H 块。主要用于存储大对象，如果超过一个 Region 的50%，就放到 H。（这里老师讲解有误，在《JVM G1源码分析和调优》书中写到：对于大对象分为两类，一类是大于HeapRegionSize的一半，但是小于HeapRegionSize，即一个完整的堆分区可以保存，则直接从空闲列表直接拿一个堆分区，或者分配一个新的堆分区。如果是连续对象，则需要多个堆分区，思路同上，但是处理的时候需要加锁。）</p><p>设置 H 的原因：</p><p>对于堆中的大对象，默认直接会分配到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放大对象。<strong>如果一个 H 区装不下一个大对象，那么 G1 会寻找连续的 H 区来存储。</strong>为了能找到连续的 H 区，有时候不得不启用 Full GC。G1 的大多数行为都把 H 区作为老年代的一部分来看待。</p><h4 id="垃圾回收过程"><a href="#垃圾回收过程" class="headerlink" title="垃圾回收过程"></a>垃圾回收过程</h4><p>G1 GC 的垃圾回收过程主要包括如下三个环节：</p><ul><li>年轻代 GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC）</li><li>（如果需要，单线程、独占式、高强度的 Full GC 还是继续存在的。它针对 GC 的评估失败提供了一种失败保护机制，即强力回收。）</li></ul><p>Young GC → Young GC + Concurrent Marking → Mixed GC → Full GC</p><p>应用程序分配内存，<strong>当年轻代的 Eden 区用尽时开始年轻代回收过程</strong>；G1 年轻代收集阶段是一个<strong>并行</strong>的<strong>独占式</strong>收集器。在年轻代回收期，G1 GC 暂停所有应用程序线程，启动所线程执行年轻代回收。然后<strong>从年轻代区间移动存活对象到 Survivor 区间或者老年代区间，也有可能是两个区间都会涉及</strong>。</p><p>当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程。</p><p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC 从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的 G1 回收器和其他 GC 不同<strong>，G1 的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的 Region 就可以了</strong>。同时，这个老年代 Region 是和年轻代一起被回收的。</p><p>举个例子：一个 Web 服务器，Java 进程最大堆内存为 4 G，每分钟响应 1500 个请求，每 45 秒钟会新分配大约 2 G 内存。G1 会每 45 秒钟进行一次年轻代回收，每 31 个小时整个堆的使用率会达到 45 %，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p><h5 id="Remembered-Set"><a href="#Remembered-Set" class="headerlink" title="Remembered Set"></a>Remembered Set</h5><ul><li>一个对象被不同区域引用的问题</li><li>一个 Region 不可能是孤立的，一个 Region 中的对象可能被其他任意 Region 中的对象引用，判断对象存活时，是否需要扫描整个 Java 堆才能保证准确？</li><li>在其他的分代收集器，也存在这样的问题（而 G1 更突出）</li><li>回收新生代也不得不同时扫描老年代？</li><li>这样的话会降低 Minor GC 的效率</li></ul><p>解决方法：</p><ul><li>无论 G1 还是其他分代收集器，JVM 都是使用 Remembered Set 来避免全局扫描；</li><li>每个 Region 都有一个对应的 Remembered Set；</li><li>每次 Reference 类型数据写操作时，都会产生一个写屏障（Write Barrier）暂时中断操作；</li><li>然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的 Region（其他收集器：检查老年代对象是否引用了新生代对象）；</li><li>如果不同，通过 CardTable（Remembered Set 的实现） 把相关引用信息记录到引用指向对象所在 Region 对应的 Remembered Set 中；</li><li>当进行垃圾收集时，在 GC Roots 的枚举范围加入 Remembered Set，就可以保证不进行全局扫描，也不会有遗漏。</li></ul><h4 id="垃圾回收过程一：年轻代回收过程"><a href="#垃圾回收过程一：年轻代回收过程" class="headerlink" title="垃圾回收过程一：年轻代回收过程"></a>垃圾回收过程一：年轻代回收过程</h4><p>JVM 启动时，G1 先准备好 Eden 区，程序在运行过程中不断创建对象到 Eden 区，当 Eden 空间耗尽时，G1 会启动一次年轻代垃圾回收过程。</p><p>年轻代垃圾回收只会收集 Eden 区和 Survivor 区。</p><p>YGC 时，首先 G1 停止应用程序的执行（STW），G1 创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代 Eden 区和 Survivor 区所有的内存分段。</p><p>然后开始如下回收过程：</p><ul><li><p><strong>第一阶段，扫描根。</strong></p><p>根是指 static 变量指向的对象，正在执行的方法调用链上的局部变量等。根引用连同 RSet 记录的外部引用作为扫描存活对象的入口。</p></li><li><p><strong>第二阶段，更新 RSet。</strong></p><p>处理 Dirty Card Queue 中的 card，更新 RSet。此阶段完成后，<strong>RSet 可以准确的反映老年代对所在的内存分段中对象的引用。</strong></p></li><li><p><strong>第三阶段：处理 RSet。</strong></p><p>识别被老年代对象所指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象。</p></li><li><p><strong>第四阶段：复制对象。</strong></p><p>此阶段，对象树被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的内存分段，Survivor 区内存段中存活的对象如果年龄未达到阈值，年龄会加 1，达到阈值会被复制到 Old 区中的内存分段，如果 Survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间。</p></li><li><p><strong>第五阶段：处理引用。</strong></p><p>处理 Soft、Weak、Phantom、Final、JNI Weak 等引用（这里可能描述不准确）。最终 Eden 空间的数据为空，GC 停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p></li></ul><p>注：对于应用程序的引用赋值语句 object.fieled = object，JVM 会在之前和之后执行特殊的操作以在 Dirty Card Queue 中入队一个保存了对象引用信息的 card，在年轻代回收的时候，G1 会对 Dirty Card Queue 中所有的 card 进行处理，以更新 RSet，保证 RSet 实时准确的反映引用关系。</p><p>那为什么不在引用赋值语句处直接更新 RSet 呢？这是为了性能的需要，RSet 的处理需要线程同步，开销会很大，使用队列性能会好很多。</p><h4 id="垃圾回收过程二：老年代并发标记过程"><a href="#垃圾回收过程二：老年代并发标记过程" class="headerlink" title="垃圾回收过程二：老年代并发标记过程"></a>垃圾回收过程二：老年代并发标记过程</h4><ul><li><strong>1.初始标记过程（STW）</strong>：标记从根节点直接可达的对象。这个阶段是 STW 的，并且会触发一次年轻代 GC。</li><li><strong>2.根区域扫描（Root Region Scanning）</strong>：G1 GC 扫描 Survivor 区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在 Young GC 之前完成。</li><li><strong>3.并发标记（Concurrent Marking）</strong>：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被 Young GC 中断。在并发标记阶段，若发现区域对象中所有的对象都是垃圾，那这个区域会被立即回收（实时回收）。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li><strong>4.再次标记（Remark,STW）</strong>：由于应用程序持续进行，需要修正上一次的标记结果。是 STW 的。G1 中采用了比 CMS 更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li><li><strong>5.独占清理（cleanup,STW）</strong>:计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是 STW 的。</li><li><strong>6.并发清理阶段</strong>：识别并清理完全空闲的区域</li></ul><h4 id="垃圾回收过程三：混合回收过程"><a href="#垃圾回收过程三：混合回收过程" class="headerlink" title="垃圾回收过程三：混合回收过程"></a>垃圾回收过程三：混合回收过程</h4><p>当越来越多的对象晋升到老年代 Old Region 时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，该算法并不是一个 Old GC，除了回收整个 Young Region，还会回收一部分的 Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些 Old Region 进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC 并不是 Full GC。</p><ul><li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过 <code>-XX:G1MixedGCCountTarget</code> 设置）被回收。</li><li>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden 区内存分段，Survivor 区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li><li>由于老年代中的内存分段默认分8次回收，G1 会优先回收垃圾多的内存分段。<strong>垃圾占内存分段比例越高的，越会被先回收。</strong>并且有一个阈值会决定内存分段是否被回收。<code>-XX:G1MixedGCLiveThresholdPercent</code> ，默认为 65%，意思是垃圾占内存分段比例要达到 65% 才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</li><li>混合回收并不一定要进行 8 次。有一个阈值 <code>-XX:G1HeapWastePercent</code>，默认值为 10%，意思是允许整个堆内存中有 10% 的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于 10%，则不再进行混合回收。因为 GC 会花费很多的时间但是回收到的内存却很少。</li></ul><h4 id="垃圾回收可选过程四：Full-GC"><a href="#垃圾回收可选过程四：Full-GC" class="headerlink" title="垃圾回收可选过程四：Full GC"></a>垃圾回收可选过程四：Full GC</h4><p>G1的初衷就是要避免 Full GC 的出现。但是如果上述方式不能正常工作，G1 会停止应用程序的执行（Stop-The-World），使用<strong>单线程</strong>的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p><p>要避免 Full GC 的发生，一旦发生 Full GC，需要对JVM参数进行调整。什么时候会发生 Full GC 呢？比如堆内存太小，当 G1 在复制存活对象的时候没有空的内存分段可用，则会回退到 Full GC，这种情况可以通过增大内存解决。</p><p>导致 G1 Full GC 的原因可能有两个：</p><ul><li>Evacuation 的时候没有足够的 To Space 来存放晋升的对象；</li><li>并发处理过程完成之前空间耗尽。</li></ul><h4 id="G1-补充"><a href="#G1-补充" class="headerlink" title="G1 补充"></a>G1 补充</h4><p>从 Oracle 官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到 G1 只是回一部分 Region，停顿时间是用户可控制的，所以并不迫切去实现，<strong>而选择把这个特性放到了 G1 之后出现的低延迟垃圾收集器（即 ZGC）中。</strong>另外，还考虑到 G1 不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。 </p><h4 id="G1-回收器的优化建议"><a href="#G1-回收器的优化建议" class="headerlink" title="G1 回收器的优化建议"></a>G1 回收器的优化建议</h4><ol><li>年轻代大小<ul><li>避免使用 -Xmn 或 -XX:NewRatio 等相关选项显式设置年轻代大小，因为固定年轻代的大小会覆盖可预测的暂停时间目标。我们让 G1 自己去调整</li></ul></li><li>暂停时间目标不要太过严苛<ul><li>G1 GC 的吞吐量目标是 90% 的应用程序时间和 10% 的垃圾回收时间</li><li>评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul></li></ol><h2 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h2><p>截止 JDK 1.8，一共有 7 款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p><table><thead><tr><th>垃圾收集器</th><th>分类</th><th>作用位置</th><th>使用算法</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>Serial</td><td>串行运行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>适用于单 CPU 环境下的 Client 模式</td></tr><tr><td>ParNew</td><td>并行运行</td><td>新生代</td><td>复制算法</td><td>响应速度优先</td><td>多 CPU 环境 Server 模式下与 CMS 配合使用</td></tr><tr><td>Parallel</td><td>并行运行</td><td>新生代</td><td>复制算法</td><td>吞吐量优先</td><td>适用于后台运算而不需要太多交互的场景</td></tr><tr><td>Serial Old</td><td>串行运行</td><td>老年代</td><td>标记-压缩算法</td><td>响应速度优先</td><td>适用于单 CPU 环境下的 Client 模式</td></tr><tr><td>Parallel Old</td><td>并行运行</td><td>老年代</td><td>标记-压缩算法</td><td>吞吐量优先</td><td>适用于后台运算而不需要太多交互的场景</td></tr><tr><td>CMS</td><td>并发运行</td><td>老年代</td><td>标记-清除算法</td><td>响应速度优先</td><td>适用于互联网或 B/S 业务</td></tr><tr><td>G1</td><td>并发、并行运行</td><td>新生代、老年代</td><td>标记-压缩算法、复制算法</td><td>响应速度优先</td><td>面向服务端应用</td></tr></tbody></table><p>GC 发展阶段</p><p>Serial → Parallel → CMS → G1 → ZGC</p><h3 id="怎么选择垃圾回收器"><a href="#怎么选择垃圾回收器" class="headerlink" title="怎么选择垃圾回收器"></a>怎么选择垃圾回收器</h3><p>Java 垃圾收集器的配置对于 JVM 优化来说是一个很重要的选择，选择合适的垃圾收集器可以让 JVM 的性能有一个很大的提升。怎么选择垃圾收集器？</p><ol><li>优先调整堆的大小让 JVM 自适应完成。</li><li>如果内存小于 100M，使用串行收集器</li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li><li>如果是多 CPU、需要高吞吐量、允许停顿时间超过 1 秒，选择并行或者 JVM 自己选择</li><li>如果是多 CPU、追求低停顿时间，需快速响应（比如延迟不能超过 1 秒，如互联网应用），使用并发收集器</li><li>官方推荐 G1，性能高。现在互联网的项目，基本都是使用 G1。</li></ol><p>最后需要明确一个观点：</p><ol><li>没有最好的收集器，更没有万能的收集算法</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ol><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><ol><li>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。这里较通用、基础性的部分如下：<ul><li>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</li><li>垃圾收集器工作的基本流程。</li></ul></li><li>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</li></ol><h2 id="GC-日志分析"><a href="#GC-日志分析" class="headerlink" title="GC 日志分析"></a>GC 日志分析</h2><h3 id="GC-日志参数设置"><a href="#GC-日志参数设置" class="headerlink" title="GC 日志参数设置"></a>GC 日志参数设置</h3><p><strong>通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略。</strong></p><p>内存分配与垃圾回收的参数列表</p><ol><li>-XX:+PrintGC ：输出GC日志。类似：-verbose:gc</li><li>-XX:+PrintGCDetails ：输出GC的详细日志</li><li>-XX:+PrintGCTimestamps ：输出GC的时间戳（以基准时间的形式）</li><li>-XX:+PrintGCDatestamps ：输出GC的时间戳（以日期的形式，如2013-05-04T21: 53: 59.234 +0800）</li><li>-XX:+PrintHeapAtGC ：在进行GC的前后打印出堆的信息</li><li>-Xloggc:…/logs/gc.log ：日志文件的输出路径</li></ol><h3 id="GC-日志查看工具"><a href="#GC-日志查看工具" class="headerlink" title="GC 日志查看工具"></a>GC 日志查看工具</h3><p>GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat 等</p><h3 id="GC-日志补充说明"><a href="#GC-日志补充说明" class="headerlink" title="GC 日志补充说明"></a>GC 日志补充说明</h3><ol><li>“[GC” 和 “[Full GC” 说明了这次垃圾收集的停顿类型，如果有 Full 则说明 GC 发生了 “Stop The World”</li><li>使用 Serial 收集器在新生代的名字是 Default New Generation，因此显示的是 “[DefNew”</li><li>使用 ParNew 收集器在新生代的名字会变成 “ParNew”，意思是 “Parallel New Generation”</li><li>使用 Parallel scavenge 收集器在新生代的名字是 “PSYoungGen”</li><li>老年代的收集和新生代道理一样，名字也是收集器决定的</li><li>使用 G1 收集器的话，会显示为 “garbage-first heap”</li><li>Allocation Failure 表明本次引起 GC 的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</li><li>[PSYoungGen: 5986K-&gt;696K(8704K) ] 5986K-&gt;704K (9216K)<ul><li>中括号内：GC 回收前年轻代大小，回收后大小，（年轻代总大小）</li><li>括号外：GC 回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li></ul></li><li>user 代表用户态回收耗时，sys 内核态回收耗时，real 实际耗时。由于多核线程切换的原因，时间总和可能会超过 real 时间</li></ol><h2 id="垃圾回收器的新发展"><a href="#垃圾回收器的新发展" class="headerlink" title="垃圾回收器的新发展"></a>垃圾回收器的新发展</h2><h3 id="垃圾回收器的发展过程"><a href="#垃圾回收器的发展过程" class="headerlink" title="垃圾回收器的发展过程"></a>垃圾回收器的发展过程</h3><p>GC 仍然处于飞速发展之中，目前的默认选项 G1 GC 在不断的进行改进，很多我们原来认为的缺点，例如串行的 Full GC、Card Table 扫描的低效等，都已经被大幅改进，例如，JDK10 以后，Full GC 已经是并行运行，在很多场景下，其表现还略优于 Parallel GC 的并行 Full GC 实现。 </p><p>即使是 Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，<strong>在 Serverless 等新的应用场景下，Serial GC 找到了新的舞台。</strong></p><p>比较不幸的是 CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在 JDK 9 中已经被标记为废弃，并在 JDK 14 版本中移除。</p><p>现在 G1 回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK 11出现）和 Shenandoah（Open JDK 12），其特点：主打低停顿时间。</p><h3 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h3><p><strong>Open JDK12的Shenandoash GC：低停顿时间的GC（实验性）</strong></p><p>Shenandoah 无疑是众多 GC 中最孤独的一个。是第一款不由 Oracle 公司团队领导开发的 Hotspot 垃圾收集器。不可避免的受到官方的排挤。比如号称 openJDK 和 OracleJDK 没有区别的 Oracle 公司仍拒绝在 Oracle JDK12 中支持 Shenandoah。</p><p>Shenandoah 垃圾回收器最初由 RedHat 进行的一项垃圾收集器研究项目 Pauseless GC 的实现，旨在针对 JVM 上的内存回收实现低停顿的需求。在 2014 年贡献给 OpenJDK。</p><p>Red Hat 研发 Shenandoah 团队对外宣称，Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200MB 还是200GB，99.9% 的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p><p><img src="https://up-img.yonghong.tech/pic/2021/05/12-20-51-shenandoah-benchmark-XybNYb.png" alt="shenandoah-benchmark"></p><p>这是 RedHat 在 2016 年发表的论文数据，测试内容是使用 ES 对 200GB 的维基百科数据进行索引。从结果看：</p><ol><li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li><li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li></ol><p>总结</p><ol><li>Shenandoah GC 的弱项：高运行负担下的吞吐量下降。</li><li>Shenandoah GC 的强项：低延迟时间。</li></ol><p>相关解读：尚硅谷宋红康Java12&amp;13新特性教程(深入解读java12&amp;13)</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWpKNDExTTdrUQ==">https://www.bilibili.com/video/BV1jJ411M7kQ<i class="fa fa-external-link-alt"></i></span></p><h3 id="令人震惊、革命性的-ZGC"><a href="#令人震惊、革命性的-ZGC" class="headerlink" title="令人震惊、革命性的 ZGC"></a>令人震惊、革命性的 ZGC</h3><p>官方文档：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMTIvZ2N0dW5pbmcv">https://docs.oracle.com/en/java/javase/12/gctuning/<i class="fa fa-external-link-alt"></i></span></p><p>ZGC 与 Shenandoah 目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</p><p>《深入理解Java虚拟机》一书中这样定义 ZGC：ZGC 收集器是一款基于 Region 内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现<strong>可并发的标记-压缩算法</strong>的，以<strong>低延迟为首要目标</strong>的一款垃圾收集器。</p><p>ZGC 的工作过程可以分为 4 个阶段：<strong>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</strong> 等。</p><p>ZGC 几乎在所有地方并发执行的，除了<strong>初始标记的是 STW 的</strong>。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p><p>在 ZGC 的强项停顿时间测试上，它毫不留情的将 Parallel、G1 拉开了两个数量级的差距。无论平均停顿、95% 停顿、99.8% 停顿、99. 98% 停顿，还是最大停顿时间，ZGC 都能毫不费劲控制在 10 毫秒以内。</p><p>虽然 ZGC 还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</p><h3 id="面向大堆的-AliGC"><a href="#面向大堆的-AliGC" class="headerlink" title="面向大堆的 AliGC"></a>面向大堆的 AliGC</h3><p>AliGC 是阿里巴巴 JVM 团队基于 G1 算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p><p><img src="https://up-img.yonghong.tech/pic/2021/05/12-20-51-aligc_1-FPAp6p.png" alt="12-20-51-aligc_1-FPAp6p"></p><p><img src="https://up-img.yonghong.tech/pic/2021/05/12-20-51-aligc_2-CKMw3y.png" alt="12-20-51-aligc_2-CKMw3y"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;垃圾回收器概述&quot;&gt;&lt;a href=&quot;#垃圾回收器概述&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收器概述&quot;&gt;&lt;/a&gt;垃圾回收器概述&lt;/h2&gt;&lt;p&gt;垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商，不同版本的 JVM 来实现。&lt;/p&gt;
&lt;p&gt;由于 JDK 的版本处于高速迭代过程中，因此 Java 发展至今已经衍生了众多的 GC 版本。&lt;/p&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 07 —— JVM 垃圾回收相关概念</title>
    <link href="http://yonghong.tech/java-advance/07-jvm-gc/"/>
    <id>http://yonghong.tech/java-advance/07-jvm-gc/</id>
    <published>2021-06-25T13:00:00.000Z</published>
    <updated>2021-06-25T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc() 的理解"></a>System.gc() 的理解</h2><p>在默认情况下，通过 System.gc() 或者 Runtime.getRuntime().gc() 的调用，<strong>会显示触发 Full GC</strong>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p><p>然而 System.gc() 调用附带一个免责声明，无法保证对垃圾收集器的调用。</p><span id="more"></span><p>JVM 实现者可以通过 System.gc() 调用来决定 JVM 的 GC 行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用 System.gc()。</p><p>例子1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemGCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemGCTest();</span><br><span class="line">        System.gc(); <span class="comment">// 提醒 JVM 的垃圾回收器执行 GC</span></span><br><span class="line"></span><br><span class="line">        System.runFinalization(); <span class="comment">// 强制调用未被使用对象的 finalize 方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了重写的 finalize 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVarGCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 10M</span></span><br><span class="line">        System.gc(); <span class="comment">// 不能回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 10M</span></span><br><span class="line">        buffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc(); <span class="comment">// 可以回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 10M</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.gc(); <span class="comment">// 不能回收，局部变量表中仍然有引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 10M</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">        System.gc(); <span class="comment">// 可以回收，局部变量表中 value 和 buffer 使用同一个 Slot</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fun1();</span><br><span class="line">        System.gc(); <span class="comment">// 可以回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalVarGCTest local = <span class="keyword">new</span> LocalVarGCTest();</span><br><span class="line">        local.fun5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h2><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>内存溢出相对于内存泄露来说，尽管更容易理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p><p>由于 GC 一直在发展，所以一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现 OOM 的情况。</p><p>大多数情况下，GC 会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的 Full GC 操作，这时候会回收大量的内存，供应用程序继续使用。</p><p>Java Doc 中对 OutOfMemoryError 的解释是，<strong>没有空闲内存，并且垃圾收集器也无法提供更多内存。</strong></p><p>1.首先说没有空闲内存的情况：说明 Java 虚拟机的堆内存不够。原因有二：</p><ul><li><p>Java 虚拟机的堆内存设置不够</p><p>比如：可能存在内存泄露问题：也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显示指定 JVM 堆大小或者指定数值偏小。我们可以通过 -Xms、-Xmx 来调整。</p></li><li><p>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在引用）</p><p>对于老版本的 Oracle JDK，因为永久代的大小时有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OOM 也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似 intern 字符串缓存占用太多空间，也会导致 OOM 问题。对应的异常信息，会标记出来和永久代相关：”java.lang.OutOfMemoryError: PermGen Space”</p><p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 OOM 有所改观，出现 OOM 异常的信息则变成了 “java.lang.OutOfMemoryError: Metaspace”。直接内存不足，也会导致 OOM。</p></li></ul><p>2.垃圾收集器无法提供更多内存，这里面隐含着一层意思是，在抛出 OOM 之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p><ul><li>例如：在引用机制分析中，涉及到 JVM 会去尝试回收软引用指向的对象等。</li><li>在 java.nio.BITs.reserveMemory() 方法中，我们能清楚地看到，System.gc() 会被调用，以清理空间。</li></ul><p>当然，也不是在任何情况下垃圾收集器都会被触发的。</p><ul><li>比如，我们去分配一个超大对象。类似一个超大数组超过堆的最大值，JVM 可以判断出垃圾收集并不能解决这个问题，所以直接抛出 OOM。</li></ul><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>内存泄露也称作 存储渗漏。严格来说，<strong>只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄露</strong>。</p><p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对对象的生命周期变得很长甚至导致 OOM，也可以叫做宽泛意义上的内存泄露。</p><p>尽管内存泄露并不会立刻引起程序崩溃，但是一旦发生内存泄露，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现 OOM 异常，导致程序崩溃。</p><p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小决定于磁盘交换区设定的大小。</p><p>举例：</p><p>1.单例模式</p><p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄露的产生。</p><p>2.一些提供 close 的资源未关闭导致内存泄露</p><p>数据库连接（dataSource.getConnection()），网络连接（socket）和 io 连接必须手动 close，否则是不能被回收的。</p><h2 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h2><p>Stop The World，简称 STW，指的是 GC 事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为 STW。</p><ul><li>可达性分析算法中枚举根节点（GC Roots）会导致所有 Java 执行线程停顿。<ul><li>分析工作必须在一个能确保一致性的快照中进行</li><li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li><li>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证。=</li></ul></li></ul><p>被 STW 中断的应用程序线程会在完成 GC 之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少 STW 的发生。</p><p>STW 事件和采用哪款 GC 无关，所有的 GC 都有这个事件。</p><p>哪怕是 G1 也不能完全避免 STW 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能得缩短了暂停时间。</p><p>STW 是 JVM 在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p><p>开发中不要用 System.gc()；会导致 STW 的发生。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopTheWorldTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WorkThread workThread = <span class="keyword">new</span> WorkThread();</span><br><span class="line">        PrintThread printThread = <span class="keyword">new</span> PrintThread();</span><br><span class="line">        workThread.start();</span><br><span class="line">        printThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line">                    list.add(buffer);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (list.size() &gt; <span class="number">10000</span>) &#123;</span><br><span class="line">                    list.clear();</span><br><span class="line">                    System.gc(); <span class="comment">// 触发 Full GC，引发 STW</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> t = System.currentTimeMillis() - startTime;</span><br><span class="line">                    System.out.println(t / <span class="number">1000</span> + <span class="string">&quot;.&quot;</span> + t % <span class="number">1000</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h2><h3 id="并发（Concurrent）"><a href="#并发（Concurrent）" class="headerlink" title="并发（Concurrent）"></a>并发（Concurrent）</h3><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p><p>并发不是真正意义上的“同时进行”，只是 CPU 把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于 CPU 处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p><h3 id="并行（Parallel）"><a href="#并行（Parallel）" class="headerlink" title="并行（Parallel）"></a>并行（Parallel）</h3><p>当系统有一个以上 CPU 时，当一个 CPU 执行一个进程时，另一个 CPU 可以执行另一个进程，两个进行互不抢占 CPU 资源，可以同时进行，我们称之为并行。</p><p>其实决定并行的因素不是 CPU 的数量，而是 CPU 的核心数量，比如一个 CPU 多个核也可以并行。</p><p>适合科学计算，后台处理等弱交互场景。</p><h3 id="并发-vs-并行"><a href="#并发-vs-并行" class="headerlink" title="并发 vs 并行"></a>并发 vs 并行</h3><p>并发，指的是多个事情，在同一时间段内同时发生了。</p><p>并行，指的是多个事情，在同一时间点上同时发生了。</p><p>并发的多个任务之间是互相抢占资源的，</p><p>并行的多个任务之间是不互相抢占资源的。</p><p>只有在多 CPU 或者一个 CPU 多核的情况中，才会发生并行。</p><p>否则，看似同时发生的事情，其实都是并发执行的，</p><h3 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h3><p>并发和并行，在谈论垃圾收集器的上下午语境中，它们可以解释如下：</p><ul><li>并行：只多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。<ul><li>如 ParNew、Parallel Scavenge、Parallel Old</li></ul></li><li>串行<ul><li>相较于并行的概念，单线程执行。</li><li>如果内存不够，则程序暂停，启动 JVM 垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li></ul></li><li>并发：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。<ul><li>用户程序在继续运行，而垃圾收集程序线程运行于另一个 CPU 上。</li><li>如：CMS、G1</li></ul></li></ul><h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><h3 id="安全点（Safe-Point）"><a href="#安全点（Safe-Point）" class="headerlink" title="安全点（Safe Point）"></a>安全点（Safe Point）</h3><p>程序执行时并非在所有的地方都可以停顿下来开始 GC，只有在特定位置才能停顿下来开始 GC，这些位置称为 安全点（Safe Point）。</p><p>Safe Point 的选择很重要，<strong>如果太少可能导致 GC 等待的时间太长，如果太频繁可能导致运行时的性能问题</strong>。大部分指令的执行时间都非常短暂，通常会根据 “是否具有让程序长时间执行的特性” 为标准。比如：选择一些执行时间较长的指令作为 Safe Point，如<strong>方法调用、循环跳转和异常跳转</strong>等。</p><p>如何在 GC 发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p><ul><li><p>抢占式中断：（目前没有虚拟机采用了）</p><p>首先中断所有线程，如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</p></li><li><p>主动式中断：</p><p>设置一个中断标志，各个线程运行到 Safe Point 的时候主动轮询到这个标志，如果中断标志为真，则将自己进行中断挂起。</p></li></ul><h3 id="安全区域（Safe-Region）"><a href="#安全区域（Safe-Region）" class="headerlink" title="安全区域（Safe Region）"></a>安全区域（Safe Region）</h3><p>Safe Point 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safe Point。但是，程序 “不执行” 的时候呢？例如线程处于 Sleep 状态或 Blocked 状态，这个时候线程无法响应 JVM 的中断请求，“走” 到安全点去中断挂起，JVM 也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p><p><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始 GC 都是安全的。</strong>我们也可以把 Safe Region 看做是拓展了的 Safe Point。</p><p>实际执行时：</p><ul><li>当线程运行到 Safe Region 的代码时，首先标识已经进入了 Safe Region，如果这段时间内发生 GC，JVM 会忽略标识为 Safe Region 状态的线程。</li><li>当线程离开 Safe Region 时，会检查 JVM 是否已经完成 GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开 Safe Region 的信号为止。</li></ul><hr><h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h2><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p><p>【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</p><p>在 JDK 1.2 版本后，Java 对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Preference）和虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。</p><p>除强引用外，其他 3 种引用均可以在 java.lang.ref 包中找到它们的身影。如下图，显示了这 3 种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p><p>Reference 子类中只有终结器引用是包内可见的，其他 3 种类型均为 public，可以在应用程序中直接使用。</p><ul><li>强引用：最传统的引用的定义，是指在程序代码之中普遍存在的引用赋值，即类似 “Object obj = new Object()” 这种引用关系。<strong>无论任何情况下，只要强引用关系还在，垃圾收集器就永远不会回收掉被引用的对象。</strong></li><li>软引用：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li><li>弱引用：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li>虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。<strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</strong></li></ul><h2 id="再谈引用：强引用（不回收）"><a href="#再谈引用：强引用（不回收）" class="headerlink" title="再谈引用：强引用（不回收）"></a>再谈引用：强引用（不回收）</h2><p>在 Java 程序中，最常见的引用类型是强引用（普通对象99%以上都是强引用），也就是我们最常见的普通对象引用，也就是默认的引用类型。</p><p>当在 Java 语言中使用 new 操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p><p>强引用的对象是可触及的，垃圾回收器就永远不会回收掉被引用的对象。</p><p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p><p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及的，在一定条件下，都是可以被回收的。所以，强引用时造成 Java 内存泄露的主要原因之一。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;强引用&quot;</span>);</span><br></pre></td></tr></table></figure><p>强引用具备以下特点：</p><ul><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向对象。</li><li>强引用可能导致内存泄露。</li></ul><h2 id="再谈引用：软引用（内存不足即回收）"><a href="#再谈引用：软引用（内存不足即回收）" class="headerlink" title="再谈引用：软引用（内存不足即回收）"></a>再谈引用：软引用（内存不足即回收）</h2><p>软引用是用来描述一些还有用，但是非必需的对象。只要被软引用关联着的对象，在系统将要发生内存溢出异常前会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><p>软引用通常用来实现内存敏感的缓存。比如：高速缓存（如，MyBatis 的缓存）就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就能保证了使用缓存的同时，不会耗尽内存。</p><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p><p>类似弱引用，只不过 Java 虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object(); <span class="comment">// 声明强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sr = <span class="keyword">new</span> SoftReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">// 销毁强引用</span></span><br></pre></td></tr></table></figure><h2 id="再谈引用：弱引用（发现即回收）"><a href="#再谈引用：弱引用（发现即回收）" class="headerlink" title="再谈引用：弱引用（发现即回收）"></a>再谈引用：弱引用（发现即回收）</h2><p>弱引用也是用来描述那些非必需对象，<strong>只</strong>被弱引用关联的对象<strong>只能生存到下一次垃圾收集发生为止</strong>。在系统 GC 时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p><p>但是，由于垃圾回收器的线程通常优先级低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p><p>弱引用和软引用一样，在构造弱引用同时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p><p><strong>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。</strong>如果这么做，当系统内存不足时，这些缓存数据就会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object(); <span class="comment">// 声明强引用</span></span><br><span class="line">WeakReference&lt;Object&gt; wr = <span class="keyword">new</span> WeakReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">// 销毁强引用</span></span><br></pre></td></tr></table></figure><p>弱引用对象与软引用对象最大的不同就在于，当 GC 在进行回收时，需要通过算法检查是够回收软引用对象，而对于弱引用，GC 总是进行回收。弱引用对象更容易、更快被 GC 回收。</p><p>面试题：开发中使用过 WeakHashMap 吗？</p><p>图片缓存等。</p><h2 id="再谈引用：虚引用（对象回收跟踪）"><a href="#再谈引用：虚引用（对象回收跟踪）" class="headerlink" title="再谈引用：虚引用（对象回收跟踪）"></a>再谈引用：虚引用（对象回收跟踪）</h2><p>也称为 “幽灵引用” 或者 “幻影引用”，是所有引用类型中最弱的一个。</p><p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p><p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的 get() 方法取得对象时，总是 null。</p><p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</p><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会回收对象后，将这个虚引用加入引用队列，以通知应用程序对象回收情况。</p><p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object(); <span class="comment">// 声明强引用</span></span><br><span class="line">ReferenceQueue phantomQueue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference&lt;Object&gt; pr = <span class="keyword">new</span> PhantomReference&lt;&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">// 销毁强引用</span></span><br></pre></td></tr></table></figure><h2 id="再谈引用：终结器引用"><a href="#再谈引用：终结器引用" class="headerlink" title="再谈引用：终结器引用"></a>再谈引用：终结器引用</h2><p>它用于实现对象的 finalize 方法，也可以称为终结器引用。</p><p>无需手动编码，其内部配合引用队列使用。</p><p>在 GC 时，终结器引用入队。由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;System-gc-的理解&quot;&gt;&lt;a href=&quot;#System-gc-的理解&quot; class=&quot;headerlink&quot; title=&quot;System.gc() 的理解&quot;&gt;&lt;/a&gt;System.gc() 的理解&lt;/h2&gt;&lt;p&gt;在默认情况下，通过 System.gc() 或者 Runtime.getRuntime().gc() 的调用，&lt;strong&gt;会显示触发 Full GC&lt;/strong&gt;，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。&lt;/p&gt;
&lt;p&gt;然而 System.gc() 调用附带一个免责声明，无法保证对垃圾收集器的调用。&lt;/p&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 06 —— JVM 垃圾回收算法</title>
    <link href="http://yonghong.tech/java-advance/06-jvm-gc-algo/"/>
    <id>http://yonghong.tech/java-advance/06-jvm-gc-algo/</id>
    <published>2021-06-18T13:00:00.000Z</published>
    <updated>2021-06-18T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么会有-GC"><a href="#为什么会有-GC" class="headerlink" title="为什么会有 GC"></a>为什么会有 GC</h1><p>本质上是内存资源的有限性，因此需要大家共享使用，手工申请，手动释放。</p><p>垃圾收集，不是 Java 语言的伴生产物。早在 1960 年，第一门开始使用内存动态分配和垃圾收集技术的 Lisp 语言诞生。</p><p>关于垃圾收集有三个经典问题：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><span id="more"></span><p>垃圾收集机制是 Java 语言的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java 的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p><p>面试题：</p><ul><li>垃圾回收器，各自优缺点，CMS、G1</li><li>GC 算法有哪些，目前的 JDK 版本采用什么回收算法</li><li>GC 两种判定方法</li><li>分代回收</li><li>垃圾收集策略和算法</li><li>平时如何搭配使用垃圾回收器</li><li>什么情况触发垃圾回收</li><li>System.gc() runtime.gc()</li><li>Java  GC 机制，GC Roots 有哪些</li><li>CMS 回收停顿了几次，为什么？</li></ul><h1 id="什么是垃圾（Garbage）"><a href="#什么是垃圾（Garbage）" class="headerlink" title="什么是垃圾（Garbage）"></a>什么是垃圾（Garbage）</h1><p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。An object is considered garbage when it  can no longer be  reached from any pointer in the running program .</p><p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占用的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</p><h1 id="为什么需要垃圾回收"><a href="#为什么需要垃圾回收" class="headerlink" title="为什么需要垃圾回收"></a>为什么需要垃圾回收</h1><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停的生产而从来不打扫一样。</p><p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便 JVM 将整理出的内存分配给新的对象。</p><p>随着应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有 GC 就不能保证应用程序的正常进行。而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。</p><h1 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h1><p>在早期的 C/C++ 时代，垃圾回收基本上是手工进行的。开发人员可以使用 new 关键字进行内存申请，并使用 delete 关键字进行内存释放。比如以下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> cmBaseGroupBridge();</span><br><span class="line"><span class="comment">// 如果注册失败，使用 delete 关键字释放该对象所占用内存区域</span></span><br><span class="line"><span class="keyword">if</span> (pBridg-&gt;Register(kDestroy) != NO_ERROR) &#123;</span><br><span class="line">    <span class="keyword">delete</span> pBridge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄露，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。</p><p>有了垃圾回收机制后，上述代码块极有可能变成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> cmBaseGroupBridge();</span><br><span class="line">pBridg-&gt;Register(kDestroy);</span><br></pre></td></tr></table></figure><p>现在，除了 Java 以外，C#、Python、Ruby 等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式已经成为现代开发语言必备的标准。</p><h1 id="Java-垃圾回收机制"><a href="#Java-垃圾回收机制" class="headerlink" title="Java 垃圾回收机制"></a>Java 垃圾回收机制</h1><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低了内存泄漏和内存溢出的风险。</p><ul><li>没有垃圾回收器，java 也会和 cpp 一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li></ul><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专注地专心于业务开发。</p><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy90ZWNobm90ZXMvZ3VpZGVzL3ZtL2djdHVuaW5nL3RvYy5odG1s">Oracle 官网关于垃圾回收的介绍<i class="fa fa-external-link-alt"></i></span></p><p>担忧：</p><p>对于 Java 开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于”自动“，那么这将会是一场灾难，最严重的就会弱化 Java 开发人员在程序出现内存溢出时定位问题和解决问题的能力。</p><p>此时，了解 JVM 的自动内存分配和内存回收原理就显得非常重要，只有在真正了解 JVM 是如何管理内存后，我们才能够在遇见 OOM 时，快速地根据错误异常日志定位问题和解决问题。</p><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集册很难过为系统达到更高并发量的瓶颈时，我们就必须对这些”自动化“的技术是是必要的监控和调优。</p><p>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至全堆和方法区的回收。</p><hr><ul><li>其中，Java 堆是垃圾收集器的工作重点</li></ul><p>从次数上讲：</p><ul><li>频繁收集年轻代</li><li>较少收集老年代</li><li>基本不动方法区/永久代/元空间</li></ul><h1 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h1><h2 id="垃圾标记阶段"><a href="#垃圾标记阶段" class="headerlink" title="垃圾标记阶段"></a>垃圾标记阶段</h2><p>在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活的对象，哪些是已经死亡的对象</strong>。只有被标记为已经死亡的对象，GC 才会在执行垃圾回收时，释放掉其所占有的内存空间，因此这个过程我们称为<strong>垃圾标记阶段</strong>。</p><p>那么在 JVM 中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</p><p>判断对象存活一般有两种方式：<strong>引用计数法</strong>和<strong>可达性分析算法</strong>。</p><h3 id="方式一：引用计数算法"><a href="#方式一：引用计数算法" class="headerlink" title="方式一：引用计数算法"></a>方式一：引用计数算法</h3><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的<strong>引用计数器属性用于记录对象被引用的情况</strong>。</p><p>对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，即表示对象 A 不可能再被使用，可进行回收。</p><p>优点：<strong>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性</strong>。</p><p>缺点：</p><ul><li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong>。</li><li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命的缺陷，导致在 Java 的垃圾回收器中没有使用这类算法。</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的 Python，它更是同时支持引用计数和垃圾收集机制。</p><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p><p>Java 并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</p><p>Python 如何解决循环引用？</p><ul><li>手动解除：很好理解，就是在合适的时机，解除引用关系。</li><li>使用弱引用 weakref，weakref 是 Python 提供的标准库，旨在解决循环引用。</li></ul><h3 id="方式二：可达性分析算法"><a href="#方式二：可达性分析算法" class="headerlink" title="方式二：可达性分析算法"></a>方式二：可达性分析算法</h3><p>可达性分析算法又叫做根搜索算法，或者是追踪性垃圾收集。</p><p>相对于引用计数法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</p><p>相较于引用计数算法，这里的可达性分析就是 Java、C# 选择的。这种类型的垃圾收集器通常也叫做<strong>追踪性垃圾收集器（Tracing Garbage Collector）</strong>。</p><p>所谓 ”GC Roots“ 根集合就是一组必须活跃的引用。</p><p>基本思路：</p><ul><li>可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达</strong>。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为<strong>引用链（Reference Chain）</strong></li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象</li><li>在可达性分析算法中，只有能够被根对象集合直接或间接连接的对象才是存活对象</li></ul><p>这个算法目前较为常用。</p><h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><p>在 Java 语言中，GC Roots 包括以下几类元素：</p><ul><li>虚拟机栈中引用的对象<ul><li>比如，各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li>本地方法栈内 JNI（通常说的本地方法）引用的对象</li><li>方法区中类静态属性引用的对象<ul><li>比如：Java 类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象<ul><li>比如：字符串常量池里的引用</li></ul></li><li>所有被同步锁 synchronized 持有的对象</li><li>Java 虚拟机内部的引用<ul><li>基本数据类型对应的 Class 对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li></ul></li><li>反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</li></ul><p>除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象 临时性 地加入，共同构成完整 GC Roots 集合。比如，分代收集和局部回收（Partial GC）</p><ul><li>如果只针对 Java 堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入 GC Roots 集合中去考虑，才能保证可达性分析的准确性。</li></ul><p><strong>小技巧：</strong>由于 Root 采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root。</p><p><strong>注意：</strong>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能够保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p><p>这点也是导致 GC 时进行必须 ”Stop The World“ 的一个重要原因。</p><ul><li>即使是号称（几乎）不会发生停顿的 CMS 收集器中，<strong>枚举根节点时也是必须要停顿的</strong>。</li></ul><h4 id="对象的-finalization-机制"><a href="#对象的-finalization-机制" class="headerlink" title="对象的 finalization 机制"></a>对象的 finalization 机制</h4><p>Java 语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。</p><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 finalize() 方法。</p><p> finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p><p>永远不要主动调用对象的 finalize() 方法，应该交给垃圾回收机制调用。理由包括以下 3 点：</p><ul><li><p>在 finalize() 时可能会导致对象复活。</p></li><li><p>finalize() 方法执行时间是没有保障的，它完全由 GC 线程决定，极端情况下，若不发生 GC，则  finalize() 方法将没有执行机会。</p></li><li><p>一个糟糕的  finalize() 会严重影响 GC 性能</p></li></ul><p>从功能上来说， finalize() 方法与 C++ 中的析构函数比较相似，但是 Java 采用的是基于垃圾回收器的自动内存管理机制，所以  finalize() 方法在本质上不同于 C++ 中的析构函数。</p><p>由于  finalize() 方法的存在，虚拟机中的对象一般处于三种可能的状态。</p><h4 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h4><p>如果所有的根节点都无法访问到某个对象，说明对象已经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是 “非死不可” 的，这时候它们暂时处于 “缓刑” 阶段。一个无法触及的对象有可能在某一个条件下 ”复活“，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p><ul><li>可触及的：从根节点开始，可以到达这个对象。</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在  finalize() 中复活。</li><li>不可触及的：对象的 finalize() 方法被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为  finalize() 方法只会被调用一次。</li></ul><p>以上 3 种状态中，是由于 finalize() 方法的存在进行的区分。只有在对象不可触及时才可以被回收。</p><h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><p>判定一个对象 objA 是否可回收，至少要经历两次标记过程：</p><ul><li>如果对象 objA 到 GC Roots 没有引用链，则进行第一次标记</li><li>进行筛选，判断此对象是否有必要执行  finalize() 方法<ul><li>如果对象 objA 没有重写 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，则虚拟机视为 ”没有必要执行“，objA 被判定为不可触及的。</li><li>如果对象 objA 重写了 finalize() 方法，且还未执行过，那么 objA 会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 finalize() 方法执行。</li><li>finalize() 方法是对象逃脱死亡的最后机会，稍后 GC 会对 F-Queue 队列中的对象进行第二次标记。如果 objA 在 finalize() 方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA 会被移出 ”即将回收“ 集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize() 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的 finalize() 方法只会被调用一次。</li></ul></li></ul><h4 id="MAT-与-JProfiler-的-GC-Roots-溯源"><a href="#MAT-与-JProfiler-的-GC-Roots-溯源" class="headerlink" title="MAT 与 JProfiler 的 GC Roots 溯源"></a>MAT 与 JProfiler 的 GC Roots 溯源</h4><p>MAT 是 Memory Analyzer 的简称，它是一款功能强大的 Java 堆内存分析器，用于查找内存泄露以及查看内存消耗情况。</p><p>MAT 是基于 Eclipse 开发的，是一款免费的性能分析工具。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWNsaXBzZS5vcmcvbWF0Lw==">https://www.eclipse.org/mat/<i class="fa fa-external-link-alt"></i></span></p><h4 id="获取-dump-文件"><a href="#获取-dump-文件" class="headerlink" title="获取 dump 文件"></a>获取 dump 文件</h4><ul><li>命令行使用 jmap<ul><li>jps</li><li>jmap -dump:format=b,live,file=test1.bin 14036</li></ul></li><li>使用 JVisualVM 导出<ul><li>捕获的 heap dump 文件是一个临时文件，关闭 JVisualVM 后自动删除，若要保留，需要将其另存为文件。</li><li>可以通过以下方式捕获 heap dump<ul><li>在左侧 Application 子窗口中右击相应的应用程序，选择 Heap Dump</li><li>在 Monitor 子标签页中点击 Heap Dump 按钮</li></ul></li><li>本地应用程序的 Heap Dumps 作为应用程序标签页的一个子标签页打开。同时，Heap Dump 在左侧 Application 栏中对应一个含有时间戳的节点，右击这个节点选择 Save As 即可将 Heap Dump 文件保存到本地。</li></ul></li></ul><h2 id="垃圾清除阶段"><a href="#垃圾清除阶段" class="headerlink" title="垃圾清除阶段"></a>垃圾清除阶段</h2><p>当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p><p>目前在 JVM 比较常见的三种垃圾收集算法是 标记-清除算法（Mark-Sweep）、复制算法（Copying）、标记-压缩算法（Mark-Compact）</p><h3 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被 J.McCarthy 等人在 1960 年提出并应用于 List 语言。</p><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为 Stop The World），然后进行两项工作，第一项是标记，第二项则是清除。</p><ul><li>标记：Collector 从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的 Header 中记录为可达对象。</li><li>清除：Collector 对对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收。</li></ul><p>缺点：</p><ul><li>效率不算高</li><li>在进行 GC 的时候，需要停止整个应用程序，导致用户体验差</li><li>这种方式清理出来的空闲内存空间是不连续的，产生内存碎片。需要维护一个空闲列表</li></ul><p>注意：何为清除？</p><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。</p><h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky 于1963 年发表了著名的论文，”使用双存储区的 Lisp 语言垃圾收集器 （A Lisp Garbage Collector Algorithm Using Serial Secondary Storage）“。M.L.Minsky 本人成功地引入到了 Lisp 语言的一个实现版本中。</p><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>将活着的内存空间分为两块，每次只是用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p><p>优点</p><ul><li><p>没有标记和清除过程，实现简单，运行高效</p></li><li><p>复制过去以后保证空间的连续性，不会出现”碎片问题“</p></li></ul><p>缺点</p><ul><li><p>此算法的缺点也是很明显的，就是需要两倍的内存空间。</p></li><li><p>对于 G1 这种分拆成为大量 region 的GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销也不小</p></li></ul><p>特别的：</p><ul><li>如果系统中的垃圾对象很多，复制短发需要复制的存活对象数量并不会太大，或者说非常低。</li></ul><p>应用场景：</p><p>在新生代，对应常规应用的垃圾回收，一次通常可以回收 70% - 99% 的内存空间，回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p><h3 id="标记-压缩算法（Mark-Compact）"><a href="#标记-压缩算法（Mark-Compact）" class="headerlink" title="标记-压缩算法（Mark-Compact）"></a>标记-压缩算法（Mark-Compact）</h3><h4 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h4><p>复制算法的高效性，是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p><p>标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以 JVM 的设计者需要在此基础上进行改进。标记-压缩（Mark-Compact）算法也由此诞生。</p><p>1970 年前后，G.L.Steele、C.J.Chene 和 D.S.Wise 等研究者发布标记-压缩算法。在许多现代的垃圾回收器中，人们都是用了标记-压缩算法或其改进版本。</p><h4 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h4><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象。</p><p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</p><p>之后清理边界外所有的空间。</p><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为 标记-清除-压缩（Mark-Sweep-Compact） 算法。</p><p>二者本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。</p><p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p><p><strong>指针碰撞（Bump the Pointer）</strong></p><p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞。</p><p><strong>优点</strong></p><p>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可。</p><p>消除了复制算法当中，内存减半的高额代价</p><p><strong>缺点</strong></p><p>从效率上来说，标记-整理算法要低于复制算法。</p><p>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。</p><p>移动的过程中，需要全程暂停用户应用程序。即：STW</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><table><thead><tr><th></th><th>Mark-Sweep</th><th>Mark-Compact</th><th>Copying</th></tr></thead><tbody><tr><td>速度</td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td>空间开销</td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的 2 倍大小（不堆积碎片）</td></tr><tr><td>移动对象</td><td>否</td><td>是</td><td>是</td></tr></tbody></table><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记阶段，比标记-清除算法多了一个整理内存的阶段。</p><p><strong>难道就没有一种最优算法吗？</strong></p><p>没有最好的算法，只有最合适的算法。</p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和缺点。分代收集算法应运而生。</p><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，<strong>不同生命周期的对象可以采取不同的收集方式，以便提高回收效率</strong>。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年龄代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在 Java 程序运行过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如 HTTP 请求中的 Session 对象、线程、Socket 连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String 对象，由于其不变性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p>目前几乎所有的 GC 都是采用分代收集（Generational Collecting）算法执行垃圾回收的。</p><p>在 HotSpot 中，基于分代的概念，GC 所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><ul><li>年轻代（Young Gen）<ul><li>年轻代的特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li><li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过 HotSpot 中的两个 Survivor 的设计得到缓解</li></ul></li><li>老年代（Tenured Gen）<ul><li>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</li><li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或是标记-清除与标记-整理的混合实现。<ul><li>Mark 阶段的开销与存活对象的数量成正比。</li><li>Sweep 阶段的开销与所管理区域大小成正比。</li><li>Compact 阶段的开销与存活对象的数据成正比。</li></ul></li></ul></li></ul><p><strong>以 HotSpot 中的 CMS 回收器为例，CMS 是基于 Mark-Sweep 实现的，对于对象的回收率很高。而对于碎片问题，CMS 采用基于 Mark-Compact 算法的 Serial Old 回收器作为补偿：当内存回收不佳（碎片导致的 Concurrent Mode Failure 时），将采用 Serial Old 执行 Full GC 以达到对老年代内存的整理。</strong></p><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。</p><h2 id="增量收集算法、分区算法"><a href="#增量收集算法、分区算法" class="headerlink" title="增量收集算法、分区算法"></a>增量收集算法、分区算法</h2><h3 id="增量收集算法（Incremental-Collecting）"><a href="#增量收集算法（Incremental-Collecting）" class="headerlink" title="增量收集算法（Incremental Collecting）"></a>增量收集算法（Incremental Collecting）</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种 STW 的状态。在 STW 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，<strong>将严重影响用户体验或者系统的稳定性</strong>。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><p>基本思想：如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，<strong>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</strong>。</p><p>总的来说，增量收集算法的基础仍然是传统的标记-清除和复制算法。<strong>增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段方式完成标记、清理或复制工作。</strong></p><p>缺点：使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为<strong>线程切换和上下文转换</strong>的消耗，会使得垃圾回收的总体成本上升，<strong>造成系统吞吐量的下降</strong>。</p><h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><p>一般来说，在相同条件下，堆空间越大，一次 GC 时所需要的时间就越长，有关 GC 产生的停顿也越长。为了更好的控制 GC 产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次 GC 所产生的停顿。</p><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间 region。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p><p>总结：注意，这些只是基本的算法思路，实际 GC 实现过程要复杂的多，目前还在发展中的前沿 GC 都是复合算法，并且并行和并发兼备。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;为什么会有-GC&quot;&gt;&lt;a href=&quot;#为什么会有-GC&quot; class=&quot;headerlink&quot; title=&quot;为什么会有 GC&quot;&gt;&lt;/a&gt;为什么会有 GC&lt;/h1&gt;&lt;p&gt;本质上是内存资源的有限性，因此需要大家共享使用，手工申请，手动释放。&lt;/p&gt;
&lt;p&gt;垃圾收集，不是 Java 语言的伴生产物。早在 1960 年，第一门开始使用内存动态分配和垃圾收集技术的 Lisp 语言诞生。&lt;/p&gt;
&lt;p&gt;关于垃圾收集有三个经典问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哪些内存需要回收？&lt;/li&gt;
&lt;li&gt;什么时候回收？&lt;/li&gt;
&lt;li&gt;如何回收？&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 05 —— JVM 相关工具</title>
    <link href="http://yonghong.tech/java-advance/05-jvm-args-tools/"/>
    <id>http://yonghong.tech/java-advance/05-jvm-args-tools/</id>
    <published>2021-06-11T13:00:00.000Z</published>
    <updated>2021-06-11T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM-命令行工具"><a href="#JVM-命令行工具" class="headerlink" title="JVM 命令行工具"></a>JVM 命令行工具</h2><table><thead><tr><th align="center">工具</th><th>简介</th></tr></thead><tbody><tr><td align="center">java</td><td>Java 应用的启动程序</td></tr><tr><td align="center">javac</td><td>JDK 内置的编译工具</td></tr><tr><td align="center">javap</td><td>反编译 class 文件的工具</td></tr><tr><td align="center">javadoc</td><td>根据 Java 代码和标准注释,自动生成相关的API说明文档</td></tr><tr><td align="center">javah</td><td>JNI 开发时, 根据 java 代码生成需要的 .h文件。</td></tr><tr><td align="center">extcheck</td><td>检查某个 jar 文件和运行时扩展 jar 有没有版本冲突，很少使用</td></tr><tr><td align="center">jdb</td><td>Java Debugger ; 可以调试本地和远端程序, 属于 JPDA 中的一个 demo 实现, 供其他调试器参考。开发时很使用</td></tr><tr><td align="center">jdeps</td><td>探测 class 或 jar 包需要的依赖</td></tr><tr><td align="center">jar</td><td>打包工具，可以将文件和目录打包成为 .jar 文件；.jar 文件本质上就是 zip 文件, 只是后缀不同。使用时按顺序对应好选项和参数即可。</td></tr><tr><td align="center">keytool</td><td>安全证书和密钥的管理工具; （支持生成、导入、导出等操作）</td></tr><tr><td align="center">jarsigner</td><td>JAR 文件签名和验证工具</td></tr><tr><td align="center">policytool</td><td>实际上这是一款图形界面工具, 管理本机的 Java 安全策略</td></tr><tr><td align="center">jps/jinfo</td><td>查看 java 进程</td></tr><tr><td align="center"><strong>jstat</strong></td><td>查看 JVM 内部 gc 相关信息</td></tr><tr><td align="center"><strong>jmap</strong></td><td>查看 heap 或类占用空间统计</td></tr><tr><td align="center"><strong>jstack</strong></td><td>查看线程信息</td></tr><tr><td align="center">jcmd</td><td>执行 JVM 相关分析命令（整合命令）</td></tr><tr><td align="center">jrunscript/jjs</td><td>执行 js 命令</td></tr></tbody></table><span id="more"></span><h3 id="常用命令实例"><a href="#常用命令实例" class="headerlink" title="常用命令实例"></a>常用命令实例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br><span class="line">jps -mlv </span><br><span class="line"><span class="meta">#</span><span class="bash"> -l 列出 Java 进程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -m 列出传递给 main 方法的参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v 列出传递给 JVM 的参数</span></span><br><span class="line"></span><br><span class="line">jinfo pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参考：https://blog.csdn.net/maosijunzi/article/details/46049117</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> jstat   内存信息</span></span><br><span class="line">jstat -gc pid 1000 1000 # 每1000ms打印1次，打印1000次</span><br><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">4352.0 4352.0 4352.0  0.0   34944.0  10175.9   198132.0   152461.3  142132.0 134139.5 19624.0 16988.2     26    0.201   0      0.000    0.201</span><br><span class="line">4352.0 4352.0 4352.0  0.0   34944.0  10175.9   198132.0   152461.3  142132.0 134139.5 19624.0 16988.2     26    0.201   0      0.000    0.201</span><br><span class="line">4352.0 4352.0 4352.0  0.0   34944.0  10175.9   198132.0   152461.3  142132.0 134139.5 19624.0 16988.2     26    0.201   0      0.000    0.201</span><br><span class="line"><span class="meta">#</span><span class="bash"> S0C：第一个幸存区的大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> S1C：第二个幸存区的大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> S0U：第一个幸存区的使用大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> S1U：第二个幸存区的使用大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> EC：伊甸园区的大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> EU：伊甸园区的使用大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> OC：老年代大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> OU：老年代使用大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MC：方法区大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MU：方法区使用大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CCSC：压缩类空间大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CCSU：压缩类空间使用大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> YGC：年轻代垃圾回收次数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> YGCT：年轻代垃圾回收消耗时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> FGC：老年代垃圾回收次数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> FGCT：老年代垃圾回收消耗时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> GCT：垃圾回收消耗总时间</span></span><br><span class="line"></span><br><span class="line">jstat -gcutil pid 1000 1000</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">  0.00  79.37  72.86  78.50  94.45  86.65     27    0.207     0    0.000    0.207</span><br><span class="line">  0.00  79.37  72.86  78.50  94.45  86.65     27    0.207     0    0.000    0.207</span><br><span class="line">  0.00  79.37  72.86  78.50  94.45  86.65     27    0.207     0    0.000    0.207</span><br><span class="line"><span class="meta">#</span><span class="bash"> S0：幸存1区当前使用比例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> S1：幸存2区当前使用比例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> E：伊甸园区使用比例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> O：老年代使用比例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> M：元数据区使用比例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> CCS：压缩使用比例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> YGC：年轻代垃圾回收次数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> FGC：老年代垃圾回收次数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> FGCT：老年代垃圾回收消耗时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> GCT：垃圾回收消耗总时间</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只看 Young 或 Old 区</span></span><br><span class="line">jstat -gcnew pid</span><br><span class="line">jstat -gcold pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> jmap    对象信息</span></span><br><span class="line">jmap -heap pid      # 堆内存</span><br><span class="line">jmap -histo pid     # 直方图</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> jstack  线程信息</span></span><br><span class="line">jstack -l pid       # 将线程相关的 locks 信息一起输 出，比如持有的锁，等待的锁。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> jcmd 综合了前面的几个命令</span></span><br><span class="line">jcmd pid VM.version</span><br><span class="line">jcmd pid VM.flags</span><br><span class="line">jcmd pid VM.command_line</span><br><span class="line">jcmd pid VM.system_properties</span><br><span class="line">jcmd pid Thread.print</span><br><span class="line">jcmd pid GC.class_histogram</span><br><span class="line">jcmd pid GC.heap_info</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当curl命令用</span></span><br><span class="line">jrunscript -e &quot;cat(&#x27;http://www.baidu.com&#x27;)&quot; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行js脚本片段</span></span><br><span class="line">jrunscript -e &quot;print(&#x27;hello,kk.jvm&#x27;+1)&quot; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行js文件</span> </span><br><span class="line">jrunscript -l js -f /XXX/XXX/test.js</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JVM-图形化工具"><a href="#JVM-图形化工具" class="headerlink" title="JVM 图形化工具"></a>JVM 图形化工具</h2><h3 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h3><p>JDK 自带工具</p><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-11-jconsole-mem-MJI7ul.png" alt="jconsole-内存"><br><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-12-jconsole-thread-b0RSWW.png" alt="jconsole-线程"><br><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-12-jconsole-guide-KgMCzE.png" alt="jconsole-概览"></p><h3 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h3><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-15-jvisualvm-guide-JU8yC7.png" alt="jvisualvm"></p><h3 id="VisualGC"><a href="#VisualGC" class="headerlink" title="VisualGC"></a>VisualGC</h3><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-16-VisualGC-poZ5Sm.png" alt="VisualGC"></p><h3 id="jmc"><a href="#jmc" class="headerlink" title="jmc"></a>jmc</h3><p>需要安装 Oracle JDK。</p><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-16-jmc-yNni2V.png" alt="jmc"><br><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-16-jmc-1-5ultLq.png" alt="jmc-1"><br><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-16-jmc-2-gKxxpd.png" alt="jmc-2"><br><img src="https://up-img.yonghong.tech/pic/2021/04/03-17-16-jmc-3-GleUio.png" alt="jmc-3"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;JVM-命令行工具&quot;&gt;&lt;a href=&quot;#JVM-命令行工具&quot; class=&quot;headerlink&quot; title=&quot;JVM 命令行工具&quot;&gt;&lt;/a&gt;JVM 命令行工具&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;工具&lt;/th&gt;
&lt;th&gt;简介&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;java&lt;/td&gt;
&lt;td&gt;Java 应用的启动程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;javac&lt;/td&gt;
&lt;td&gt;JDK 内置的编译工具&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;javap&lt;/td&gt;
&lt;td&gt;反编译 class 文件的工具&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;javadoc&lt;/td&gt;
&lt;td&gt;根据 Java 代码和标准注释,自动生成相关的API说明文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;javah&lt;/td&gt;
&lt;td&gt;JNI 开发时, 根据 java 代码生成需要的 .h文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;extcheck&lt;/td&gt;
&lt;td&gt;检查某个 jar 文件和运行时扩展 jar 有没有版本冲突，很少使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jdb&lt;/td&gt;
&lt;td&gt;Java Debugger ; 可以调试本地和远端程序, 属于 JPDA 中的一个 demo 实现, 供其他调试器参考。开发时很使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jdeps&lt;/td&gt;
&lt;td&gt;探测 class 或 jar 包需要的依赖&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jar&lt;/td&gt;
&lt;td&gt;打包工具，可以将文件和目录打包成为 .jar 文件；.jar 文件本质上就是 zip 文件, 只是后缀不同。使用时按顺序对应好选项和参数即可。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;keytool&lt;/td&gt;
&lt;td&gt;安全证书和密钥的管理工具; （支持生成、导入、导出等操作）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jarsigner&lt;/td&gt;
&lt;td&gt;JAR 文件签名和验证工具&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;policytool&lt;/td&gt;
&lt;td&gt;实际上这是一款图形界面工具, 管理本机的 Java 安全策略&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jps/jinfo&lt;/td&gt;
&lt;td&gt;查看 java 进程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;jstat&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;查看 JVM 内部 gc 相关信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;jmap&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;查看 heap 或类占用空间统计&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;jstack&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;查看线程信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jcmd&lt;/td&gt;
&lt;td&gt;执行 JVM 相关分析命令（整合命令）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jrunscript/jjs&lt;/td&gt;
&lt;td&gt;执行 js 命令&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记（一）</title>
    <link href="http://yonghong.tech/reading-notes/001/"/>
    <id>http://yonghong.tech/reading-notes/001/</id>
    <published>2021-05-31T13:00:00.000Z</published>
    <updated>2021-05-31T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="《秒赞》林桂枝"><a href="#《秒赞》林桂枝" class="headerlink" title="《秒赞》林桂枝"></a>《秒赞》林桂枝</h2><p>1.你的样子里，有你走过的路，读过的书，看过的风景。</p><p>2.想当垃圾吃垃圾，想当辣椒吃辣椒，想当什么自己要想好吃什么。</p><ul><li>创建“好东西”文件夹，在里面放好的设计与照片、出色的演讲、有见地的文章、有趣的事物。</li><li>准备一个“好东西”本子，随时记录有趣的对话和文字，补充新词汇，不断丰富自己的储备。</li><li>将自己认为“有感觉”的词汇记下来，接着将这些词汇分给不同的人和不同的事物，想想这些词该给谁，与什么东西结合最有意思。</li><li>读完一本书，写个简短的读书心得；看完一部电影，记录自己的感受。有时间多写，忙的话写几行字也可以。</li><li>你记录的点点滴滴将会成为你个人的宝贵资产，你的缪斯女神，更是让你工作顺利、表现优秀的利器。</li></ul><p>3.人能想象到的一切都是真实的。——毕加索</p><span id="more"></span><hr><h2 id="《财务自由之路-I》博多·舍费尔"><a href="#《财务自由之路-I》博多·舍费尔" class="headerlink" title="《财务自由之路 I》博多·舍费尔"></a>《财务自由之路 I》博多·舍费尔</h2><p>1.我将生活简化为5个领域：健康、财务、关系、情感和人生意义。5个领域都同等重要。</p><p>2.为什么人们想在短期内变得富有？因为他们想获得足够的能为他们服务的金钱。因为他们想拥有一台赚钱机器，而非穷其一生当一台赚钱机器。因为他们想拥有足够的资金，以过上一种收支平衡的生活。</p><p>3.你的事业建立在你最大的爱好之上。用你的爱好来赚钱。花点时间分析一下，你真正感兴趣的是什么、你的才能在哪方面，之后你才有可能从事一份自己既感兴趣又能赚钱的工作。</p><p>4.责任这个单词在英语中叫作“responsibility”，在这个单词中隐藏着另外两个单词“response”（回应）和“ability”（技巧）。因此，责任这一词用英语来解释就是：有技巧地进行回应。以争吵应对争执，以冲突应对挑衅，绝非最佳的问题解决方式。</p><p>5.如果提的问题是“谁来负责任”，那我们就是在寻找借口。当我们说“你负有责任”时，将事情引向积极方向的机会就消失了。而且，这个关于责任的问题还会将我们一直引向过去。正确的提问应该是：“在当时谁应该对此负责？”但你现在不能拓宽你当时的可控领域，所以需要将精力运用在当下。我们提出的问题也应该以当下为中心：我们现在能做些什么？</p><p>6.日记本是空白的书籍，是你可以自己写作的书籍，专属于你个人。每个人都应该每天写自己的成功日记，记录下当天所有的成功事件：你获得的每一次夸奖和每一次认可，无论是你遵守纪律，完成一项任务，还是你使某人快乐。…… 随着时间的推移，你还需要一本思想日记本（记录你的所有创意）、一本关系日记本（记录所有使你快乐的关系）、一本知识日记本（记录你从自己犯过的错误中学到的所有东西，使你以后不会再重蹈覆辙），以及其他内容的日记本……</p><p>7.去为你的劣势找到解决方案，去为你的优势找一个教练吧！</p><p>8.你在未来5年当中可以休息一整年。在一整年的时间里，你可以做想做的任何事，并有能力支付这一年的所有账单。你可以去旅行，做使你快乐但平时又没有足够时间来做的事情。</p><p>9.一致性不是绝对的美德。如果我今天的观点与昨天不同，是不是就因为改变自身方向而没有一致性了呢？我的确与自己的过去不相一致了，但于真理而言，我是保持一致了……一致性在于按照认知去追随真理。</p><p>10.借口是我们讲给自己听的谎言。我们应该自己对自己越来越诚实，承担越来越多的责任。</p><p>11.全世界最富有的投资者沃伦·巴菲特说过：“毕竟，只有当潮水退去时，你才知道谁在裸泳。”</p><p>12.恐惧永远不应该左右你的决定。因为世界上不存在失败。是的，你没有看错：世界上不存在失败。美国脱口秀大师奥普拉·温弗瑞曾经说过：“我不相信失败。因为如果你享受了过程中的乐趣，那这就不是失败。”</p><p>13.“如果你不经常犯错，表明你冒的风险不够，没有付出最大的努力。”</p><hr><h2 id="《财务自由之路-II》博多·舍费尔"><a href="#《财务自由之路-II》博多·舍费尔" class="headerlink" title="《财务自由之路 II》博多·舍费尔"></a>《财务自由之路 II》博多·舍费尔</h2><p>1.正如爱因斯坦（Einstein）所言，我相信“每个孩子都可能是天才”。我们中的每个人，您和我至少在某方面有着特殊的天赋，而我们应该把这些天赋发挥到极致。</p><p>2.对于大多数人来说，薪水其实是给自己的赔偿费。</p><p>3.当您成功时，生活的大门为您敞开。虽然在通向胜利的道路上，您将会常常看到地狱，然而生活就是如此。但是，如果您坚持梦想，就不会被打倒。您将得到想得到的一切，还有很多很多其他的东西。<br>——弗莱明思（J.Flemmings）</p><p>4.一幢房子是一种负债，而非投资。并且，他希望我首先进行投资。他的原则是：“当您攒够一定数量的资金之后，再购置房产。而且，房子的价值不应超出年净收入的4倍，并且您每月分期付款不应超过月收入的25%。”</p><p>5.许多人仅仅从经济角度来考虑他们的主要事业。他们遵循这样的信条：“什么能赚钱，什么就是我的主要事业。”依我看，这是个完全错误的开端。</p><hr><h2 id="《权力》杰弗瑞·菲佛"><a href="#《权力》杰弗瑞·菲佛" class="headerlink" title="《权力》杰弗瑞·菲佛"></a>《权力》杰弗瑞·菲佛</h2><p>1.处在一个权力小、地位低的职位上可能会危害你的健康，相反，拥有权力及相应的控制权则会延长你的寿命。</p><p>2.你要克服自己这个障碍，克服对自我形象的过分关注，或者是特别在意别人对你的看法。无论如何，其他人不会特别关心或惦记你，他们关注的主要是他们自己。如果你不去尝试获得影响力，你也许能够维护良好的形象，但却无法登上权力的顶峰。</p><p>3.雇员的薪酬与他们的年龄和在组织中任期长短的关系，强于薪酬与工作绩效的关系。</p><p>4.掌权者自我感觉良好，最好的方法之一就是恭维他们。</p><p>5.为你的成功负责的人，是你的上司，是有权力提升你或者阻止你在组织中晋升的人。而且不管你的位置在哪里，总会有人在你上面。所以你的工作就是，确保那些有影响力的人有强烈的愿望让你获得成功。这可能需要你做好工作，但也可能需要确保掌权者知道你的工作做得很好，确保他们记得你，对你的评价很高，因为你能让他们自我感觉良好。业绩和职场政治技巧结合在一起，才能帮助你获得晋升。只靠业绩本身是不够的，在某些情况下，业绩甚至可能是无关痛痒的。</p><p>6.一些人晋升到很高的位置并成就了惊人的事业，他们与其他人的不同之处有两点：意愿和技能。意愿是使人愿意承担巨大挑战的驱动力，技能则是把雄心转换为成就的能力。意愿体现在个人素质中，就是雄心、精力和专注。而有助于获得权力的4项技能，则分别是自知之明和反省心态、散发自信的信心和能力、理解他人并懂得换位思考以及化解冲突的能力。在对以上每个特质进行说明之后，我将讨论另一个特质：智力。智力和权力有些关系，但我认为它被严重高估了。</p><p>7.如果你对你的工作值多少回报没有自信，对你想要的东西也不自信，你就不愿意要求或者推动别人，因此，相较于那些比你活跃的人而言，你获得的金钱或影响力就比较少。</p><p>8.引人注意可以帮助你获得你需要的位置和权力。你应该为你想要的东西提出请求，并且在为自己构建权力之路时，不要太在乎别人怎么看你。但是，要获得和行使权力，就需要资源来奖励你的朋友和惩罚你的敌人，需要信息和门路来促进你在组织中的升迁。</p><p>9.事实上人们常犯的一个严重错误是，他们以为在目前的职位上无法建立权力基础和掌握资源，以为需要在更高的职位上才能这样做。其实，如果你把权力基础打好，那么攀升到更高的职位就会变得更简单容易一些，而且你在任何时候都可以这样做，永远都不会太早或太迟。</p><p>10.领导的实质就是：让拥有不同能力和视角的人或部门协作，共同完成一项任务或达成一桩交易。</p><p>11.领导力的秘诀就是要扮演角色，要装模作样，要在这门舞台艺术上富于技巧。</p><p>12.与表达悲伤、内疚或自责的人相比，表达愤怒的人通常被视为更加强大。</p><p>13.领导力的秘诀就是要扮演角色，要装模作样，要在这门舞台艺术上富于技巧。</p><p>14.我们选择了我们行事和说话的方式，这些决定对于获取和保持权力而言非常重要。</p><p>15.“权力之中有20%是被赋予的，有80%是自己获取的。”</p><p>16.一旦人们对某个人形成了印象，他们就不会承认任何与他们最初想法不一致的信息。</p><p>17.行为动力机制倾向于巩固人们的初步印象和声望，并倾向于让这些印象成真，即使它们一开始并不是真的。</p><p>18.这里的建议不是让你在任何一个单一的地方留下良好的印象，而是建议你找到一个可以让你树立辉煌声望的环境，也就是建议你不断尝试不同的环境，直到你成功地发现了这样一个环境为止。</p><p>19.由于人们来自不同的背景，面临的激励机制不同，获得的信息不同，所以他们所看到的世界也各不相同。因此在组织中，分歧是不可避免的。令人遗憾的是，许多人都会尝试避免冲突，他们认为分歧令人不快，因此他们避免让不同的意见浮出水面，也避免与对手进行艰难的交谈。</p><p>20.如果你处在一个权力相当大的位置上，而你觉得自己变得越来越疲倦时，那你还不如离开这个位置。</p><p>21.人们包括公司都容易落入能力陷阱。他们曾以某种方式做某些事，并获得了成功。</p><p>22.有些人以为自己不喜欢或者不可能喜欢玩权力游戏。但他们根本就没有尝试过，又如何知道自己会不喜欢呢？</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;《秒赞》林桂枝&quot;&gt;&lt;a href=&quot;#《秒赞》林桂枝&quot; class=&quot;headerlink&quot; title=&quot;《秒赞》林桂枝&quot;&gt;&lt;/a&gt;《秒赞》林桂枝&lt;/h2&gt;&lt;p&gt;1.你的样子里，有你走过的路，读过的书，看过的风景。&lt;/p&gt;
&lt;p&gt;2.想当垃圾吃垃圾，想当辣椒吃辣椒，想当什么自己要想好吃什么。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建“好东西”文件夹，在里面放好的设计与照片、出色的演讲、有见地的文章、有趣的事物。&lt;/li&gt;
&lt;li&gt;准备一个“好东西”本子，随时记录有趣的对话和文字，补充新词汇，不断丰富自己的储备。&lt;/li&gt;
&lt;li&gt;将自己认为“有感觉”的词汇记下来，接着将这些词汇分给不同的人和不同的事物，想想这些词该给谁，与什么东西结合最有意思。&lt;/li&gt;
&lt;li&gt;读完一本书，写个简短的读书心得；看完一部电影，记录自己的感受。有时间多写，忙的话写几行字也可以。&lt;/li&gt;
&lt;li&gt;你记录的点点滴滴将会成为你个人的宝贵资产，你的缪斯女神，更是让你工作顺利、表现优秀的利器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.人能想象到的一切都是真实的。——毕加索&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://yonghong.tech/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="http://yonghong.tech/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 04 —— JVM 内存模型：堆和栈是什么？</title>
    <link href="http://yonghong.tech/java-advance/04-jvm-mem/"/>
    <id>http://yonghong.tech/java-advance/04-jvm-mem/</id>
    <published>2021-05-16T13:00:00.000Z</published>
    <updated>2021-05-16T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM-运行时数据区概述"><a href="#JVM-运行时数据区概述" class="headerlink" title="JVM 运行时数据区概述"></a>JVM 运行时数据区概述</h2><p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。结合 JVM 虚拟机规范，来讨论一下经典的 JVM 内存布局。</p><p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。而另外一些则是与线程一一对应的，这些与线对应的数据区域会随着线程开始和结束而创建和销毁。</p><span id="more"></span><h3 id="JVM-整体架构"><a href="#JVM-整体架构" class="headerlink" title="JVM 整体架构"></a>JVM 整体架构</h3><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-19-47-VusNfO-S1kg66.png" alt="JVM 整体架构 - 英文"></p><hr><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-19-46-8oddUR-oMwPkk.png" alt="JVM 整体架构 - 中文"></p><h3 id="JVM-系统线程"><a href="#JVM-系统线程" class="headerlink" title="JVM 系统线程"></a>JVM 系统线程</h3><p>线程是一个程序里的运行单元。JVM 允许一个应用有多个线程并行的执行</p><p>在 HotSpot 虚拟机里，每个线程都与操作系统的本地线程直接映射。当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java 线程执行终止后，本地线程也会回收</p><p>操作系统负责所有的线程的安排调度到任何一个可用的 CPU 上。一旦本地线程初始化成功，它就会调用 Java 线程中的人run() 方法</p><p>如果你使用 jconsole 或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用 public static void main(String[] args) 的 main 线程以及所有这个 main 线程自己创建的线程。</p><p>这些主要的后台系统线程在 HotSpot 虚拟机里主要是以下几个</p><ul><li>虚拟机线程：这种线程的操作是需要 JVM 达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要 JVM 达到安全点，这样堆才不会变化。这种线程的执行类型包括“stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</li><li>GC 线程：这种线程对在 JVM 里不同种类的垃圾收集行为提供了支持</li><li>编译线程：这种线程在运行时会将字节码编译成本地代码</li><li>信号调度线程：这种线程接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理</li></ul><h2 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-39-01-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-OjY1mD.png" alt="JVM内存结构"></p><ul><li>每个线程只能访问自己的线程栈。</li><li>每个线程都不能访问（看不见）其他线程的局部变量。</li><li>所有原生类型的局部变量都存储在线程栈中，因此对其他线程是不可见的。</li><li>线程可以将一个原生变量值的副本传给另一个线程，但不能共享原生局部变量本身。</li><li>堆内存中包含了 Java 代码中创建的所有对象，不管是哪个线程创建的。其中也涵盖了包装类型（例如，Byte，Integer，Long等）。</li><li>不管是创建一个对象并将其值赋值给局部变量，还是赋值给另一个对象的成员变量，创建的对象都会被保存到堆内存中。</li></ul><hr><ul><li>如果是原生数据类型的局部变量，那么它的内容就全部保留在线程栈上。 </li><li>如果是对象引用，则栈中的局部变量槽位中保存着对象的引用地址，而实际的对象内容保存在堆中。</li><li>对象的成员变量与对象本身一起存储在堆上，不管成员变量的类型是原生数据类型，还是对象引用。</li><li>类的静态变量则和类定义一样都保存在堆中。</li></ul><hr><ul><li>总结一下：方法中使用的原生数据类型和对象引用地址在栈上存储；对象、对象成员与类定义、静态变量在堆上。</li><li>堆内存又称为“共享堆”，堆中的所有对象，可以被所有线程访问，只要他们能拿到对象的引用地址。</li><li>如果一个线程可以访问某个对象时，也就可以访问该对象的成员变量。</li><li>如果两个线程同时调用某个对象的同一方法，则它们都可以访问到这个对象的成员变量，但每个线程的局部变量副本是独立的。</li></ul><h2 id="JVM-内存整体结构"><a href="#JVM-内存整体结构" class="headerlink" title="JVM 内存整体结构"></a>JVM 内存整体结构</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-41-01-JVM%E5%86%85%E5%AD%98%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84-eSeqP8.png" alt="JVM内存整体结构"></p><ul><li>每启动一个线程，JVM就会在栈空间栈分配对应的线程栈，比如 1MB 空间（-Xss1m） </li><li>线程栈也叫做 Java 方法栈。如果使用了 JNI 方法，则会分配一个单独的本地方法栈（Native Stack） </li><li>线程执行过程中，一般会有多个方法组成调用栈（Stack Trace），比如 A 调用 B，B 调用 C 。每执行到一个方法，就会创建对应的栈帧（Frame）。</li></ul><h2 id="JVM-栈内存机构"><a href="#JVM-栈内存机构" class="headerlink" title="JVM 栈内存机构"></a>JVM 栈内存机构</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-44-01-JVM%E6%A0%88%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-Z8QlQS.png" alt="JVM栈内存结构"></p><ul><li>栈帧是一个逻辑上的概念，具体的大小在一个方法编写完成后基本上就能确定。 </li><li>比如返回值，需要有一个空间存放吧，每个局部变量都需要对应的地址空间，此外还有给指令使用的操作数栈，以及 Class 指针（标识这个栈帧对应的是哪个类的方法，指向非堆里面的 Class 对象）。</li></ul><h2 id="JVM-堆内存结构"><a href="#JVM-堆内存结构" class="headerlink" title="JVM 堆内存结构"></a>JVM 堆内存结构</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-45-01-JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-0TRoeN.png" alt="JVM堆内存结构"></p><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-46-01-jconsole%E5%86%85%E5%AD%98-KNrKkU.png" alt="jconsole内存"></p><ul><li>堆内存是所有线程共用的内存空间，JVM 将 Heap 内存分为年轻代（Young generation）和老年代（Old generation，也叫 Tenured）两部分。</li><li>年轻代还划分为3个内存池，伊甸园区（Eden space）和存活区（Survivor space），在大部分GC算法中有两个存活区（S0，S1），在我们可以观察到的任何时刻，S0和S1总有一个是空的，但一般很小，也浪费不了多少空间。</li><li>Non-Heap本质上还是Heap，只是一般不归GC管理，里面划分为3个内存区池。</li><li>Metaspace 以前叫持久代（永久代，Permanent generation），Java 换了个名字叫 Metaspace</li><li>CCS Compressed Class Space，存放 class 信息的，和 Metaspace 有交叉</li><li>Code Cache，存放 JIT 编译器编译后的本地机器代码。</li></ul><h2 id="CPU-与内存行为"><a href="#CPU-与内存行为" class="headerlink" title="CPU 与内存行为"></a>CPU 与内存行为</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-47-01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84-3aWMrH.png" alt="计算机硬件架构"></p><ul><li>CPU 乱序执行</li><li>volatile 关键字</li><li>原子性操作</li><li>内存屏障</li></ul><h2 id="Java对象模型"><a href="#Java对象模型" class="headerlink" title="Java对象模型"></a>Java对象模型</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-47-01-Java%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-K1uNvD.png" alt="Java对象模型"></p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-47-01-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-G12dzM.jpg" alt="Java内存模型"></p><p>JMM 规范对应的是 JSR-133 Java Memory Model and Thread Specification 《Java 语言规范》 $17.4 Memory Model 章节</p><p>JMM 规范明确定义了不同的线程之间通过哪些方式，在什么时候可以看见其他线程保存到共享变量中的值；以及在必要时，如何对共享变量的访问进行同步。这样的好处是屏蔽各种硬件平台的操作系统之间的内存访问差异，实现了Java并发程序真正的跨平台。</p><ul><li>所有的对象（包括内部的实例成员变量），static 变量，以及数组，都必须存放到堆内存中。</li><li>局部变量，方法的形参/入参，异常处理语句的入参不允许在线程之间共享，所以不受内存模型的影响。</li><li>多个线程同时对一个变量访问时【读取/写入】，这时候只要有某个线程执行的是写操作，那么这种现象称之为“冲突”。</li><li>可以被其他线程影响或感知的操作，称为线程间的交互行为，可分为：读取、写入、同步操作、外部操作等等。其中同步操作包括：对 volatile 变量的读写，对管程（monitor）的锁定与解锁，线程的起始操作与结尾操作，线程启动和结束等等。外部操作则是指对线程执行环境之外的操作，比如停止其他线程等等。</li><li>JMM 规范的是线程间的交互操作，而不管线程内部对局部变量进行的操作。</li></ul><hr><h2 id="JVM-启动参数"><a href="#JVM-启动参数" class="headerlink" title="JVM 启动参数"></a>JVM 启动参数</h2><ul><li>以 - 开头为标准参数，所有的 JVM 都要实现这些参数，并且向后兼容。例，<code>-server</code></li><li>-D 设置系统属性。例，<code>-Dfile.encoding=UTF-8</code></li><li>以 -X 开头为非标准参数，基本都是传给 JVM 的，默认 JVM 实现这些参数的功能，但是并不保证所有 JVM 实现都满足，且不保证向后兼容。可以使用 <code>java -X</code> 命令来查看当前 JVM 支持的非标准参数。例，<code>-Xmx8g</code></li><li>以 -XX: 开头为非稳定参数，专门用于控制 JVM 的行为，跟具体的 JVM 实现有关，随时可能会在下个版本取消。<ul><li>-XX: +-Flags 形式，+-是对布尔值进行开关。例，<code>-XX:+UseG1GC</code></li><li>-XX: key=value 形式，指定某个选项的值。例，<code>-XX:MaxPermSize=256m</code></li></ul></li></ul><p>1.系统属性参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-Dfile.encoding=UTF-<span class="number">8</span></span><br><span class="line">-Duser.timezone=GMT+08</span><br><span class="line">-Dmaven.test.skip=<span class="keyword">true</span></span><br><span class="line">-Dio.netty.eventLoopThreads=<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以这样</span></span><br><span class="line">System.setProperty(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;A100&quot;</span>);</span><br><span class="line">String a = System.getProperty(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure><p>2.运行模式参数</p><ul><li>-server: 设置 JVM 使用 server 模式，特点是启动速度比较慢，但运行时性能和内存管理效率很高，适用于生产环境。在具有 64 位能力的 JDK 环境下将默认启用该模式，而忽略 -client 参数。</li><li>-client: JDK1.7 之前在32位的 x86 机器上的默认值是 -client 选项。设置 JVM 使用 client 模式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或者 PC 应用开发和调试。此外，我们知道 JVM 加载字节码后，可以解释执行，也可以编译成本地代码再执行，所以可以配置 JVM 对字节码的处理模式。</li><li>-Xint: 在解释模式(interpreted mode)下运行，-Xint 标记会强制 JVM 解释执行所有的字节码，这当然会降低运行速度，通常低10倍或更多。</li><li>-Xcomp: -Xcomp 参数与 -Xint 正好相反，JVM 在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化。【注意预热】</li><li>-Xmixed: -Xmixed 是混合模式，将解释模式和编译模式进行混合使用，有 JVM 自己决定，这是 JVM 的默认模式，也是推荐模式。 我们使用 java -version 可以看到 mixed mode 等信息。</li></ul><p>3.堆内存设置参数</p><ul><li>-Xmx, 指定最大堆内存。 如 -Xmx4g. 这只是限制了 Heap 部分的最大值为4g。这个内存不包括栈内存，也不包括堆外使用的内存。</li><li>-Xms, 指定堆内存空间的初始大小。 如 -Xms4g。 而且指定的内存大小，并不是操作系统实际分配的初始值，而是GC先规划好，用到才分配。专用服务器上需要保持 –Xms 和 –Xmx 一致，否则应用刚启动可能就有好几个 FullGC。 当两者配置不一致时，堆内存扩容可能会导致性能抖动。</li><li>-Xmn, 等价于 -XX:NewSize，使用 G1 垃圾收集器 不应该 设置该选项，在其他的某些业务场景下可以设置。官方建议设置为 -Xmx 的 1/2 ~ 1/4.</li><li>-XX:MaxPermSize=size, 这是 JDK1.7 之前使用的。Java8 默认允许的 Meta空间无限大，此参数无效。</li><li>-XX:MaxMetaspaceSize=size, Java8 默认不限制 Meta 空间, 一般不允许设置该选项。</li><li>-XX:MaxDirectMemorySize=size，系统可以使用的最大堆外内存，这个参数跟 -Dsun.nio.MaxDirectMemorySize 效果相同。</li><li>-Xss, 设置每个线程栈的字节数，影响栈的深度。 例如 -Xss1m 指定线程栈为 1MB，与-XX:ThreadStackSize=1m 等价</li></ul><ol><li>如果什么都不配置会如何?</li><li>Xmx 是否与 Xms 设置相等?</li><li>Xmx 设置为机器内存的什么比例合适?</li><li>作业: 画一下 Xmx、Xms、Xmn、Meta、DirectMemory、Xss 这些内存参数的关系</li></ol><p>4.GC设置参数</p><ul><li>-XX:+UseG1GC:使用 G1 垃圾回收器 </li><li>-XX:+UseConcMarkSweepGC:使用 CMS 垃圾回收器 </li><li>-XX:+UseSerialGC:使用串行垃圾回收器 </li><li>-XX:+UseParallelGC:使用并行垃圾回收器</li><li>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC // Java 11+</li><li>-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC // Java 12+</li></ul><p>各个 JVM 版本的默认 GC 是什么?</p><p>5.分析诊断参数</p><ul><li>-XX:+-HeapDumpOnOutOfMemoryError 选项, 当 OutOfMemoryError 产生，即内存溢出(堆内存或持久代)时，自动 Dump 堆内存。<ul><li>示例用法: java -XX:+HeapDumpOnOutOfMemoryError -Xmx256m ConsumeHeap</li></ul></li><li>-XX:HeapDumpPath 选项, 与 HeapDumpOnOutOfMemoryError 搭配使用, 指定内存溢出时 Dump 文件的目 录。如果没有指定则默认为启动 Java 程序的工作目录。<ul><li>示例用法: java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/ ConsumeHeap </li><li>自动 Dump 的 hprof 文件会存储到 /usr/local/ 目录下</li></ul></li><li>-XX:OnError 选项, 发生致命错误时(fatal error)执行的脚本。<ul><li>例如, 写一个脚本来记录出错时间, 执行一些命令, 或者 curl 一下某个在线报警的 url. 示例用法:java -XX:OnError=”gdb - %p” MyApp</li><li>可以发现有一个 %p 的格式化字符串，表示进程 PID。</li></ul></li><li>-XX:OnOutOfMemoryError 选项, 抛出 OutOfMemoryError 错误时执行的脚本。 </li><li>-XX:ErrorFile=filename 选项, 致命错误的日志文件名,绝对路径或者相对路径。</li><li>-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1506，远程调试</li></ul><p>6.JavaAgent参数</p><p>Agent 是 JVM 中的一项黑科技, 可以通过无侵入方式来做很多事情，比如注入 AOP 代码，执行统计等等，权限非常大。这里简单介绍一下配置选项，详细功能需要专门来讲。</p><p>设置 agent 的语法如下:</p><ul><li>-agentlib:libname[=options] 启用 native 方式的 agent, 参考 LD_LIBRARY_PATH 路径。</li><li>-agentpath:pathname[=options] 启用 native 方式的 agent。</li><li>-javaagent:jarpath[=options] 启用外部的 agent 库, 比如 pinpoint.jar 等等。</li><li>-Xnoagent 则是禁用所有 agent。 以下示例开启 CPU 使用时间抽样分析:<ul><li>JAVA_OPTS=”-agentlib:hprof=cpu=samples,file=cpu.samples.log”</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;JVM-运行时数据区概述&quot;&gt;&lt;a href=&quot;#JVM-运行时数据区概述&quot; class=&quot;headerlink&quot; title=&quot;JVM 运行时数据区概述&quot;&gt;&lt;/a&gt;JVM 运行时数据区概述&lt;/h2&gt;&lt;p&gt;内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。结合 JVM 虚拟机规范，来讨论一下经典的 JVM 内存布局。&lt;/p&gt;
&lt;p&gt;Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。而另外一些则是与线程一一对应的，这些与线对应的数据区域会随着线程开始和结束而创建和销毁。&lt;/p&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 03 —— 类加载器和双亲委派到底是什么？</title>
    <link href="http://yonghong.tech/java-advance/03-jvm-classloader/"/>
    <id>http://yonghong.tech/java-advance/03-jvm-classloader/</id>
    <published>2021-05-15T13:00:00.000Z</published>
    <updated>2021-05-15T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类加载子系统作用"><a href="#类加载子系统作用" class="headerlink" title="类加载子系统作用"></a>类加载子系统作用</h2><ul><li>类加载子系统负责从文件系统或者网络中加载 Class 文件，Class 文件在文件开头有特定的文件标识（cafebabe）</li><li>ClassLoader 只负责 Class 文件的加载，至于它是否能够运行，则由 Execution Engine 决定</li><li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区还存放运行时常量池信息，可能还包含字符串字面值和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）</li></ul><span id="more"></span><h2 id="类加载器的角色"><a href="#类加载器的角色" class="headerlink" title="类加载器的角色"></a>类加载器的角色</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-20-16-U6ND22-TgTnLm.png" alt="类加载器的角色"></p><ul><li>class file 存放于本地硬盘上，可以理解成设计师画在纸上的模板，最终这个模板在执行的时候要加载到 JVM 中来，根据这个文件实例化出 n 个一模一样的实例</li><li>class file 加载到 JVM 中，被称为 DNA 原数据模板，放在方法区</li><li>在 class 文件 -&gt; JVM -&gt; 最终成为原数据模板，此过程需要一个运输工具，即类加载器 Class Loader，扮演一个快递员的角色</li></ul><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-18-01-%E7%B1%BB%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%847%E4%B8%AA%E6%AD%A5%E9%AA%A4-r3r8RQ.png" alt="类生命周期的7个步骤"></p><ol><li>加载（Loading）：找Class文件</li><li>验证（Verification）：验证格式、依赖</li><li>准备（Preparation）：静态字段、方法表</li><li>解析（Resolution）：符号解析为引用</li><li>初始化（Initialization）：构造器、静态变量赋值、静态代码块</li><li>使用（Using）</li><li>卸载（Unloading）</li></ol><h3 id="Loading-阶段"><a href="#Loading-阶段" class="headerlink" title="Loading 阶段"></a>Loading 阶段</h3><ol><li><p>通过一个类的全限定名获取定义此类的二进制字节流</p></li><li><p>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据区</p></li><li><p><strong>在内存中生成一个代表这个类的 java.lang.Class 对象</strong>，作为方法区这个类的各种数据的访问入口</p></li></ol><p>补充：加载 class 文件的方式</p><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从 zip 压缩包中读取，成为日后 jar、war 格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP 应用</li><li>从专有数据库中提取 class 文件，比较少见</li><li>从加密文件中获取，典型的防 class 文件被反编译的保护措施</li></ul><h3 id="Linking-阶段"><a href="#Linking-阶段" class="headerlink" title="Linking 阶段"></a>Linking 阶段</h3><p>1.验证（Verify）：</p><ul><li>目的在于确保 class 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机的自身安全</li><li>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证</li></ul><p>2.准备（Prepare）：</p><ul><li>为类变量分配内存并且设置该类变量的默认初始值，即零值</li><li>这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，准备阶段会显示初始化</li><li>这里不会为实例变量分配初始值，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中</li></ul><p>3.解析（Resolve）：</p><ul><li>将常量池内的符号引用转换为直接引用的过程</li><li>事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java 虚拟机规范》的 class 文件格式中。直接引用就是直接指向目标的指针、相对偏移量或者一个间接定位到目标的句柄</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等。</li></ul><h3 id="Initialization-阶段"><a href="#Initialization-阶段" class="headerlink" title="Initialization 阶段"></a>Initialization 阶段</h3><ul><li>初始化阶段就是执行类构造器方法 <code>&lt;clinit&gt;()</code> 的过程</li><li>此方法不需要定义，是 javac 编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来</li><li>构造器方法中指令按语句在源文件中出现的顺序执行</li><li><code>&lt;clinit&gt;()</code> 不同于类的构造器。（关联：构造器是虚拟机视角下的 <code>&lt;init&gt;()</code>）</li><li>若该类具有父类，JVM 会保证子类的 <code>&lt;clinit&gt;()</code> 执行前，父类的 <code>clinit()</code> 已经执行完毕</li><li>虚拟机必须保证一个类的 <code>clinit()</code> 方法在多线程下被同步加载</li></ul><h2 id="类的加载时机"><a href="#类的加载时机" class="headerlink" title="类的加载时机"></a>类的加载时机</h2><ol><li>当虚拟机启动时，初始化用户指定的主类，就是启动执行的main方法所在的类；</li><li>当遇到用一新建目标类实例的new指令时，初始化new指令的目标类，就是new一个类的时候要初始化；</li><li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li><li>当遇到访问静态字段的指令时，初始化该静态字段所在的类；</li><li>子类的初始化会触发父类的初始化；</li><li>如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类初始化，会触发该接口的初始化；</li><li>使用反射API对某个类型进行反射调用时，初始化这个类，其实跟前面一样，反射调用要么是已经有实例了，要么是静态方法，都需要初始化；</li><li>当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类；</li></ol><h3 id="不会初始化（可能会加载）"><a href="#不会初始化（可能会加载）" class="headerlink" title="不会初始化（可能会加载）"></a>不会初始化（可能会加载）</h3><ol><li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化；</li><li>定义对象数组，不会触发该类的初始化；</li><li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类；</li><li>通过类名获取Class对象，不会触发类的初始化，Hello.class不会让Hello类初始化；</li><li>通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化，Class.forName(“jvm.Hello”) 默认会加载Hello类；</li><li>通过ClassLoader默认的loadClass方法，也不会触发初始化动作（加载了，但是不会初始化）；</li></ol><h2 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-23-01-3%E4%B8%AA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-pnd3RO.png" alt="3个类加载器"></p><ul><li>启动类加载器（引导类加载器，Bootstrap ClassLoader）<ul><li>这个类加载器使用 C/C++ 语言实现的，嵌套在 JVM 内部</li><li>它用来加载 Java 的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类</li><li>并不继承自 java.lang.ClassLoader，没有父加载器。</li><li>加载拓展类和应用程序类加载器，并指定为他们的父类加载器</li><li>出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类</li></ul></li><li>拓展类加载器（Extension ClassLoader）<ul><li>Java 语言编写，由 sun.misc.Launcher$ExtClassLoader 实现</li><li>派生于 ClassLoader 类</li><li>父类加载器为启动类加载器</li><li>从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/lib/ext 子目录（拓展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由拓展类加载器加载</li></ul></li><li>应用程序类加载器（系统类加载器，AppClassLoader）<ul><li>java 语言编写，由 sun.misc.Launcher$AppClassLoader 实现</li><li>派生于 ClassLoader 类</li><li>父类加载器为拓展类加载器</li><li>他负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java 应用的类都是由它来完成加载</li><li>通过 ClassLoader$getSystemClassLoader() 方法可以获取到该类加载器</li></ul></li></ul><p>类加载器可以通过getParent获取父加载器，这并不是继承关系，如果直接继承ClassLoader自己实现一个类加载器，且不指定父加载器，他的父加载器就是AppClassLoader</p><p>任何parent为null的加载器，其父加载器为 BootstrapClassLoader</p><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-26-01-%E6%8B%93%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%BA%94%E7%94%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-PRIfeU.png" alt="拓展类加载器和应用类加载器"></p><h2 id="加载器特点"><a href="#加载器特点" class="headerlink" title="加载器特点"></a>加载器特点</h2><h3 id="双亲委托"><a href="#双亲委托" class="headerlink" title="双亲委托"></a>双亲委托</h3><p>Java 虚拟机对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。</p><ul><li>如果一个类加载器收到了类加载的请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行</li><li>如果父类加载器还存在其他父类加载器，则进一步向上委托，依次递归请求最终将到达顶层的启动类加载器</li><li>如果父类加载器可以完成类的加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制</li></ul><p><strong>优势</strong></p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心 API 被随意篡改</li></ul><p><strong>沙箱安全机制</strong></p><p>自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载过程中会率先加载 JDK 自带的文件（rt.jar 包中 java/lang/String.class），报错信息说没有 main 方法，就是因为加载的是rt.jar 包中的 String 类。这样可以保证对 Java 核心源代码的保护，这就是沙箱安全机制。</p><p>在 JVM 中表示两个 class 对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名</li><li>加载这个类的 ClassLoader （指 ClassLoader 实例对象）必须相同</li></ul><p>换句话说，在 JVM 中，即使这两个类对象（class 对象）来源于同一个 Class 文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的。</p><p>JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么 JVM 会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。</p><h3 id="负责依赖"><a href="#负责依赖" class="headerlink" title="负责依赖"></a>负责依赖</h3><p>如果一个类依赖了其他的类，那么就需要先加载依赖的类。</p><h3 id="缓存加载"><a href="#缓存加载" class="headerlink" title="缓存加载"></a>缓存加载</h3><p>类加载之后，就把它缓存起来，后续从缓存中获取</p><h2 id="关于-ClassLoader"><a href="#关于-ClassLoader" class="headerlink" title="关于 ClassLoader"></a>关于 ClassLoader</h2><p>ClassLoader 类，它是一个抽象类，其后所有的类加载器都继承自 ClassLoader （不包括启动类加载器）</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>getParent()</td><td>返回该类加载器的超类加载器</td></tr><tr><td>loadClass(String name)</td><td>加载名称为 name 的类，返回结果为 java.lang.Class 类的实例</td></tr><tr><td>findClass(String name)</td><td>查找名称为 name 的类，返回结果为 java.lang.Class 类的实例</td></tr><tr><td>findLoadedClass(String name)</td><td>查找名称为 name 的已经被加载过的类，返回结果为 java.lang.Class 类的实例</td></tr><tr><td>defineClass(String name, byte[] b, int off, int len)</td><td>把字节数组 b 中的内存转换成为一个 Java 类，返回结果为 java.lang.Class 类的实例</td></tr><tr><td>resolveClass(Class&lt;?&gt; c)</td><td>连接指定的一个 Java 类</td></tr></tbody></table><h2 id="获取-ClassLoader-的途径"><a href="#获取-ClassLoader-的途径" class="headerlink" title="获取 ClassLoader 的途径"></a>获取 ClassLoader 的途径</h2><p>方式一：获取当前类的 ClassLoader</p><p>clazz.getClassLoader()</p><p>方式二：获取当前线程上下文的 ClassLoader</p><p>Thread.currentThread().getContextClassLoader()</p><p>方式三：获取系统的ClassLoader</p><p>ClassLoader.getSystemClassLoader()</p><p>方式四：获取调用者的 CLassLoader</p><p>DriverManager.getCallerClassLoader()</p><h2 id="显示当前-ClassLoader-加载了哪些-Jar-？"><a href="#显示当前-ClassLoader-加载了哪些-Jar-？" class="headerlink" title="显示当前 ClassLoader 加载了哪些 Jar ？"></a>显示当前 ClassLoader 加载了哪些 Jar ？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmClassLoaderPrintPath</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动类加载器</span></span><br><span class="line">        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        System.out.println(<span class="string">&quot;启动类加载器&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; ===&gt; &quot;</span> + url.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓展类加载器</span></span><br><span class="line">        printClassLoader(<span class="string">&quot;拓展类加载器&quot;</span>, JvmClassLoaderPrintPath.class.getClassLoader().getParent());</span><br><span class="line">        <span class="comment">// 应用类加载器</span></span><br><span class="line">        printClassLoader(<span class="string">&quot;应用类加载器&quot;</span>, JvmClassLoaderPrintPath.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassLoader</span><span class="params">(String name, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot; ClassLoader -&gt; &quot;</span> + classLoader.toString());</span><br><span class="line">            printUrlForClassLoader(classLoader);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot; ClassLoader -&gt; null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUrlForClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        Object ucp = insightField(classLoader, <span class="string">&quot;ucp&quot;</span>);</span><br><span class="line">        Object path = insightField(ucp, <span class="string">&quot;path&quot;</span>);</span><br><span class="line">        ArrayList ps = (ArrayList) path;</span><br><span class="line">        <span class="keyword">for</span> (Object p : ps) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; ===&gt; &quot;</span> + p.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">insightField</span><span class="params">(Object obj, String fName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field f = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> URLClassLoader) &#123;</span><br><span class="line">                f = URLClassLoader.class.getDeclaredField(fName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f = obj.getClass().getDeclaredField(fName);</span><br><span class="line">            &#125;</span><br><span class="line">            f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> f.get(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">启动类加载器</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/resources.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/rt.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/sunrsasign.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/jsse.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/jce.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/charsets.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/jfr.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/classes</span><br><span class="line">拓展类加载器 ClassLoader -&gt; sun.misc.Launcher$ExtClassLoader@6d06d69c</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/sunec.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/nashorn.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/cldrdata.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/dnsns.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/localedata.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/sunjce_provider.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/sunpkcs11.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/jaccess.jar</span><br><span class="line"> ===&gt; file:/Users/yq/.sdkman/candidates/java/8.0.275.hs-adpt/jre/lib/ext/zipfs.jar</span><br><span class="line"> ===&gt; file:/System/Library/Java/Extensions/MRJToolkit.jar</span><br><span class="line">应用类加载器 ClassLoader -&gt; sun.misc.Launcher$AppClassLoader@659e0bfd</span><br><span class="line"> ===&gt; file:/Users/yq/code/wangyonghong/code-lab/gtu-java/out/production/gtu-java/</span><br></pre></td></tr></table></figure><h2 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h2><ul><li><p>在 Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式</p></li><li><p>为什么要自定义类加载器</p><ul><li>隔离加载类</li><li>修改类加载方式</li><li>拓展加载源</li><li>防止源码泄露</li></ul></li><li><p>开发人员可以通过继承抽象类 java.lang.ClassLoader 类的方式，实现自己的类加载器，以满足一些特殊需求</p></li><li><p>在 JDK 1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载器类，但是在 JDK 1.2 之后已不再建议用户去覆盖 loadClass() 方法，而是建议把自定义的类加载逻辑写在 findClass() 方法中</p></li><li><p>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findClass() 方法以及获取字节码流的方式，使自定义类加载器编写更加简单</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, classLoader!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以下方法拿到 base64</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac Hello.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> base64 Hello.class</span> </span><br><span class="line">yv66vgAAADQAHAoABgAOCQAPABAIABEKABIAEwcAFAcAFQEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAAVoZWxsbwEAClNvdXJjZUZpbGUBAApIZWxsby5qYXZhDAAHAAgHABYMABcAGAEAE0hlbGxvLCBjbGFzc0xvYWRlciEHABkMABoAGwEABUhlbGxvAQAQamF2YS9sYW5nL09iamVjdAEAEGphdmEvbGFuZy9TeXN0ZW0BAANvdXQBABVMamF2YS9pby9QcmludFN0cmVhbTsBABNqYXZhL2lvL1ByaW50U3RyZWFtAQAHcHJpbnRsbgEAFShMamF2YS9sYW5nL1N0cmluZzspVgAhAAUABgAAAAAAAgABAAcACAABAAkAAAAdAAEAAQAAAAUqtwABsQAAAAEACgAAAAYAAQAAAAQAAQALAAgAAQAJAAAAJQACAAEAAAAJsgACEgO2AASxAAAAAQAKAAAACgACAAAABgAIAAcAAQAMAAAAAgAN</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过以下方法可以自定义ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yonghongwang#163.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021/4/2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> HelloClassLoader().findClass(<span class="string">&quot;Hello&quot;</span>).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String helloBase64 = <span class="string">&quot;yv66vgAAADQAHAoABgAOCQAPABAIABEKABIAEwcAFAcAFQEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAAVoZWxsbwEAClNvdXJjZUZpbGUBAApIZWxsby5qYXZhDAAHAAgHABYMABcAGAEAE0hlbGxvLCBjbGFzc0xvYWRlciEHABkMABoAGwEABUhlbGxvAQAQamF2YS9sYW5nL09iamVjdAEAEGphdmEvbGFuZy9TeXN0ZW0BAANvdXQBABVMamF2YS9pby9QcmludFN0cmVhbTsBABNqYXZhL2lvL1ByaW50U3RyZWFtAQAHcHJpbnRsbgEAFShMamF2YS9sYW5nL1N0cmluZzspVgAhAAUABgAAAAAAAgABAAcACAABAAkAAAAdAAEAAQAAAAUqtwABsQAAAAEACgAAAAYAAQAAAAQAAQALAAgAAQAJAAAAJQACAAEAAAAJsgACEgO2AASxAAAAAQAKAAAACgACAAAABgAIAAcAAQAMAAAAAgAN&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = decode(helloBase64);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] decode(String base64) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getDecoder().decode(base64);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加类的几种方式？"><a href="#添加类的几种方式？" class="headerlink" title="添加类的几种方式？"></a>添加类的几种方式？</h2><ol><li>放到 JDK 的 lib/ext 下，或者 -Djava.ext.dirs=path</li><li>java -cp/classpath 或者 class 文件放到当前路径</li><li>自定义 ClassLoader 加载</li><li>拿到当前执行类的 ClassLoader，反射调用 addUrl 方法添加 Jar 或路径（JDK 9 之后平级了，可以使用 <code>Class.forName(&quot;xxx&quot;, new URLClassLoader(&quot;path&quot;));</code>）</li></ol><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>自定义一个 Classloader，加载一个 Hello.xlass 文件，执行 hello 方法， 此文件内容是一个 Hello.class 文件所有字节(x=255-x)处理后的文件。</p><p>题解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yonghongwang#163.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassloader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; helloClass = <span class="keyword">new</span> MyClassloader().findClass(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        Method helloMethod = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            helloMethod = helloClass.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            helloMethod.invoke(helloClass.newInstance());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) &#123;</span><br><span class="line">        String path = <span class="keyword">this</span>.getClass().getResource(<span class="string">&quot;Hello.xlass&quot;</span>).getPath();</span><br><span class="line">        File file;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file = <span class="keyword">new</span> File(URLDecoder.decode(path, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;failed to find path: &quot;</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile() &amp;&amp; file.exists()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (FileChannel channel = <span class="keyword">new</span> FileInputStream(file).getChannel()) &#123;</span><br><span class="line">                ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="keyword">int</span>) channel.size());</span><br><span class="line">                channel.read(byteBuffer);</span><br><span class="line">                bytes = byteBuffer.array();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;failed to find path: &quot;</span> + path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;failed to find path: &quot;</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, decode(bytes), <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * replace each byte with x-&gt;255-x</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] decode(<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line"><span class="comment">//            bytes[i] = (byte) (255 - bytes[i]);</span></span><br><span class="line">            bytes[i] = (<span class="keyword">byte</span>) ~bytes[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;类加载子系统作用&quot;&gt;&lt;a href=&quot;#类加载子系统作用&quot; class=&quot;headerlink&quot; title=&quot;类加载子系统作用&quot;&gt;&lt;/a&gt;类加载子系统作用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;类加载子系统负责从文件系统或者网络中加载 Class 文件，Class 文件在文件开头有特定的文件标识（cafebabe）&lt;/li&gt;
&lt;li&gt;ClassLoader 只负责 Class 文件的加载，至于它是否能够运行，则由 Execution Engine 决定&lt;/li&gt;
&lt;li&gt;加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区还存放运行时常量池信息，可能还包含字符串字面值和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 02 —— 是时候了解一下 Java 字节码了</title>
    <link href="http://yonghong.tech/java-advance/02-jvm-bytecode/"/>
    <id>http://yonghong.tech/java-advance/02-jvm-bytecode/</id>
    <published>2021-05-14T14:00:00.000Z</published>
    <updated>2021-05-14T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是字节码？"><a href="#什么是字节码？" class="headerlink" title="什么是字节码？"></a>什么是字节码？</h2><ul><li><p>我们平时所说的 Java 字节码，指的是用 Java 语言编译成的字节码。准确的说能在 JVM 平台上执行的字节码格式都是一样的。所以应该统称为 JVM 字节码。</p></li><li><p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的 JVM 上运行。</p></li><li><p>Java 虚拟机与 Java 语言并没有必然的联系，它只与特定的二进制文件格式 .class 文件格式所关联，.class 文件中包含了 Java 虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他的辅助信息。</p></li><li><p>Java bytecode 由单字节（byte）的指令组成，理论上最多支持 256 个操作码（opcode）。 实际上 Java 只使用了200左右的操作码，还有一些操作码则保留给调试操作。详情见：</p></li><li><p><a href="https://yonghong.tech/2021/01/jvm-instruction-set/">JVM 指令集对照表</a></p></li></ul><span id="more"></span><p>根据指令的性质，主要分为四个大类：</p><ol><li>栈操作指令，包括与局部变量交互的指令</li><li>程序流程控制指令</li><li>对象操作指令，包括方法调用指令</li><li>算术运算以及类型转换指令</li></ol><p>举个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloByteCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloByteCode obj = <span class="keyword">new</span> HelloByteCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac -g HelloByteCode.java</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> javap -c -v HelloByteCode</span></span><br><span class="line">Classfile /Users/yonghong/Coding/code-lab/gtu-java/week01/HelloByteCode.class</span><br><span class="line">  Last modified 2021-1-7; size 415 bytes</span><br><span class="line">  MD5 checksum 44dd68d97fffda0bd16a524fb32b983a</span><br><span class="line">  Compiled from &quot;HelloByteCode.java&quot;</span><br><span class="line">public class HelloByteCode</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52   // 52 对应 Java 8</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:        // 常量池</span><br><span class="line"><span class="meta">   #</span><span class="bash">1 = Methodref          <span class="comment">#4.#19         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">2 = Class              <span class="comment">#20            // HelloByteCode</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">3 = Methodref          <span class="comment">#2.#19         // HelloByteCode.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">4 = Class              <span class="comment">#21            // java/lang/Object</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">5 = Utf8               &lt;init&gt;</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">6 = Utf8               ()V</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">7 = Utf8               Code</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">8 = Utf8               LineNumberTable</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">9 = Utf8               LocalVariableTable</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">10 = Utf8               this</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">11 = Utf8               LHelloByteCode;</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">12 = Utf8               main</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">13 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">14 = Utf8               args</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">15 = Utf8               [Ljava/lang/String;</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">16 = Utf8               obj</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">17 = Utf8               SourceFile</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">18 = Utf8               HelloByteCode.java</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">19 = NameAndType        <span class="comment">#5:#6          // &quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash">20 = Utf8               HelloByteCode</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">21 = Utf8               java/lang/Object</span></span><br><span class="line">&#123;</span><br><span class="line">  public HelloByteCode();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   LHelloByteCode;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=1</span><br><span class="line">         0: new           #2                  // class HelloByteCode</span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0   // new 指令在源码的第 3 行</span><br><span class="line">        line 4: 8   // return 指令在源码的第 4 行</span><br><span class="line">      LocalVariableTable:   // 本地变量表</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">      // 起作用的行  生效范围  槽数  变量名称  变量类型签名</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">            8       1     1   obj   LHelloByteCode;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;HelloByteCode.java&quot;</span><br></pre></td></tr></table></figure><h3 id="javac-与-javap"><a href="#javac-与-javap" class="headerlink" title="javac 与 javap"></a>javac 与 javap</h3><p>javac 的用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac -<span class="built_in">help</span></span></span><br><span class="line">用法: javac &lt;options&gt; &lt;source files&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -g                         生成所有调试信息</span><br><span class="line">  -g:none                    不生成任何调试信息</span><br><span class="line">  -g:&#123;lines,vars,source&#125;     只生成某些调试信息</span><br><span class="line">  -nowarn                    不生成任何警告</span><br><span class="line">  -verbose                   输出有关编译器正在执行的操作的消息</span><br><span class="line">  -deprecation               输出使用已过时的 API 的源位置</span><br><span class="line">  -classpath &lt;路径&gt;            指定查找用户类文件和注释处理程序的位置</span><br><span class="line">  -cp &lt;路径&gt;                   指定查找用户类文件和注释处理程序的位置</span><br><span class="line">  -sourcepath &lt;路径&gt;           指定查找输入源文件的位置</span><br><span class="line">  -bootclasspath &lt;路径&gt;        覆盖引导类文件的位置</span><br><span class="line">  -extdirs &lt;目录&gt;              覆盖所安装扩展的位置</span><br><span class="line">  -endorseddirs &lt;目录&gt;         覆盖签名的标准路径的位置</span><br><span class="line">  -proc:&#123;none,only&#125;          控制是否执行注释处理和/或编译。</span><br><span class="line">  -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程</span><br><span class="line">  -processorpath &lt;路径&gt;        指定查找注释处理程序的位置</span><br><span class="line">  -parameters                生成元数据以用于方法参数的反射</span><br><span class="line">  -d &lt;目录&gt;                    指定放置生成的类文件的位置</span><br><span class="line">  -s &lt;目录&gt;                    指定放置生成的源文件的位置</span><br><span class="line">  -h &lt;目录&gt;                    指定放置生成的本机标头文件的位置</span><br><span class="line">  -implicit:&#123;none,class&#125;     指定是否为隐式引用文件生成类文件</span><br><span class="line">  -encoding &lt;编码&gt;             指定源文件使用的字符编码</span><br><span class="line">  -source &lt;发行版&gt;              提供与指定发行版的源兼容性</span><br><span class="line">  -target &lt;发行版&gt;              生成特定 VM 版本的类文件</span><br><span class="line">  -profile &lt;配置文件&gt;            请确保使用的 API 在指定的配置文件中可用</span><br><span class="line">  -version                   版本信息</span><br><span class="line">  -help                      输出标准选项的提要</span><br><span class="line">  -A关键字[=值]                  传递给注释处理程序的选项</span><br><span class="line">  -X                         输出非标准选项的提要</span><br><span class="line">  -J&lt;标记&gt;                     直接将 &lt;标记&gt; 传递给运行时系统</span><br><span class="line">  -Werror                    出现警告时终止编译</span><br><span class="line">  @&lt;文件名&gt;                     从文件读取选项和文件名</span><br></pre></td></tr></table></figure><p>javap 的用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javap -<span class="built_in">help</span></span></span><br><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -help  --help  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -public                  仅显示公共类和成员</span><br><span class="line">  -protected               显示受保护的/公共类和成员</span><br><span class="line">  -package                 显示程序包/受保护的/公共类</span><br><span class="line">                           和成员 (默认)</span><br><span class="line">  -p  -private             显示所有类和成员</span><br><span class="line">  -c                       对代码进行反汇编</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的</span><br><span class="line">                           系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">  -cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure><h2 id="字节码的运行时结构"><a href="#字节码的运行时结构" class="headerlink" title="字节码的运行时结构"></a>字节码的运行时结构</h2><p>JVM 是一台基于栈的计算机器。</p><p>每个线程都有一个独属于自己的线程栈（JVM Stack），用于存储 栈帧（Frame）。 每一次方法调用，JVM 都会自动创建一个栈帧。栈帧由操作数栈，局部变量数组以及一个 Class 引用组成。Class 引用指向当前方法在运行时常量池中对应的 Class。</p><h2 id="从助记符到二进制"><a href="#从助记符到二进制" class="headerlink" title="从助记符到二进制"></a>从助记符到二进制</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-05-%E4%BB%8E%E5%8A%A9%E8%AE%B0%E7%AC%A6%E5%88%B0%E4%BA%8C%E8%BF%9B%E5%88%B6-1rl8Dp.png" alt="从助记符到二进制"></p><h2 id="四则运行的例子"><a href="#四则运行的例子" class="headerlink" title="四则运行的例子"></a>四则运行的例子</h2><p>MovingAverage.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> sum = <span class="number">0.0D</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(<span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">        <span class="keyword">this</span>.sum += value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAvg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="keyword">this</span>.count) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sum / <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LocalVaribleTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVaribleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MovingAverage ma = <span class="keyword">new</span> MovingAverage();</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line">        ma.submit(num1);</span><br><span class="line">        ma.submit(num2);</span><br><span class="line">        <span class="keyword">double</span> avg = ma.getAvg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javap -c MovingAverage</span></span><br><span class="line">Compiled from &quot;MovingAverage.java&quot;</span><br><span class="line">public class MovingAverage &#123;</span><br><span class="line">  public MovingAverage();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: aload_0</span><br><span class="line">       5: iconst_0</span><br><span class="line">       6: putfield      #2                  // Field count:I</span><br><span class="line">       9: aload_0</span><br><span class="line">      10: dconst_0</span><br><span class="line">      11: putfield      #3                  // Field sum:D</span><br><span class="line">      14: return</span><br><span class="line"></span><br><span class="line">  public void submit(double);</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: dup</span><br><span class="line">       2: getfield      #2                  // Field count:I</span><br><span class="line">       5: iconst_1</span><br><span class="line">       6: iadd</span><br><span class="line">       7: putfield      #2                  // Field count:I</span><br><span class="line">      10: aload_0</span><br><span class="line">      11: dup</span><br><span class="line">      12: getfield      #3                  // Field sum:D</span><br><span class="line">      15: dload_1</span><br><span class="line">      16: dadd</span><br><span class="line">      17: putfield      #3                  // Field sum:D</span><br><span class="line">      20: return</span><br><span class="line"></span><br><span class="line">  public double getAvg();</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_0</span><br><span class="line">       1: aload_0</span><br><span class="line">       2: getfield      #2                  // Field count:I</span><br><span class="line">       5: if_icmpne     13</span><br><span class="line">       8: aload_0</span><br><span class="line">       9: getfield      #3                  // Field sum:D</span><br><span class="line">      12: dreturn</span><br><span class="line">      13: aload_0</span><br><span class="line">      14: getfield      #3                  // Field sum:D</span><br><span class="line">      17: aload_0</span><br><span class="line">      18: getfield      #2                  // Field count:I</span><br><span class="line">      21: i2d</span><br><span class="line">      22: ddiv</span><br><span class="line">      23: dreturn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> javap -c LocalVaribleTest</span></span><br><span class="line">Compiled from &quot;LocalVaribleTest.java&quot;</span><br><span class="line">public class LocalVaribleTest &#123;</span><br><span class="line">  public LocalVaribleTest();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class MovingAverage</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #3                  // Method MovingAverage.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: iconst_1</span><br><span class="line">       9: istore_2</span><br><span class="line">      10: iconst_2</span><br><span class="line">      11: istore_3</span><br><span class="line">      12: aload_1</span><br><span class="line">      13: iload_2</span><br><span class="line">      14: i2d   // int 转成 double 隐式转换</span><br><span class="line">      15: invokevirtual #4                  // Method MovingAverage.submit:(D)V</span><br><span class="line">      18: aload_1</span><br><span class="line">      19: iload_3</span><br><span class="line">      20: i2d</span><br><span class="line">      21: invokevirtual #4                  // Method MovingAverage.submit:(D)V</span><br><span class="line">      24: aload_1</span><br><span class="line">      25: invokevirtual #5                  // Method MovingAverage.getAvg:()D</span><br><span class="line">      28: dstore        4</span><br><span class="line">      30: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算数操作与类型转换"><a href="#算数操作与类型转换" class="headerlink" title="算数操作与类型转换"></a>算数操作与类型转换</h2><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-20-09-01-%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-D45qpJ.png" alt="算数操作与类型转换"></p><h2 id="一个完整的循环控制"><a href="#一个完整的循环控制" class="headerlink" title="一个完整的循环控制"></a>一个完整的循环控制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForLoopTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MovingAverage ma = <span class="keyword">new</span> MovingAverage();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            ma.submit(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> avg = ma.getAvg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javap -c ForLoopTest</span></span><br><span class="line">Compiled from &quot;ForLoopTest.java&quot;</span><br><span class="line">public class ForLoopTest &#123;</span><br><span class="line">  public ForLoopTest();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class MovingAverage</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #3                  // Method MovingAverage.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: getstatic     #4                  // Field nums:[I</span><br><span class="line">      11: astore_2</span><br><span class="line">      12: aload_2</span><br><span class="line">      13: arraylength</span><br><span class="line">      14: istore_3</span><br><span class="line">      15: iconst_0                // 初始化变量 0</span><br><span class="line">      16: istore        4         // 存储到本地变量表 4 槽位</span><br><span class="line">      18: iload         4         // 加载 4 槽位 到操作数栈</span><br><span class="line">      20: iload_3                 // 加载 int 3 到操作数栈</span><br><span class="line">      21: if_icmpge     43        // 比较，如果大于等于跳转到 43 行指令</span><br><span class="line">      24: aload_2</span><br><span class="line">      25: iload         4</span><br><span class="line">      27: iaload</span><br><span class="line">      28: istore        5</span><br><span class="line">      30: aload_1</span><br><span class="line">      31: iload         5</span><br><span class="line">      33: i2d</span><br><span class="line">      34: invokevirtual #5                  // Method MovingAverage.submit:(D)V</span><br><span class="line">      37: iinc          4, 1      // 4 槽位上加 1</span><br><span class="line">      40: goto          18        // goto 18 行指令</span><br><span class="line">      43: aload_1</span><br><span class="line">      44: invokevirtual #6                  // Method MovingAverage.getAvg:()D</span><br><span class="line">      47: dstore_2</span><br><span class="line">      48: return</span><br><span class="line"></span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_3</span><br><span class="line">       1: newarray       int</span><br><span class="line">       3: dup</span><br><span class="line">       4: iconst_0</span><br><span class="line">       5: iconst_1</span><br><span class="line">       6: iastore</span><br><span class="line">       7: dup</span><br><span class="line">       8: iconst_1</span><br><span class="line">       9: bipush        6</span><br><span class="line">      11: iastore</span><br><span class="line">      12: dup</span><br><span class="line">      13: iconst_2</span><br><span class="line">      14: bipush        8</span><br><span class="line">      16: iastore</span><br><span class="line">      17: putstatic     #4                  // Field nums:[I</span><br><span class="line">      20: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法调用的指令"><a href="#方法调用的指令" class="headerlink" title="方法调用的指令"></a>方法调用的指令</h2><ul><li>invokestatic，顾名思义，这个指令用于调用某个类的静态方法，这是方法调用指令中最快的一个。</li><li>invokespecial, 用来调用构造函数，但也可以用于调用同一个类中的 private 方法, 以及可见的超类方法。</li><li>invokevirtual，如果是具体类型的目标对象，invokevirtual 用于调用公共，受保护和 package 级的私有方法。</li><li>invokeinterface，当通过接口引用来调用方法时，将会编译为 invokeinterface 指令。</li><li>invokedynamic，JDK7 新增加的指令，是实现“动态类型语言”（Dynamically Typed Language）支持而进行的升级改进，同时也是 JDK8 以后支持 lambda 表达式的实现基础。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是字节码？&quot;&gt;&lt;a href=&quot;#什么是字节码？&quot; class=&quot;headerlink&quot; title=&quot;什么是字节码？&quot;&gt;&lt;/a&gt;什么是字节码？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我们平时所说的 Java 字节码，指的是用 Java 语言编译成的字节码。准确的说能在 JVM 平台上执行的字节码格式都是一样的。所以应该统称为 JVM 字节码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的 JVM 上运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java 虚拟机与 Java 语言并没有必然的联系，它只与特定的二进制文件格式 .class 文件格式所关联，.class 文件中包含了 Java 虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他的辅助信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java bytecode 由单字节（byte）的指令组成，理论上最多支持 256 个操作码（opcode）。 实际上 Java 只使用了200左右的操作码，还有一些操作码则保留给调试操作。详情见：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://yonghong.tech/2021/01/jvm-instruction-set/&quot;&gt;JVM 指令集对照表&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 进阶 01 —— 5 分钟回顾一下 Java 基础知识</title>
    <link href="http://yonghong.tech/java-advance/01-jvm-basic/"/>
    <id>http://yonghong.tech/java-advance/01-jvm-basic/</id>
    <published>2021-05-14T13:00:00.000Z</published>
    <updated>2021-05-14T13:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-生态圈"><a href="#Java-生态圈" class="headerlink" title="Java 生态圈"></a>Java 生态圈</h2><p>Java 是目前应用最为广泛的软件开发平台之一。随着 Java 以及 Java 社区的不断壮大，Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p><ul><li>作为一个平台：Java 虚拟机扮演着举足轻重的作用。<ul><li>Groovy、Scala、JRuby、Kotlin 等都是 Java 平台的一部分。</li></ul></li><li>作为一种文化：Java 几乎成为了开源的代名词<ul><li>第三方开源软件和框架，如，Tomcat、Struts、MyBatis、Spring 等</li><li>就连 JDK 和 JVM 自身也有不少开源的实现，如 OpenJDK、Harmony</li></ul></li><li>作为一个社区，Java 拥有全世界最多的技术拥护者和开源社区的支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到 Java 的身影。其应用形式之复杂、参与人数之众也令人咋舌。</li></ul><span id="more"></span><h2 id="Java-跨平台的语言"><a href="#Java-跨平台的语言" class="headerlink" title="Java 跨平台的语言"></a>Java 跨平台的语言</h2><h3 id="Java-虚拟机规范"><a href="#Java-虚拟机规范" class="headerlink" title="Java 虚拟机规范"></a>Java 虚拟机规范</h3><p>The Java Virtual Machine is the cornerstone of the Java platform. <strong>It is the component of the technology responsible for its hardware- and operating system-independence</strong>, the small size of its compiled code, and its ability to protect users from malicious programs.</p><p>The Java Virtual Machine is an abstract computing machine. Like a real computing machine, it has an instruction set and manipulates various memory areas at run time. It is reasonably common to implement a programming language using a virtual machine; the best-known virtual machine may be the P-Code machine of UCSD Pascal.</p><h3 id="JVM-跨语言的平台"><a href="#JVM-跨语言的平台" class="headerlink" title="JVM 跨语言的平台"></a>JVM 跨语言的平台</h3><p>随着 Java 7 的正式发布，Java 虚拟机的设计者们通过 JSR-292 规范基本实现在 Java 虚拟机平台上运行非 Java 语言编写的程序。</p><p>Java 虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说，Java 虚拟机拥有语言无关性，并不会单纯地与 Java 语言“终身绑定”，只要其他编程语言的编译结果满足并包含 Java 虚拟机的内部指令集，符号表以及其他的辅助信息，他就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</p><p><img src="https://up-img.yonghong.tech/pic/2021/04/03-19-34-orUTHy-CAZ1Zb.png" alt="Java 跨平台的语言"></p><p><img src="https://up-img.yonghong.tech/pic/2021/04/02-19-40-%E6%BA%90%E7%A0%81%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%B7%A8%E5%B9%B3%E5%8F%B0-R6Uzxy.png" alt="源码跨平台和二进制跨平台"></p><ul><li>Java、C++、Rust 的区别<ul><li>C/C++ 完全相信而且惯着程序员，让大家自行管理内存，可以编写很自由的代码，但一 不小心就会造成内存泄漏等问题，导致程序崩溃。</li><li>Java/Golang 完全不相信程序员，但也惯着程序员。所有的内存生命周期都由 JVM 运行 时统一管理。 在绝大部分场景下，你可以非常自由的写代码，而且不用关心内存到底是 什么情况。 内存使用有问题的时候，我们可以通过 JVM 来进行信息相关的分析诊断和 调整。 这也是本课程的目标。</li><li>Rust 语言选择既不相信程序员，也不惯着程序员。 让你在写代码的时候，必须清楚明白 的用 Rust 的规则管理好你的变量，好让机器能明白高效地分析和管理内存。 但是这样 会导致代码不利于人的理解，写代码很不自由，学习成本也很高。</li></ul></li></ul><h3 id="多语言混合编程"><a href="#多语言混合编程" class="headerlink" title="多语言混合编程"></a>多语言混合编程</h3><p>Java 平台上的多语言混合编程正在成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</p><p>试想一下，在一个项目之中，并行处理使用 Clojure 语言编写，展示层使用 JRuby/Rails，中间层则是 Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生 API 一样方便，因为他们最终都运行在一个虚拟机之上。</p><p>对于这些运行在虚拟机之上、Java 语言之外的语言，来自系统级的、底层的支持正在迅速增强，以 JSR-292 为核心的一系列项目和功能改进（如，Davinci Machine 项目、Nashorn 引擎、InvokeDynamic 指令、java.lang.invoke 包等），推动 Java 虚拟机从 Java 语言的虚拟机向多语言虚拟机发展。</p><h3 id="两种架构"><a href="#两种架构" class="headerlink" title="两种架构"></a>两种架构</h3><p>Java 编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构。</p><p>具体来说两种架构之间的区别：</p><ul><li>基于栈式架构的特点<ul><li>设计和实现更简单，适用于资源受限的系统；</li><li>避开了寄存器的分配难题：使用零地址指令方式分配；</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作数。指令集更小，编译器容易实现；</li><li>不需要硬件支持，可移植性更好，更好实现跨平台。</li></ul></li><li>基于寄存器架构的特点<ul><li>典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机；</li><li>指令集架构则完全依赖硬件，可移植性差；</li><li>性能优秀和执行更高效；</li><li>花费更少的指令去完成一项操作；</li><li>在大部分情况下，基于寄存器架构的指令集往往都是一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。</li></ul></li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>同样执行 2+3 这种逻辑操作，其指令分别如下：</p><p>基于栈的计算流程（以 Java 虚拟机为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iconst_2 <span class="comment">// 常量 2 入栈</span></span><br><span class="line">istore_1</span><br><span class="line">iconst_3 <span class="comment">// 常量 3 入栈</span></span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd     <span class="comment">// 常量 2、3 出栈，执行相加</span></span><br><span class="line">istore_0 <span class="comment">// 结果 5 入栈</span></span><br></pre></td></tr></table></figure><p>而基于寄存器的计算流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,<span class="number">2</span>  <span class="comment">// 将 eax 寄存器的值设置为 2</span></span><br><span class="line">mov eax,<span class="number">3</span>  <span class="comment">// 使 eax 寄存器的值加 3</span></span><br></pre></td></tr></table></figure><p>代码演示一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackStruTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">cd chapter_01</span><br><span class="line">javac StackStruTest.java</span><br><span class="line">javap -v StackStruTest</span><br><span class="line">Classfile /Users/yonghong/Coding/jvm/song/chapter_01/StackStruTest.class</span><br><span class="line">  Last modified 2020-11-17; size 277 bytes</span><br><span class="line">  MD5 checksum 9a7da6f68b8101238c5ab826d90154c5</span><br><span class="line">  Compiled from &quot;StackStruTest.java&quot;</span><br><span class="line">public class StackStruTest</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line"><span class="meta">   #</span><span class="bash">1 = Methodref          <span class="comment">#3.#12         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">2 = Class              <span class="comment">#13            // StackStruTest</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">3 = Class              <span class="comment">#14            // java/lang/Object</span></span></span><br><span class="line"><span class="meta">   #</span><span class="bash">4 = Utf8               &lt;init&gt;</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">5 = Utf8               ()V</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">6 = Utf8               Code</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">7 = Utf8               LineNumberTable</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">8 = Utf8               main</span></span><br><span class="line"><span class="meta">   #</span><span class="bash">9 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">10 = Utf8               SourceFile</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">11 = Utf8               StackStruTest.java</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">12 = NameAndType        <span class="comment">#4:#5          // &quot;&lt;init&gt;&quot;:()V</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash">13 = Utf8               StackStruTest</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">14 = Utf8               java/lang/Object</span></span><br><span class="line">&#123;</span><br><span class="line">  public StackStruTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 2: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=2, args_size=1</span><br><span class="line">         0: iconst_5 // 直接返回了 5</span><br><span class="line">         1: istore_1</span><br><span class="line">         2: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 4: 0</span><br><span class="line">        line 5: 2</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;StackStruTest.java&quot;</span><br></pre></td></tr></table></figure><p>由于跨平台的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的。优点是跨平台、指令集小，编译器容易实现；缺点是性能下降，实现同样的功能需要更多的指令。</p><p>时至今日，尽管嵌入式平台已经不是 Java 程序的主流运行平台了（准确来说是 HotSpot 虚拟机的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p><p>答：基于栈式架构的虚拟机跨平台、指令集小，编译器容易实现，在非资源受限的场景中也是可以使用的。</p><h2 id="JVM-的生命周期"><a href="#JVM-的生命周期" class="headerlink" title="JVM 的生命周期"></a>JVM 的生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java 虚拟机的启动时通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ul><li>一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序；</li><li>程序开始执行时他才运行，程序结束时他就停止；</li><li>执行一个所谓的 Java 程序的时候，真真正正在执行的是一个叫做 Java 虚拟机的进程。</li></ul><h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p>有如下的几种情况：</p><ul><li>程序正常执行结束；</li><li>程序在执行过程中遇到了异常或错误而异常终止；</li><li>由于操作系统出现错误而导致 Java 虚拟机进程终止；</li><li>某线程调用 Runtime 类或 System 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或者 halt 操作；</li><li>除此之外，JNI（Java Native Interface）规范中描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时 Java 虚拟机的退出情况。</li></ul><h2 id="JVM-发展历程"><a href="#JVM-发展历程" class="headerlink" title="JVM 发展历程"></a>JVM 发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ul><li>早在 1996 年 Java 1.0 版本的时候，Sun 公司发布了一款名为 Sun Classic VM 的 Java 虚拟机，它同时也是世界上第一款商用 Java 虚拟机，JDK 1.4 时完全被淘汰。</li><li>这款虚拟机内部只提供解释器。</li><li>如果使用 JIT 编译器，就需要进行外挂。但是一旦使用了 JIT 编译器，JIT 就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li><li>现在 HotSpot 内置了此虚拟机。</li></ul><h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><ul><li>为了解决上一个虚拟机问题，JDK 1.2 时，Sun 提供了此虚拟机；</li><li>Exact Memory Management: 准确式内存管理；<ul><li>也可以叫 Non-Conservative/Accurate Memory Management</li><li>虚拟机可以知道内存中某个位置的数据具体是什么类型</li></ul></li><li>具备现代高性能虚拟机的雏形<ul><li>热点探测</li><li>编译器与解释器混合工作模式</li></ul></li><li>只在 Solaris 平台短暂使用，其他平台上还是 Classic VM<ul><li>英雄气短，终被 HotSpot 虚拟机替换</li></ul></li></ul><h3 id="HotSpot"><a href="#HotSpot" class="headerlink" title="HotSpot"></a>HotSpot</h3><ul><li>HotSpot 历史<ul><li>最初由一家名为 Longview Technologies 的小公司设计</li><li>1997 年，此公司被 Sun 收购；2009 年，Sun 公司被 Oracle 收购</li><li>JDK 1.3 时，HotSpot VM 成为默认虚拟机</li></ul></li><li>目前 HotSpot 占有绝对的市场地位，称霸武林<ul><li>现在使用比较多的 JDK 8、JDK 11中默认的虚拟机是 HotSpot</li><li>Sun/Oracle JDk 和 OpenJDK 的默认虚拟机</li></ul></li><li>从服务端、桌面端、嵌入式都有应用</li><li>名称中的 HotSpot 指的就是它的热点代码探测技术<ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li><li>通过编译器与解释器协同工作，在最优的程序响应时间与最佳执行性能中取得平衡</li></ul></li></ul><h3 id="BEA-的-JRockit"><a href="#BEA-的-JRockit" class="headerlink" title="BEA 的 JRockit"></a>BEA 的 JRockit</h3><ul><li>专注于服务器应用<ul><li>它可以不太关注程序启动速度，因此 JRockit 内部不包含解释器实现，全部代码都是靠即时编译器编译后执行</li></ul></li><li>大量的行业基准测试显示，JRockit JVM 是世界上最快的 JVM。<ul><li>使用 JRockit 产品，客户已经体验带了显著的性能提高（一些超过了 70%）和硬件成本的减少（达50%）。</li></ul></li><li>优势：全面的 Java 运行时解决方案组合<ul><li>JRockit 面向延迟敏感型应用的解决方案 JRockit Real Time 提供以毫秒或微秒级的 JVM 响应时间，适合财务，军事指挥，电信网络的需要。</li><li>MissionControl 服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li></ul></li><li>2008年，BEA 被 Oracle 收购</li></ul><h3 id="IBM-的-J9"><a href="#IBM-的-J9" class="headerlink" title="IBM 的 J9"></a>IBM 的 J9</h3><ul><li>全称：IBM Technology for Java Virtual Machine，简称 IT4J，内部代号 J9</li><li>市场定位与 HotSpot 接近，服务端、桌面应用、嵌入式等多用途 VM</li><li>广泛应用于 IBM 的各种 Java 产品</li><li>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的虚拟机。</li><li>2017左右，IBM 发布了开源 J9 VM，命名为 OpenJ9，交给 Eclipse 基金会管理，也称为 Eclipse OpenJ9</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Java-生态圈&quot;&gt;&lt;a href=&quot;#Java-生态圈&quot; class=&quot;headerlink&quot; title=&quot;Java 生态圈&quot;&gt;&lt;/a&gt;Java 生态圈&lt;/h2&gt;&lt;p&gt;Java 是目前应用最为广泛的软件开发平台之一。随着 Java 以及 Java 社区的不断壮大，Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为一个平台：Java 虚拟机扮演着举足轻重的作用。&lt;ul&gt;
&lt;li&gt;Groovy、Scala、JRuby、Kotlin 等都是 Java 平台的一部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作为一种文化：Java 几乎成为了开源的代名词&lt;ul&gt;
&lt;li&gt;第三方开源软件和框架，如，Tomcat、Struts、MyBatis、Spring 等&lt;/li&gt;
&lt;li&gt;就连 JDK 和 JVM 自身也有不少开源的实现，如 OpenJDK、Harmony&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作为一个社区，Java 拥有全世界最多的技术拥护者和开源社区的支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到 Java 的身影。其应用形式之复杂、参与人数之众也令人咋舌。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Java进阶" scheme="http://yonghong.tech/tags/Java%E8%BF%9B%E9%98%B6/"/>
    
    <category term="JVM" scheme="http://yonghong.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JDK 16 正式发布！</title>
    <link href="http://yonghong.tech/release/jdk-16/"/>
    <id>http://yonghong.tech/release/jdk-16/</id>
    <published>2021-04-03T02:00:00.000Z</published>
    <updated>2021-04-03T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>JDK 16 在 2021 年 3 月 16 日正式发布了，这次发布的主要功能有：</p><ul><li>JEP 338: Vector API (Incubator)</li><li>JEP 347: Enable C++14 Language Features</li><li>JEP 357: Migrate from Mercurial to Git</li><li>JEP 369: Migrate to GitHub</li><li>JEP 376: ZGC: Concurrent Thread-Stack Processing</li><li>JEP 380: Unix-Domain Socket Channels</li><li>JEP 386: Alpine Linux Port</li><li>JEP 387: Elastic Metaspace</li><li>JEP 388: Windows/AArch64 Port</li><li>JEP 389: Foreign Linker API (Incubator)</li><li>JEP 390: Warnings for Value-Based Classes</li><li>JEP 392: Packaging Tool</li><li>JEP 393: Foreign-Memory Access API (Third Incubator)</li><li>JEP 394: Pattern Matching for instanceof</li><li>JEP 395: Records</li><li>JEP 396: Strongly Encapsulate JDK Internals by Default</li><li>JEP 397: Sealed Classes (Second Preview)</li></ul><span id="more"></span><hr><h3 id="JEP-338-Vector-API-Incubator"><a href="#JEP-338-Vector-API-Incubator" class="headerlink" title="JEP 338: Vector API (Incubator)"></a>JEP 338: Vector API (Incubator)</h3><p>Vector API 这是一个新的初始迭代孵化器模块，模块包：<code>jdk.incubator.vector</code>，用于表示在运行时可靠地编译到支持的 CPU 架构上的最佳矢量硬件指令的矢量计算。</p><h3 id="JEP-347-Enable-C-14-Language-Features"><a href="#JEP-347-Enable-C-14-Language-Features" class="headerlink" title="JEP 347: Enable C++14 Language Features"></a>JEP 347: Enable C++14 Language Features</h3><p>允许在 JDK 底层的 C ++ 源代码中使用 C ++ 14 的新语言特性，并且提供了在 HotSpot 虚拟机代码中，哪些代码使用了这些新特性的指南。</p><h3 id="JEP-357-Migrate-from-Mercurial-to-Git"><a href="#JEP-357-Migrate-from-Mercurial-to-Git" class="headerlink" title="JEP 357: Migrate from Mercurial to Git"></a>JEP 357: Migrate from Mercurial to Git</h3><p>将 OpenJDK 社区的源代码存储库从 Mercurial（hg）迁移到 Git。</p><h3 id="JEP-369-Migrate-to-GitHub"><a href="#JEP-369-Migrate-to-GitHub" class="headerlink" title="JEP 369: Migrate to GitHub"></a>JEP 369: Migrate to GitHub</h3><p>在 GitHub 上托管 OpenJDK 社区的 Git 存储库。</p><h3 id="JEP-376-ZGC-Concurrent-Thread-Stack-Processing"><a href="#JEP-376-ZGC-Concurrent-Thread-Stack-Processing" class="headerlink" title="JEP 376: ZGC: Concurrent Thread-Stack Processing"></a>JEP 376: ZGC: Concurrent Thread-Stack Processing</h3><p>ZGC 是一种较新的垃圾回收器，指在解决 HotSpot 虚拟机中的 GC 停顿及可伸缩问题。</p><p>ZGC 最早是在 JDK 11 中集成进来的，在 <a href="https://yonghong.tech/release/jdk-15/">JDK 15</a> 中正式转正。</p><p>这个版本则是为了让 ZGC 支持并发栈处理，解决了最后一个重大瓶颈，把 ZGC 中的线程栈处理从安全点移到了并发阶段。并且还提供了一种机制，使得其他 HotSpot 子系统可以通过该机制延迟处理线程栈。</p><h3 id="JEP-380-Unix-Domain-Socket-Channels"><a href="#JEP-380-Unix-Domain-Socket-Channels" class="headerlink" title="JEP 380: Unix-Domain Socket Channels"></a>JEP 380: Unix-Domain Socket Channels</h3><p>UNIX 域套接字通道，为 <code>java.nio.channels</code> 包中的套接字通道和服务端套接字通道 APIs 增加 Unix 域套接字通道所有特性支持。</p><p>UNIX 域套接字主要用于同一主机上的进程间通信（IPC），大部分方面与 TCP/IP套接字类似，不同的是 UNIX 域套接字是通过文件系统路径名寻址，而不是通过 IP 地址和端口号。</p><h3 id="JEP-386-Alpine-Linux-Port"><a href="#JEP-386-Alpine-Linux-Port" class="headerlink" title="JEP 386: Alpine Linux Port"></a>JEP 386: Alpine Linux Port</h3><p>在 x64 和 AArch64 平台体系结构上，将 JDK 移植到 Alpine Linux 以及使用 musl 作为其主要 C 语言库的其他 Linux 发行版中。</p><h3 id="JEP-387-Elastic-Metaspace"><a href="#JEP-387-Elastic-Metaspace" class="headerlink" title="JEP 387: Elastic Metaspace"></a>JEP 387: Elastic Metaspace</h3><p>弹性的元空间，可以帮助 HotSpot 虚拟机，将元空间中未使用的 class 元数据内存更及时地返回给操作系统，以减少元空间的内存占用空间。</p><p>另外，还简化了元空间的代码，以降低维护成本。</p><h3 id="JEP-388-Windows-AArch64-Port"><a href="#JEP-388-Windows-AArch64-Port" class="headerlink" title="JEP 388: Windows/AArch64 Port"></a>JEP 388: Windows/AArch64 Port</h3><p>将 JDK 移植到 Windows/ AArch64 平台系列。</p><h3 id="JEP-389-Foreign-Linker-API-Incubator"><a href="#JEP-389-Foreign-Linker-API-Incubator" class="headerlink" title="JEP 389: Foreign Linker API (Incubator)"></a>JEP 389: Foreign Linker API (Incubator)</h3><p>引入了一个新的 API，该 API 提供了对本地 native 代码的静态类型访问支持。</p><h3 id="JEP-390-Warnings-for-Value-Based-Classes"><a href="#JEP-390-Warnings-for-Value-Based-Classes" class="headerlink" title="JEP 390: Warnings for Value-Based Classes"></a>JEP 390: Warnings for Value-Based Classes</h3><p>基于值的类的警告，将基础类型包装类指定为基于值的类，废除其构造函数以进行删除，从而提示新的弃用警告。并且提供了在任何基于值的类的实例上不正常进行同步的警告。</p><h3 id="JEP-392-Packaging-Tool"><a href="#JEP-392-Packaging-Tool" class="headerlink" title="JEP 392: Packaging Tool"></a>JEP 392: Packaging Tool</h3><p>提供了 jpackage 打包工具，可用于打包独立的 Java 应用程序。</p><p>jpackage 打包工具是在 JDK 14 中首次作为孵化工具引入的新特性，到了 JDK 15 它仍然还在孵化中，现在它终于转正了。</p><h3 id="JEP-393-Foreign-Memory-Access-API-Third-Incubator"><a href="#JEP-393-Foreign-Memory-Access-API-Third-Incubator" class="headerlink" title="JEP 393: Foreign-Memory Access API (Third Incubator)"></a>JEP 393: Foreign-Memory Access API (Third Incubator)</h3><p>外部内存访问 API（三次孵化中），引入了一个新的 API，可以帮助 Java 应用程序更安全、有效地访问 Java 堆之外的外部内存。</p><p>这个最早在 JDK 14 中成为孵化特性，JDK 15/ JDK 16 中继续二、三次孵化并对其 API 有了一些更新，这个可以在 JDK 17 中好好期待一下转正。</p><h3 id="JEP-394-Pattern-Matching-for-instanceof"><a href="#JEP-394-Pattern-Matching-for-instanceof" class="headerlink" title="JEP 394: Pattern Matching for instanceof"></a>JEP 394: Pattern Matching for instanceof</h3><p>模式匹配 for instanceof，相当于是增强的 instanceof，在 JDK 14 中首次成为预览特性，在 JDK 16 中正式转正。</p><p>模式匹配的到来将使得 instanceof 变得更简洁、更安全，为什么这么说，请看下面的示例。</p><p>正常的 instanceof 写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> IPad) &#123;</span><br><span class="line">    IPad iPad = (IPad) object;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> IPhone) &#123;</span><br><span class="line">    IPhone iPhone = (IPhone) object;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模式匹配的 instanceof 写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (object <span class="keyword">instanceof</span> IPad iPad) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> IPhone iPhone) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断、赋值一步到位。</p><h3 id="JEP-395-Records"><a href="#JEP-395-Records" class="headerlink" title="JEP 395: Records"></a>JEP 395: Records</h3><p>简单来说，Records 就是一种新的语法糖，目的还是为了简化代码，在 JDK 14 中首次成为预览特性，在 JDK 16 中正式转正。</p><p>Records 可以在一定程度上避免低级冗余的代码，比如：constructors, getters, equals(), hashCode(), toString() 方法等，相当于 Lombok 的 @Data 注解，但又不能完全替代。</p><h3 id="JEP-396-Strongly-Encapsulate-JDK-Internals-by-Default"><a href="#JEP-396-Strongly-Encapsulate-JDK-Internals-by-Default" class="headerlink" title="JEP 396: Strongly Encapsulate JDK Internals by Default"></a>JEP 396: Strongly Encapsulate JDK Internals by Default</h3><p>JDK 内部默认强封装，JDK 16 开始对 JDK 内部大部分元素默认进行强封装，sun.misc.Unsafe 之类的关键内部 API 除外，从而限制对它们的访问。</p><p>此外，用户仍然可以选择自 JDK 9 以来的默认的宽松的强封装，这样可以帮助用户毫不费力地升级到未来的 Java 版本。</p><h3 id="JEP-397-Sealed-Classes-Second-Preview"><a href="#JEP-397-Sealed-Classes-Second-Preview" class="headerlink" title="JEP 397: Sealed Classes (Second Preview)"></a>JEP 397: Sealed Classes (Second Preview)</h3><p>封闭类（二次预览），可以是封闭类和或者封闭接口，用来增强 Java 编程语言，防止其他类或接口扩展或实现它们。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>官方日志：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0L3Byb2plY3RzL2pkay8xNi8=">https://openjdk.java.net/projects/jdk/16/<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qZGsuamF2YS5uZXQvMTYvcmVsZWFzZS1ub3Rlcw==">https://jdk.java.net/16/release-notes<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;JDK 16 在 2021 年 3 月 16 日正式发布了，这次发布的主要功能有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JEP 338: Vector API (Incubator)&lt;/li&gt;
&lt;li&gt;JEP 347: Enable C++14 Language Features&lt;/li&gt;
&lt;li&gt;JEP 357: Migrate from Mercurial to Git&lt;/li&gt;
&lt;li&gt;JEP 369: Migrate to GitHub&lt;/li&gt;
&lt;li&gt;JEP 376: ZGC: Concurrent Thread-Stack Processing&lt;/li&gt;
&lt;li&gt;JEP 380: Unix-Domain Socket Channels&lt;/li&gt;
&lt;li&gt;JEP 386: Alpine Linux Port&lt;/li&gt;
&lt;li&gt;JEP 387: Elastic Metaspace&lt;/li&gt;
&lt;li&gt;JEP 388: Windows/AArch64 Port&lt;/li&gt;
&lt;li&gt;JEP 389: Foreign Linker API (Incubator)&lt;/li&gt;
&lt;li&gt;JEP 390: Warnings for Value-Based Classes&lt;/li&gt;
&lt;li&gt;JEP 392: Packaging Tool&lt;/li&gt;
&lt;li&gt;JEP 393: Foreign-Memory Access API (Third Incubator)&lt;/li&gt;
&lt;li&gt;JEP 394: Pattern Matching for instanceof&lt;/li&gt;
&lt;li&gt;JEP 395: Records&lt;/li&gt;
&lt;li&gt;JEP 396: Strongly Encapsulate JDK Internals by Default&lt;/li&gt;
&lt;li&gt;JEP 397: Sealed Classes (Second Preview)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="release" scheme="http://yonghong.tech/categories/release/"/>
    
    
    <category term="JDK" scheme="http://yonghong.tech/tags/JDK/"/>
    
    <category term="Java" scheme="http://yonghong.tech/tags/Java/"/>
    
    <category term="release" scheme="http://yonghong.tech/tags/release/"/>
    
    <category term="ZGC" scheme="http://yonghong.tech/tags/ZGC/"/>
    
    <category term="GitHub" scheme="http://yonghong.tech/tags/GitHub/"/>
    
    <category term="Vector" scheme="http://yonghong.tech/tags/Vector/"/>
    
    <category term="Metaspace" scheme="http://yonghong.tech/tags/Metaspace/"/>
    
    <category term="Sealed" scheme="http://yonghong.tech/tags/Sealed/"/>
    
    <category term="instanceof" scheme="http://yonghong.tech/tags/instanceof/"/>
    
  </entry>
  
  <entry>
    <title>【macOS 命令】scutil</title>
    <link href="http://yonghong.tech/macos-command/scutil/"/>
    <id>http://yonghong.tech/macos-command/scutil/</id>
    <published>2021-03-29T12:00:00.000Z</published>
    <updated>2021-03-29T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>管理系统配置参数。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>对系统的用户名和主机名进行修改</p><ul><li>ComputerName 就是电脑名称，给人看的（在下图中，电脑名称）</li><li>HostName 主机名，但通常不会设置这个值</li><li>LocalHostName 主机名，和 Linux 系统的 hostname 一样（在下图中，本地网络中电脑名称）</li></ul><span id="more"></span><p><img src="https://up-img.yonghong.tech/pic/2021/03/29-20-27-%E6%88%AA%E5%B1%8F2021-03-29%20%E4%B8%8B%E5%8D%888.27.22-EnugWj.png" alt="电脑名称、主机名设置"></p><p>hostname 命令取值的顺序：</p><ul><li>hostname 命令设置的值</li><li>HostName 属性值</li><li>LocalHostName 属性值（通常系统都会设置此属性）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看系统主机名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scutil --get ComputerName</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scutil --get HostName</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scutil --get LocalHostName</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改系统主机名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scutil --<span class="built_in">set</span> ComputerName xxx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scutil --<span class="built_in">set</span> HostName xxx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> scutil --<span class="built_in">set</span> LocalHostName xxx</span></span><br></pre></td></tr></table></figure><p>查看 DNS 配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scutil --dns</span></span><br></pre></td></tr></table></figure><p>查看代理信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scutil --proxy</span></span><br></pre></td></tr></table></figure><p>查看网络信息（ipv4/ipv6）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> scutil --nwi</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;管理系统配置参数。&lt;/p&gt;
&lt;h2 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot; title=&quot;用法&quot;&gt;&lt;/a&gt;用法&lt;/h2&gt;&lt;p&gt;对系统的用户名和主机名进行修改&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ComputerName 就是电脑名称，给人看的（在下图中，电脑名称）&lt;/li&gt;
&lt;li&gt;HostName 主机名，但通常不会设置这个值&lt;/li&gt;
&lt;li&gt;LocalHostName 主机名，和 Linux 系统的 hostname 一样（在下图中，本地网络中电脑名称）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="macOS 命令" scheme="http://yonghong.tech/categories/macOS-%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="macOS 命令" scheme="http://yonghong.tech/tags/macOS-%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>MySQL update 语句 set 顺序</title>
    <link href="http://yonghong.tech/2021/03/mysql-update-set-order/"/>
    <id>http://yonghong.tech/2021/03/mysql-update-set-order/</id>
    <published>2021-03-01T14:24:00.000Z</published>
    <updated>2021-03-01T14:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>绝大多数数据库，在执行 update 语句时，update t set a = b, b = a 便可实现 a、b 列值互换，赋值表达式右侧的值取的都是原始值。MySQL 则是例外，其单表更新是自左到右依次完成，即先完成 a = b，然后在完成 b = a (此时 a = b），所以执行结果变成 a、b 列都是 b，然后多表更新则又不尊从该更新法则。</p><p>这个问题源于业务中一次对券有效期进行延期的操作，需求是对优惠券有效期延期 35 天。</p><ul><li>一部分券在生效中，直接修改过期时间即可；</li><li>一部分券已经过期，修改过期时间后，需要判断一下是否仍然是过期的还是生效中的，修改券的状态</li></ul><span id="more"></span><p>所以 SQL 语句大致如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPDATE coupon </span><br><span class="line"><span class="keyword">SET</span> end_time <span class="operator">=</span> DATE_ADD(end_time, <span class="type">INTERVAL</span> <span class="number">35</span> <span class="keyword">DAY</span>), </span><br><span class="line">status <span class="operator">=</span> (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> end_time <span class="operator">&gt;</span> NOW() <span class="keyword">THEN</span> <span class="string">&#x27;生效中&#x27;</span> <span class="keyword">ELSE</span> <span class="string">&#x27;已过期&#x27;</span> <span class="keyword">END</span>), </span><br><span class="line">gmt_modify <span class="operator">=</span> NOW() </span><br><span class="line"><span class="keyword">WHERE</span> ... ;</span><br></pre></td></tr></table></figure><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>这个地方就有个问题，当修改 status 的时候 end_time 到底是原始数据，还是修改后的数据。经过测试，是使用的修改后的数据，接下来去 MySQL 官网中求证一下。</p><h2 id="MySQL-官方文档的说明"><a href="#MySQL-官方文档的说明" class="headerlink" title="MySQL 官方文档的说明"></a>MySQL 官方文档的说明</h2><p>MySQL 官网文档中是这样描述的，当你要更新一个列的时候，UPDATE 语句使用的是这列值的当前值。举个例子：下面这个语句从左到右顺序执行，先执行 col1 = col + 1，此时 col1 已经是加 1 后的值了，执行 col2 = col1 的时候，也是加 1 后的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE t1 <span class="keyword">SET</span> col1 <span class="operator">=</span> col1 <span class="operator">+</span> <span class="number">1</span>, col2 <span class="operator">=</span> col1;</span><br></pre></td></tr></table></figure><p><strong>但是，这个规则只适用于单表的 UPDATE，多表就不适用于这个规则了，多表更新，赋值语句不确保任何给定的顺序执行，可能是原值，也可能是新值。</strong></p><h2 id="MySQL-如何实现两列互换"><a href="#MySQL-如何实现两列互换" class="headerlink" title="MySQL 如何实现两列互换"></a>MySQL 如何实现两列互换</h2><p>编程语言中，实现两个变量互换很简单：引入临时变量 tmp，tmp = a，a = b，b = tmp 即可实现 a、b 互换，但是 SQL 中没有临时变量，又如何实现变量互换呢？解决方案还是使用临时变量（只不过临时变量是某数据列的值，然后后面再覆盖该数据列的值），假设有 a b 列，a = 100，b = 1，实现 a b 互换，我们可以使用通用手法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">=</span> a <span class="operator">+</span> b, <span class="number">101</span></span><br><span class="line">b <span class="operator">=</span> a <span class="operator">-</span> b, <span class="number">100</span></span><br><span class="line">a <span class="operator">=</span> a <span class="operator">-</span> b, <span class="number">1</span></span><br></pre></td></tr></table></figure><p>至此，a = 1, b = 100，实现 a、b 值互换，SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update t <span class="keyword">set</span> a <span class="operator">=</span> a <span class="operator">+</span> b, b <span class="operator">=</span> a <span class="operator">-</span> b, a <span class="operator">=</span> a <span class="operator">-</span> b;</span><br></pre></td></tr></table></figure><h2 id="MySQL-多表更新的例子"><a href="#MySQL-多表更新的例子" class="headerlink" title="MySQL 多表更新的例子"></a>MySQL 多表更新的例子</h2><p>两张表：pur_po_bill_detail（采购单细表），wm_sh_bill_detail（收货单细表），采购后，先根据采购单细表创建收货单，然后根据收货单入库。</p><p><strong>pur_po_bill_detail（采购单细表）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `pur_po_bill_detail` (</span><br><span class="line">  `sid` <span class="type">int</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `bill_id` <span class="type">bigint</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;po单号id&#x27;</span>,</span><br><span class="line">  `bill_no` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单号&#x27;</span>,</span><br><span class="line">  `pw_count` <span class="type">decimal</span>(<span class="number">20</span>,<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;已入库数量&#x27;</span>,</span><br><span class="line">  `th_count` <span class="type">decimal</span>(<span class="number">20</span>,<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;不合格数量&#x27;</span>,</span><br><span class="line">  `bill_status` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`sid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;采购订单细表&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>wm_sh_bill_detail（收货单细表）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `wm_sh_bill_detail` (</span><br><span class="line">  `sid` <span class="type">int</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `bill_id` <span class="type">bigint</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;收货单id&#x27;</span>,</span><br><span class="line">  `bill_no` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ref_number` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> <span class="string">&#x27;采购单号&#x27;</span>,</span><br><span class="line">  `ref_detail_sid` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> <span class="string">&#x27;采购单行项目sid&#x27;</span>,</span><br><span class="line">  `sh_count` <span class="type">decimal</span>(<span class="number">20</span>,<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `in_count` <span class="type">decimal</span>(<span class="number">20</span>,<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `left_count` <span class="type">decimal</span>(<span class="number">20</span>,<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  ...</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY (`sid`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;收货单细表&#x27;</span></span><br></pre></td></tr></table></figure><p>下述sql是在收货单入库时反写采购单细表入库数量、状态。</p><p>当采购单行项目：入库数量 + 不合格退货数量 &gt;= 订单数量，状态变成已入库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPDATE pur_po_bill_detail t0, wm_sh_bill_detail t1</span><br><span class="line"><span class="keyword">set</span> t0.pw_count <span class="operator">=</span> <span class="built_in">coalesce</span>(t0.pw_count,<span class="number">0</span>) <span class="operator">+</span> t1.in_count, </span><br><span class="line">t0.th_count <span class="operator">=</span> <span class="built_in">coalesce</span>(t0.th_count,<span class="number">0</span>) <span class="operator">+</span> <span class="built_in">coalesce</span>(t1.left_count,<span class="number">0</span>),</span><br><span class="line">t0.bill_status <span class="operator">=</span> <span class="keyword">case</span> <span class="keyword">when</span> t0.pw_count <span class="operator">+</span> t0.th_count <span class="operator">&gt;=</span> t0.goods_count <span class="keyword">then</span> <span class="string">&#x27;已入库&#x27;</span> <span class="keyword">else</span> t0.bill_status <span class="keyword">end</span></span><br><span class="line"><span class="keyword">WHERE</span> t0.sid <span class="operator">=</span> t1.ref_detail_sid <span class="keyword">and</span> t1.bill_no <span class="operator">=</span> <span class="string">&#x27;SH20180001&#x27;</span>;</span><br></pre></td></tr></table></figure><p>sql执行结果失败，系mysql多表更新，在case判断时，t0.pw_count, t0.th_count取到的是原值。所以mysql多表更新需要注意：</p><p>赋值语句、case语句尽量避免依赖引用，如本案case使用了赋值语句pw_count,th_count列，所以判断就出问题啦；可通过update语句拆分来实现多表复杂更新目标。</p><p>上述update语句拆分，先更新数量，然后更新状态：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UPDATE pur_po_bill_detail t0, wm_sh_bill_detail t1</span><br><span class="line"><span class="keyword">set</span> t0.pw_count <span class="operator">=</span> <span class="built_in">coalesce</span>(t0.pw_count,<span class="number">0</span>) <span class="operator">+</span> t1.in_count, </span><br><span class="line">t0.th_count <span class="operator">=</span> <span class="built_in">coalesce</span>(t0.th_count,<span class="number">0</span>) <span class="operator">+</span> <span class="built_in">coalesce</span>(t1.left_count,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">WHERE</span> t0.sid <span class="operator">=</span> t1.ref_detail_sid <span class="keyword">and</span> t1.bill_no <span class="operator">=</span> <span class="string">&#x27;SH20180001&#x27;</span>;</span><br><span class="line"></span><br><span class="line">UPDATE pur_po_bill_detail t0, wm_sh_bill_detail t1</span><br><span class="line"><span class="keyword">set</span> t0.bill_status <span class="operator">=</span> <span class="keyword">case</span> <span class="keyword">when</span> t0.pw_count <span class="operator">+</span> t0.th_count <span class="operator">&gt;=</span> t0.goods_count <span class="keyword">then</span> <span class="string">&#x27;已入库&#x27;</span> <span class="keyword">else</span> t0.bill_status <span class="keyword">end</span></span><br><span class="line"><span class="keyword">WHERE</span> t0.sid <span class="operator">=</span> t1.ref_detail_sid <span class="keyword">and</span> t1.bill_no <span class="operator">=</span> <span class="string">&#x27;SH20180001&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="再次回到业务中来"><a href="#再次回到业务中来" class="headerlink" title="再次回到业务中来"></a>再次回到业务中来</h2><p>再次回到业务场景中来，如果采用券的过期时间全部更新这种方式的话，先执行 end_time 延期，再去判断是否过期，这个时候使用的 end_time 已经是修改过的了。</p><p>其实这种更新方式也没有必要，如果券延期后还是过期的，那么其实也可以不更新券的有效期，那么 SQL 就变成了下面这样的。先过滤出延期后是生效状态的券，在进行更新。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UPDATE coupon </span><br><span class="line"><span class="keyword">SET</span> end_time <span class="operator">=</span> DATE_ADD(end_time, <span class="type">INTERVAL</span> <span class="number">35</span> <span class="keyword">DAY</span>), </span><br><span class="line">status <span class="operator">=</span> <span class="string">&#x27;生效中&#x27;</span>, </span><br><span class="line">gmt_modify <span class="operator">=</span> NOW() </span><br><span class="line"><span class="keyword">WHERE</span> ... </span><br><span class="line"><span class="keyword">AND</span> DATE_ADD(end_time, <span class="type">INTERVAL</span> <span class="number">35</span> <span class="keyword">DAY</span>) <span class="operator">&gt;</span> NOW() ;</span><br></pre></td></tr></table></figure><h2 id="MySQL-官方文档原文"><a href="#MySQL-官方文档原文" class="headerlink" title="MySQL 官方文档原文"></a>MySQL 官方文档原文</h2><p>If you access a column from the table to be updated in an expression, <a href="https://dev.mysql.com/doc/refman/8.0/en/update.html"><code>UPDATE</code></a> uses the current value of the column. For example, the following statement sets <code>col1</code> to one more than its current value:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE t1 <span class="keyword">SET</span> col1 <span class="operator">=</span> col1 <span class="operator">+</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>The second assignment in the following statement sets <code>col2</code> to the current (updated) <code>col1</code> value, not the original <code>col1</code> value. The result is that <code>col1</code> and <code>col2</code> have the same value. This behavior differs from standard SQL.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE t1 <span class="keyword">SET</span> col1 <span class="operator">=</span> col1 <span class="operator">+</span> <span class="number">1</span>, col2 <span class="operator">=</span> col1;</span><br></pre></td></tr></table></figure><p>Single-table <a href="https://dev.mysql.com/doc/refman/8.0/en/update.html"><code>UPDATE</code></a> assignments are generally evaluated from left to right. For multiple-table updates, there is no guarantee that assignments are carried out in any particular order.</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NodWFuZ3hpbi9hcnRpY2xlL2RldGFpbHMvODQ1NTgwNTA=">谈谈mysql update语句 set顺序问题、列交换sql实现及多表更新注意事项<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vNS43L2VuL3VwZGF0ZS5odG1s">https://dev.mysql.com/doc/refman/5.7/en/update.html<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vOC4wL2VuL3VwZGF0ZS5odG1s">https://dev.mysql.com/doc/refman/8.0/en/update.html<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;绝大多数数据库，在执行 update 语句时，update t set a = b, b = a 便可实现 a、b 列值互换，赋值表达式右侧的值取的都是原始值。MySQL 则是例外，其单表更新是自左到右依次完成，即先完成 a = b，然后在完成 b = a (此时 a = b），所以执行结果变成 a、b 列都是 b，然后多表更新则又不尊从该更新法则。&lt;/p&gt;
&lt;p&gt;这个问题源于业务中一次对券有效期进行延期的操作，需求是对优惠券有效期延期 35 天。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一部分券在生效中，直接修改过期时间即可；&lt;/li&gt;
&lt;li&gt;一部分券已经过期，修改过期时间后，需要判断一下是否仍然是过期的还是生效中的，修改券的状态&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://yonghong.tech/categories/MySQL/"/>
    
    
    <category term="数据库" scheme="http://yonghong.tech/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="http://yonghong.tech/tags/MySQL/"/>
    
    <category term="UPDATE" scheme="http://yonghong.tech/tags/UPDATE/"/>
    
  </entry>
  
</feed>
